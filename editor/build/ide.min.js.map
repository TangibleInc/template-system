{"version":3,"file":"ide.min.js.map","sources":["../ide/Layout/src/Orientation.ts","../ide/Layout/src/Rect.ts","../ide/Layout/src/DockLocation.ts","../ide/Layout/src/DragDrop.ts","../ide/Layout/src/model/Action.ts","../ide/Layout/src/model/Actions.ts","../ide/Layout/src/Attribute.ts","../ide/Layout/src/AttributeDefinitions.ts","../ide/Layout/src/DropInfo.ts","../ide/Layout/src/Types.ts","../ide/Layout/src/model/Node.ts","../ide/Layout/src/model/SplitterNode.ts","../ide/Layout/src/model/TabNode.ts","../ide/Layout/src/model/RowNode.ts","../ide/Layout/src/model/TabSetNode.ts","../ide/Layout/src/model/Utils.ts","../ide/Layout/src/model/BorderNode.ts","../ide/Layout/src/I18nLabel.ts","../ide/Layout/src/model/ICloseType.ts","../ide/Layout/src/view/Utils.tsx","../ide/Layout/src/view/BorderButton.tsx","../ide/Layout/src/view/TabButtonStamp.tsx","../ide/Layout/src/PopupMenu.tsx","../ide/Layout/src/view/TabOverflowHook.tsx","../ide/Layout/src/view/BorderTabSet.tsx","../ide/Layout/src/view/Splitter.tsx","../ide/Layout/src/view/ErrorBoundary.tsx","../ide/Layout/src/view/Tab.tsx","../ide/Layout/src/view/TabButton.tsx","../ide/Layout/src/view/TabSet.tsx","../ide/Layout/src/view/FloatingWindow.tsx","../ide/Layout/src/view/FloatingWindowTab.tsx","../ide/Layout/src/view/TabFloating.tsx","../ide/Layout/src/view/Icons.tsx","../ide/Layout/src/view/Layout.tsx","../ide/Layout/src/model/BorderSet.ts","../ide/Layout/src/model/Model.ts","../ide/Layout/model.ts","../ide/Editor/index.tsx","../ide/Preview/index.tsx","../ide/Assets/index.tsx","../ide/Location/index.tsx","../ide/Library/index.tsx","../ide/Support/index.tsx","../ide/icons.tsx","../ide/Header/index.tsx","../ide/index.tsx"],"sourcesContent":["export class Orientation {\n    static HORZ = new Orientation(\"horz\");\n    static VERT = new Orientation(\"vert\");\n\n    static flip(from: Orientation) {\n        if (from === Orientation.HORZ) {\n            return Orientation.VERT;\n        } else {\n            return Orientation.HORZ;\n        }\n    }\n\n    /** @internal */\n    private _name: string;\n\n    /** @internal */\n    private constructor(name: string) {\n        this._name = name;\n    }\n\n    getName() {\n        return this._name;\n    }\n\n    toString() {\n        return this._name;\n    }\n}\n","import { Orientation } from \"./Orientation\";\n\nexport class Rect {\n    static empty() {\n        return new Rect(0, 0, 0, 0);\n    }\n\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    constructor(x: number, y: number, width: number, height: number) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    static fromElement(element: Element) {\n        let { x, y, width, height } = element.getBoundingClientRect();\n        return new Rect(x, y, width, height);\n    }\n\n    clone() {\n        return new Rect(this.x, this.y, this.width, this.height);\n    }\n\n    equals(rect: Rect) {\n        if (this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    getBottom() {\n        return this.y + this.height;\n    }\n\n    getRight() {\n        return this.x + this.width;\n    }\n\n    getCenter() {\n        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n    }\n\n    positionElement(element: HTMLElement, position?: string) {\n        this.styleWithPosition(element.style, position);\n    }\n\n    styleWithPosition(style: Record<string, any>, position: string = \"absolute\") {\n        style.left = this.x + \"px\";\n        style.top = this.y + \"px\";\n        style.width = Math.max(0, this.width) + \"px\"; // need Math.max to prevent -ve, cause error in IE\n        style.height = Math.max(0, this.height) + \"px\";\n        style.position = position;\n        return style;\n    }\n\n    contains(x: number, y: number) {\n        if (this.x <= x && x <= this.getRight() && this.y <= y && y <= this.getBottom()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    removeInsets(insets: { top: number; left: number; bottom: number; right: number }) {\n        return new Rect(this.x + insets.left, this.y + insets.top, Math.max(0, this.width - insets.left - insets.right), Math.max(0, this.height - insets.top - insets.bottom));\n    }\n\n    centerInRect(outerRect: Rect) {\n        this.x = (outerRect.width - this.width) / 2;\n        this.y = (outerRect.height - this.height) / 2;\n    }\n\n    /** @internal */\n    _getSize(orientation: Orientation) {\n        let prefSize = this.width;\n        if (orientation === Orientation.VERT) {\n            prefSize = this.height;\n        }\n        return prefSize;\n    }\n\n    toString() {\n        return \"(Rect: x=\" + this.x + \", y=\" + this.y + \", width=\" + this.width + \", height=\" + this.height + \")\";\n    }\n}\n","import { Orientation } from \"./Orientation\";\nimport { Rect } from \"./Rect\";\n\nexport class DockLocation {\n    static values: Record<string, DockLocation> = {};\n    static TOP = new DockLocation(\"top\", Orientation.VERT, 0);\n    static BOTTOM = new DockLocation(\"bottom\", Orientation.VERT, 1);\n    static LEFT = new DockLocation(\"left\", Orientation.HORZ, 0);\n    static RIGHT = new DockLocation(\"right\", Orientation.HORZ, 1);\n    static CENTER = new DockLocation(\"center\", Orientation.VERT, 0);\n\n    /** @internal */\n    static getByName(name: string): DockLocation {\n        return DockLocation.values[name];\n    }\n\n    /** @internal */\n    static getLocation(rect: Rect, x: number, y: number) {\n        x = (x - rect.x) / rect.width;\n        y = (y - rect.y) / rect.height;\n\n        if (x >= 0.25 && x < 0.75 && y >= 0.25 && y < 0.75) {\n            return DockLocation.CENTER;\n        }\n\n        // Whether or not the point is in the bottom-left half of the rect\n        // +-----+\n        // |\\    |\n        // |x\\   |\n        // |xx\\  |\n        // |xxx\\ |\n        // |xxxx\\|\n        // +-----+\n        const bl = y >= x;\n\n        // Whether or not the point is in the bottom-right half of the rect\n        // +-----+\n        // |    /|\n        // |   /x|\n        // |  /xx|\n        // | /xxx|\n        // |/xxxx|\n        // +-----+\n        const br = y >= 1 - x;\n\n        if (bl) {\n            return br ? DockLocation.BOTTOM : DockLocation.LEFT;\n        } else {\n            return br ? DockLocation.RIGHT : DockLocation.TOP;\n        }\n    }\n\n    /** @internal */\n    _name: string;\n    /** @internal */\n    _orientation: Orientation;\n    /** @internal */\n    _indexPlus: number;\n\n    /** @internal */\n    constructor(name: string, orientation: Orientation, indexPlus: number) {\n        this._name = name;\n        this._orientation = orientation;\n        this._indexPlus = indexPlus;\n        DockLocation.values[this._name] = this;\n    }\n\n    getName() {\n        return this._name;\n    }\n\n    getOrientation() {\n        return this._orientation;\n    }\n\n    /** @internal */\n    getDockRect(r: Rect) {\n        if (this === DockLocation.TOP) {\n            return new Rect(r.x, r.y, r.width, r.height / 2);\n        } else if (this === DockLocation.BOTTOM) {\n            return new Rect(r.x, r.getBottom() - r.height / 2, r.width, r.height / 2);\n        }\n        if (this === DockLocation.LEFT) {\n            return new Rect(r.x, r.y, r.width / 2, r.height);\n        } else if (this === DockLocation.RIGHT) {\n            return new Rect(r.getRight() - r.width / 2, r.y, r.width / 2, r.height);\n        } else {\n            return r.clone();\n        }\n    }\n\n    /** @internal */\n    split(rect: Rect, size: number) {\n        if (this === DockLocation.TOP) {\n            const r1 = new Rect(rect.x, rect.y, rect.width, size);\n            const r2 = new Rect(rect.x, rect.y + size, rect.width, rect.height - size);\n            return { start: r1, end: r2 };\n        } else if (this === DockLocation.LEFT) {\n            const r1 = new Rect(rect.x, rect.y, size, rect.height);\n            const r2 = new Rect(rect.x + size, rect.y, rect.width - size, rect.height);\n            return { start: r1, end: r2 };\n        }\n        if (this === DockLocation.RIGHT) {\n            const r1 = new Rect(rect.getRight() - size, rect.y, size, rect.height);\n            const r2 = new Rect(rect.x, rect.y, rect.width - size, rect.height);\n            return { start: r1, end: r2 };\n        } else {\n            // if (this === DockLocation.BOTTOM) {\n            const r1 = new Rect(rect.x, rect.getBottom() - size, rect.width, size);\n            const r2 = new Rect(rect.x, rect.y, rect.width, rect.height - size);\n            return { start: r1, end: r2 };\n        }\n    }\n\n    /** @internal */\n    reflect() {\n        if (this === DockLocation.TOP) {\n            return DockLocation.BOTTOM;\n        } else if (this === DockLocation.LEFT) {\n            return DockLocation.RIGHT;\n        }\n        if (this === DockLocation.RIGHT) {\n            return DockLocation.LEFT;\n        } else {\n            // if (this === DockLocation.BOTTOM) {\n            return DockLocation.TOP;\n        }\n    }\n\n    toString() {\n        return \"(DockLocation: name=\" + this._name + \", orientation=\" + this._orientation + \")\";\n    }\n}\n","import * as React from \"react\";\nimport { Rect } from \"./Rect\";\n\n/** @internal */\nconst canUseDOM = !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n\nexport class DragDrop {\n    static instance = new DragDrop();\n\n    /** @internal */\n    private _fDblClick: ((event: Event) => void) | undefined;\n    /** @internal */\n    private _fClick: ((event: Event) => void) | undefined;\n    /** @internal */\n    private _fDragEnd: ((event: Event) => void) | undefined;\n    /** @internal */\n    private _fDragMove: ((event: React.MouseEvent<Element>) => void) | undefined;\n    /** @internal */\n    private _fDragStart: ((pos: { clientX: number; clientY: number }) => boolean) | undefined;\n    /** @internal */\n    private _fDragCancel: ((wasDragging: boolean) => void) | undefined;\n\n    /** @internal */\n    private _glass: HTMLDivElement | undefined;\n    /** @internal */\n    private _defaultGlassCursor: string;\n    /** @internal */\n    private _glassCursorOverride: string | undefined;\n    /** @internal */\n    private _manualGlassManagement: boolean = false;\n    /** @internal */\n    private _lastClick: number;\n    /** @internal */\n    private _clickX: number;\n    /** @internal */\n    private _clickY: number;\n    /** @internal */\n    private _startX: number = 0;\n    /** @internal */\n    private _startY: number = 0;\n    /** @internal */\n    private _dragDepth: number = 0;\n    /** @internal */\n    private _glassShowing: boolean = false;\n    /** @internal */\n    private _dragging: boolean = false;\n    /** @internal */\n    private _active: boolean = false; // drag and drop is in progress, can be used on ios to prevent body scrolling (see demo)\n    /** @internal */\n    private _document?: HTMLDocument;\n    /** @internal */\n    private _rootElement?: HTMLElement | undefined;\n    /** @internal */\n    private _lastEvent?: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<Element> | undefined;\n\n    /** @internal */\n    private constructor() {\n        if (canUseDOM) {\n            // check for serverside rendering\n            this._glass = document.createElement(\"div\");\n            this._glass.style.zIndex = \"998\";\n            this._glass.style.backgroundColor = \"transparent\";\n            this._glass.style.outline = \"none\";\n        }\n\n        this._defaultGlassCursor = \"default\";\n\n        this._onMouseMove = this._onMouseMove.bind(this);\n        this._onMouseUp = this._onMouseUp.bind(this);\n        this._onKeyPress = this._onKeyPress.bind(this);\n        this._onDragCancel = this._onDragCancel.bind(this);\n        this._onDragEnter = this._onDragEnter.bind(this);\n        this._onDragLeave = this._onDragLeave.bind(this);\n        this.resizeGlass = this.resizeGlass.bind(this);\n\n        this._lastClick = 0;\n        this._clickX = 0;\n        this._clickY = 0;\n    }\n\n    // if you add the glass pane then you should remove it\n    addGlass(fCancel: ((wasDragging: boolean) => void) | undefined) {\n        if (!this._glassShowing) {\n            if (!this._document) {\n                this._document = window.document;\n            }\n            if (!this._rootElement) {\n                this._rootElement = this._document.body;\n            }\n            this.resizeGlass();\n            this._document.defaultView?.addEventListener('resize', this.resizeGlass);\n            this._document.body.appendChild(this._glass!);\n            this._glass!.tabIndex = -1;\n            this._glass!.focus();\n            this._glass!.addEventListener(\"keydown\", this._onKeyPress);\n            this._glass!.addEventListener(\"dragenter\", this._onDragEnter, { passive: false });\n            this._glass!.addEventListener(\"dragover\", this._onMouseMove, { passive: false });\n            this._glass!.addEventListener(\"dragleave\", this._onDragLeave, { passive: false });\n            this._glassShowing = true;\n            this._fDragCancel = fCancel;\n            this._manualGlassManagement = false;\n        } else {\n            // second call to addGlass (via dragstart)\n            this._manualGlassManagement = true;\n        }\n    }\n\n    resizeGlass() {\n        const glassRect = Rect.fromElement(this._rootElement!);\n        glassRect.positionElement(this._glass!, \"fixed\");\n    }\n\n    hideGlass() {\n        if (this._glassShowing) {\n            this._document!.body.removeChild(this._glass!);\n            this._document!.defaultView?.removeEventListener('resize', this.resizeGlass);\n            this._glassShowing = false;\n            this._document = undefined;\n            this._rootElement = undefined;\n            this.setGlassCursorOverride(undefined);\n        }\n    }\n\n    /** @internal */\n    _updateGlassCursor() {\n        this._glass!.style.cursor = this._glassCursorOverride ?? this._defaultGlassCursor;\n    }\n\n    /** @internal */\n    _setDefaultGlassCursor(cursor: string) {\n        this._defaultGlassCursor = cursor;\n        this._updateGlassCursor()\n    }\n\n    setGlassCursorOverride(cursor: string | undefined) {\n        this._glassCursorOverride = cursor;\n        this._updateGlassCursor()\n    }\n\n    startDrag(\n        event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<Element> | undefined,\n        fDragStart: ((pos: { clientX: number; clientY: number }) => boolean) | undefined,\n        fDragMove: ((event: React.MouseEvent<Element>) => void) | undefined,\n        fDragEnd: ((event: Event) => void) | undefined,\n        fDragCancel?: ((wasDragging: boolean) => void) | undefined,\n        fClick?: ((event: Event) => void) | undefined,\n        fDblClick?: ((event: Event) => void) | undefined,\n        currentDocument?: Document,\n        rootElement?: HTMLDivElement\n    ) {\n        // prevent 'duplicate' action (mouse event for same action as previous touch event (a fix for ios))\n        if (event && this._lastEvent && this._lastEvent.type.startsWith(\"touch\") && event.type.startsWith(\"mouse\") && event.timeStamp - this._lastEvent.timeStamp < 500) {\n            return;\n        }\n\n        this._lastEvent = event;\n\n        if (currentDocument) {\n            this._document = currentDocument;\n        } else {\n            this._document = window.document;\n        }\n        if (rootElement) {\n            this._rootElement = rootElement;\n        } else {\n            this._rootElement = this._document.body;\n        }\n\n        const posEvent = this._getLocationEvent(event);\n        this.addGlass(fDragCancel);\n\n        if (this._dragging) {\n            console.warn(\"this._dragging true on startDrag should never happen\");\n        }\n\n        if (event) {\n            this._startX = posEvent.clientX;\n            this._startY = posEvent.clientY;\n            if (!window.matchMedia || window.matchMedia(\"(pointer: fine)\").matches) {\n                this._setDefaultGlassCursor(getComputedStyle(event.target as Element).cursor);\n            }\n            this._stopPropagation(event);\n            this._preventDefault(event);\n        } else {\n            this._startX = 0;\n            this._startY = 0;\n            this._setDefaultGlassCursor(\"default\");\n        }\n\n        this._dragging = false;\n        this._fDragStart = fDragStart;\n        this._fDragMove = fDragMove;\n        this._fDragEnd = fDragEnd;\n        this._fDragCancel = fDragCancel;\n        this._fClick = fClick;\n        this._fDblClick = fDblClick;\n\n        this._active = true;\n\n        if (event?.type === 'dragenter') {\n            this._dragDepth = 1;\n            this._rootElement.addEventListener(\"dragenter\", this._onDragEnter, { passive: false });\n            this._rootElement.addEventListener(\"dragover\", this._onMouseMove, { passive: false });\n            this._rootElement.addEventListener(\"dragleave\", this._onDragLeave, { passive: false });\n            this._document.addEventListener(\"dragend\", this._onDragCancel, { passive: false });\n            this._document.addEventListener(\"drop\", this._onMouseUp, { passive: false });\n        } else {\n            this._document.addEventListener(\"mouseup\", this._onMouseUp, { passive: false });\n            this._document.addEventListener(\"mousemove\", this._onMouseMove, { passive: false });\n            this._document.addEventListener(\"touchend\", this._onMouseUp, { passive: false });\n            this._document.addEventListener(\"touchmove\", this._onMouseMove, { passive: false });\n        }\n    }\n\n    isDragging() {\n        return this._dragging;\n    }\n\n    isActive() {\n        return this._active;\n    }\n\n    toString() {\n        const rtn = \"(DragDrop: \" + \"startX=\" + this._startX + \", startY=\" + this._startY + \", dragging=\" + this._dragging + \")\";\n\n        return rtn;\n    }\n\n    /** @internal */\n    private _onKeyPress(event: KeyboardEvent) {\n        if (event.keyCode === 27) {\n            // esc\n            this._onDragCancel();\n        }\n    }\n\n    /** @internal */\n    private _onDragCancel() {\n        this._rootElement!.removeEventListener(\"dragenter\", this._onDragEnter);\n        this._rootElement!.removeEventListener(\"dragover\", this._onMouseMove);\n        this._rootElement!.removeEventListener(\"dragleave\", this._onDragLeave);\n        this._document!.removeEventListener(\"dragend\", this._onDragCancel);\n        this._document!.removeEventListener(\"drop\", this._onMouseUp);\n        this._document!.removeEventListener(\"mousemove\", this._onMouseMove);\n        this._document!.removeEventListener(\"mouseup\", this._onMouseUp);\n        this._document!.removeEventListener(\"touchend\", this._onMouseUp);\n        this._document!.removeEventListener(\"touchmove\", this._onMouseMove);\n        this.hideGlass();\n        if (this._fDragCancel !== undefined) {\n            this._fDragCancel(this._dragging);\n        }\n        this._dragging = false;\n        this._active = false;\n    }\n\n    /** @internal */\n    private _getLocationEvent(event: any) {\n        let posEvent: any = event;\n        if (event && event.touches) {\n            posEvent = event.touches[0];\n        }\n        return posEvent;\n    }\n\n    /** @internal */\n    private _getLocationEventEnd(event: any) {\n        let posEvent: any = event;\n        if (event.changedTouches) {\n            posEvent = event.changedTouches[0];\n        }\n        return posEvent;\n    }\n\n    /** @internal */\n    private _stopPropagation(event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<Element>) {\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        }\n    }\n\n    /** @internal */\n    private _preventDefault(event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<Element>) {\n        if (event.preventDefault && event.cancelable) {\n            event.preventDefault();\n        }\n        return event;\n    }\n\n    /** @internal */\n    private _onMouseMove(event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<Element>) {\n        this._lastEvent = event;\n\n        const posEvent = this._getLocationEvent(event);\n        this._stopPropagation(event);\n        this._preventDefault(event);\n\n        if (!this._dragging && (Math.abs(this._startX - posEvent.clientX) > 5 || Math.abs(this._startY - posEvent.clientY) > 5)) {\n            this._dragging = true;\n            if (this._fDragStart) {\n                this._setDefaultGlassCursor(\"move\");\n                this._dragging = this._fDragStart({ clientX: this._startX, clientY: this._startY });\n            }\n        }\n\n        if (this._dragging) {\n            if (this._fDragMove) {\n                this._fDragMove(posEvent);\n            }\n        }\n        return false;\n    }\n\n    /** @internal */\n    private _onMouseUp(event: Event) {\n        this._lastEvent = event;\n\n        const posEvent = this._getLocationEventEnd(event);\n\n        this._stopPropagation(event);\n        this._preventDefault(event);\n\n        this._active = false;\n\n        this._rootElement!.removeEventListener(\"dragenter\", this._onDragEnter);\n        this._rootElement!.removeEventListener(\"dragover\", this._onMouseMove);\n        this._rootElement!.removeEventListener(\"dragleave\", this._onDragLeave);\n        this._document!.removeEventListener(\"dragend\", this._onDragCancel);\n        this._document!.removeEventListener(\"drop\", this._onMouseUp);\n        this._document!.removeEventListener(\"mousemove\", this._onMouseMove);\n        this._document!.removeEventListener(\"mouseup\", this._onMouseUp);\n        this._document!.removeEventListener(\"touchend\", this._onMouseUp);\n        this._document!.removeEventListener(\"touchmove\", this._onMouseMove);\n\n        if (!this._manualGlassManagement) {\n            this.hideGlass();\n        }\n\n        if (this._dragging) {\n            this._dragging = false;\n            if (this._fDragEnd) {\n                this._fDragEnd(event);\n            }\n            // dump(\"set dragging = false\\n\");\n        } else {\n            if (this._fDragCancel) {\n                this._fDragCancel(this._dragging);\n            }\n            if (Math.abs(this._startX - posEvent.clientX) <= 5 && Math.abs(this._startY - posEvent.clientY) <= 5) {\n\n                let isDoubleClick = false;\n                const clickTime = new Date().getTime();\n                // check for double click\n                if (Math.abs(this._clickX - posEvent.clientX) <= 5 && Math.abs(this._clickY - posEvent.clientY) <= 5) {\n                    if (clickTime - this._lastClick < 500) {\n                        if (this._fDblClick) {\n                            this._fDblClick(event);\n                            isDoubleClick = true;\n                        }\n                    }\n                }\n \n                if (!isDoubleClick && this._fClick) {\n                    this._fClick(event);\n                }\n\n                this._lastClick = clickTime;\n                this._clickX = posEvent.clientX;\n                this._clickY = posEvent.clientY;\n            }\n        }\n        return false;\n    }\n\n    /** @internal */\n    private _onDragEnter(event: DragEvent) {\n        this._preventDefault(event);\n        this._stopPropagation(event);\n        this._dragDepth++;\n        return false;\n    }\n\n    /** @internal */\n    private _onDragLeave(event: DragEvent) {\n        this._preventDefault(event);\n        this._stopPropagation(event);\n        this._dragDepth--;\n        if (this._dragDepth <= 0) {\n            this._onDragCancel();\n        }\n        return false;\n    }\n}\n","export class Action {\n    type: string;\n    data: Record<string, any>;\n\n    constructor(type: string, data: Record<string, any>) {\n        this.type = type;\n        this.data = data;\n    }\n}\n","import { DockLocation } from \"../DockLocation\";\nimport { Action } from \"./Action\";\n\n/**\n * The Action creator class for FlexLayout model actions\n */\nexport class Actions {\n    static ADD_NODE = \"FlexLayout_AddNode\";\n    static MOVE_NODE = \"FlexLayout_MoveNode\";\n    static DELETE_TAB = \"FlexLayout_DeleteTab\";\n    static DELETE_TABSET = \"FlexLayout_DeleteTabset\";\n    static RENAME_TAB = \"FlexLayout_RenameTab\";\n    static SELECT_TAB = \"FlexLayout_SelectTab\";\n    static SET_ACTIVE_TABSET = \"FlexLayout_SetActiveTabset\";\n    static ADJUST_SPLIT = \"FlexLayout_AdjustSplit\";\n    static ADJUST_BORDER_SPLIT = \"FlexLayout_AdjustBorderSplit\";\n    static MAXIMIZE_TOGGLE = \"FlexLayout_MaximizeToggle\";\n    static UPDATE_MODEL_ATTRIBUTES = \"FlexLayout_UpdateModelAttributes\";\n    static UPDATE_NODE_ATTRIBUTES = \"FlexLayout_UpdateNodeAttributes\";\n    static FLOAT_TAB = \"FlexLayout_FloatTab\";\n    static UNFLOAT_TAB = \"FlexLayout_UnFloatTab\";\n\n    /**\n     * Adds a tab node to the given tabset node\n     * @param json the json for the new tab node e.g {type:\"tab\", component:\"table\"}\n     * @param toNodeId the new tab node will be added to the tabset with this node id\n     * @param location the location where the new tab will be added, one of the DockLocation enum values.\n     * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.\n     * @param select (optional) whether to select the new tab, overriding autoSelectTab\n     * @returns {Action} the action\n     */\n    static addNode(json: any, toNodeId: string, location: DockLocation, index: number, select?: boolean): Action {\n        return new Action(Actions.ADD_NODE, {\n            json,\n            toNode: toNodeId,\n            location: location.getName(),\n            index,\n            select,\n        });\n    }\n\n    /**\n     * Moves a node (tab or tabset) from one location to another\n     * @param fromNodeId the id of the node to move\n     * @param toNodeId the id of the node to receive the moved node\n     * @param location the location where the moved node will be added, one of the DockLocation enum values.\n     * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.\n     * @param select (optional) whether to select the moved tab(s) in new tabset, overriding autoSelectTab\n     * @returns {Action} the action\n     */\n    static moveNode(fromNodeId: string, toNodeId: string, location: DockLocation, index: number, select?: boolean): Action {\n        return new Action(Actions.MOVE_NODE, {\n            fromNode: fromNodeId,\n            toNode: toNodeId,\n            location: location.getName(),\n            index,\n            select,\n        });\n    }\n\n    /**\n     * Deletes a tab node from the layout\n     * @param tabsetNodeId the id of the tab node to delete\n     * @returns {Action} the action\n     */\n    static deleteTab(tabNodeId: string): Action {\n        return new Action(Actions.DELETE_TAB, { node: tabNodeId });\n    }\n\n    /**\n     * Deletes a tabset node and all it's child tab nodes from the layout\n     * @param tabsetNodeId the id of the tabset node to delete\n     * @returns {Action} the action\n     */\n    static deleteTabset(tabsetNodeId: string): Action {\n        return new Action(Actions.DELETE_TABSET, { node: tabsetNodeId });\n    }\n\n    /**\n     * Change the given nodes tab text\n     * @param tabNodeId the id of the node to rename\n     * @param text the test of the tab\n     * @returns {Action} the action\n     */\n    static renameTab(tabNodeId: string, text: string): Action {\n        return new Action(Actions.RENAME_TAB, { node: tabNodeId, text });\n    }\n\n    /**\n     * Selects the given tab in its parent tabset\n     * @param tabNodeId the id of the node to set selected\n     * @returns {Action} the action\n     */\n    static selectTab(tabNodeId: string): Action {\n        return new Action(Actions.SELECT_TAB, { tabNode: tabNodeId });\n    }\n\n    /**\n     * Set the given tabset node as the active tabset\n     * @param tabsetNodeId the id of the tabset node to set as active\n     * @returns {Action} the action\n     */\n    static setActiveTabset(tabsetNodeId: string): Action {\n        return new Action(Actions.SET_ACTIVE_TABSET, { tabsetNode: tabsetNodeId });\n    }\n\n    /**\n     * Adjust the splitter between two tabsets\n     * @example\n     *  Actions.adjustSplit({node1: \"1\", weight1:30, pixelWidth1:300, node2: \"2\", weight2:70, pixelWidth2:700});\n     *\n     * @param splitSpec an object the defines the new split between two tabsets, see example below.\n     * @returns {Action} the action\n     */\n    static adjustSplit(splitSpec: { node1Id: string; weight1: number; pixelWidth1: number; node2Id: string; weight2: number; pixelWidth2: number }): Action {\n        const node1 = splitSpec.node1Id;\n        const node2 = splitSpec.node2Id;\n\n        return new Action(Actions.ADJUST_SPLIT, {\n            node1,\n            weight1: splitSpec.weight1,\n            pixelWidth1: splitSpec.pixelWidth1,\n            node2,\n            weight2: splitSpec.weight2,\n            pixelWidth2: splitSpec.pixelWidth2,\n        });\n    }\n\n    static adjustBorderSplit(nodeId: string, pos: number): Action {\n        return new Action(Actions.ADJUST_BORDER_SPLIT, { node: nodeId, pos });\n    }\n\n    /**\n     * Maximizes the given tabset\n     * @param tabsetNodeId the id of the tabset to maximize\n     * @returns {Action} the action\n     */\n    static maximizeToggle(tabsetNodeId: string): Action {\n        return new Action(Actions.MAXIMIZE_TOGGLE, { node: tabsetNodeId });\n    }\n\n    /**\n     * Updates the global model jsone attributes\n     * @param attributes the json for the model attributes to update (merge into the existing attributes)\n     * @returns {Action} the action\n     */\n    static updateModelAttributes(attributes: any): Action {\n        return new Action(Actions.UPDATE_MODEL_ATTRIBUTES, { json: attributes });\n    }\n\n    /**\n     * Updates the given nodes json attributes\n     * @param nodeId the id of the node to update\n     * @param attributes the json attributes to update (merge with the existing attributes)\n     * @returns {Action} the action\n     */\n    static updateNodeAttributes(nodeId: string, attributes: any): Action {\n        return new Action(Actions.UPDATE_NODE_ATTRIBUTES, { node: nodeId, json: attributes });\n    }\n\n    static floatTab(nodeId: string): Action {\n        return new Action(Actions.FLOAT_TAB, { node: nodeId });\n    }\n\n    static unFloatTab(nodeId: string): Action {\n        return new Action(Actions.UNFLOAT_TAB, { node: nodeId });\n    }\n}\n","/** @internal */\nexport class Attribute {\n    static NUMBER = \"number\";\n    static STRING = \"string\";\n    static BOOLEAN = \"boolean\";\n\n    name: string;\n    modelName?: string;\n    defaultValue: any;\n    alwaysWriteJson?: boolean;\n    type?: string; \n    required: boolean;\n    fixed: boolean;\n\n    constructor(name: string, modelName: string | undefined, defaultValue: any, alwaysWriteJson?: boolean) {\n        this.name = name;\n        this.modelName = modelName;\n        this.defaultValue = defaultValue;\n        this.alwaysWriteJson = alwaysWriteJson;\n        this.required = false;\n        this.fixed = false;\n\n        this.type = \"any\";\n    }\n\n    setType(value: string) {\n        this.type = value;\n        return this;\n    }\n\n    setRequired() {\n        this.required = true;\n        return this;\n    }\n\n    setFixed() {\n        this.fixed = true;\n        return this;\n    }\n\n}\n","import { Attribute } from \"./Attribute\";\n\n/** @internal */\nexport class AttributeDefinitions {\n    attributes: Attribute[];\n    nameToAttribute: Record<string, Attribute>;\n\n    constructor() {\n        this.attributes = [];\n        this.nameToAttribute = {};\n    }\n\n    addWithAll(name: string, modelName: string | undefined, defaultValue: any, alwaysWriteJson?: boolean) {\n        const attr = new Attribute(name, modelName, defaultValue, alwaysWriteJson);\n        this.attributes.push(attr);\n        this.nameToAttribute[name] = attr;\n        return attr;\n    }\n\n    addInherited(name: string, modelName: string) {\n        return this.addWithAll(name, modelName, undefined, false);\n    }\n\n    add(name: string, defaultValue: any, alwaysWriteJson?: boolean) {\n        return this.addWithAll(name, undefined, defaultValue, alwaysWriteJson);\n    }\n\n    getAttributes() {\n        return this.attributes;\n    }\n\n    getModelName(name: string) {\n        const conversion = this.nameToAttribute[name];\n        if (conversion !== undefined) {\n            return conversion.modelName;\n        }\n        return undefined;\n    }\n\n    toJson(jsonObj: any, obj: any) {\n        for (const attr of this.attributes) {\n            const fromValue = obj[attr.name];\n            if (attr.alwaysWriteJson || fromValue !== attr.defaultValue) {\n                jsonObj[attr.name] = fromValue;\n            }\n        }\n    }\n\n    fromJson(jsonObj: any, obj: any) {\n        for (const attr of this.attributes) {\n            const fromValue = jsonObj[attr.name];\n            if (fromValue === undefined) {\n                obj[attr.name] = attr.defaultValue;\n            } else {\n                obj[attr.name] = fromValue;\n            }\n        }\n    }\n\n    update(jsonObj: any, obj: any) {\n        for (const attr of this.attributes) {\n            if (jsonObj.hasOwnProperty(attr.name)) {\n                const fromValue = jsonObj[attr.name];\n                if (fromValue === undefined) {\n                    delete obj[attr.name];\n                } else {\n                    obj[attr.name] = fromValue;\n                }\n            }\n        }\n    }\n\n    setDefaults(obj: any) {\n        for (const attr of this.attributes) {\n            obj[attr.name] = attr.defaultValue;\n        }\n    }\n\n    toTypescriptInterface(name: string, parentAttributes: AttributeDefinitions | undefined) {\n        const lines = [];\n        const sorted = this.attributes.sort((a, b) => a.name.localeCompare(b.name));\n        // const sorted = this.attributes;\n        lines.push(\"export interface I\" + name + \"Attributes {\");\n        for (let i = 0; i < sorted.length; i++) {\n            const c = sorted[i];\n            let type = c.type;\n            let defaultValue = undefined;\n\n            let attr = c;\n            let inherited = undefined;\n            if (attr.defaultValue !== undefined) {\n                defaultValue = attr.defaultValue;\n            } else if (attr.modelName !== undefined\n                && parentAttributes !== undefined\n                && parentAttributes.nameToAttribute[attr.modelName] !== undefined) {\n                inherited = attr.modelName;\n                attr = parentAttributes.nameToAttribute[attr.modelName];\n                defaultValue = attr.defaultValue;\n                type = attr.type;\n            }\n\n            let defValue = JSON.stringify(defaultValue);\n\n            const required = attr.required || attr.fixed ? \"\" : \"?\";\n\n            if (c.fixed) {\n                lines.push(\"\\t\" + c.name + \": \" + defValue + \";\");\n            } else {\n                const comment = (defaultValue !== undefined ? \"default: \" + defValue : \"\") +\n                    (inherited !== undefined ? \" - inherited from global \" + inherited : \"\");\n\n                lines.push(\"\\t\" + c.name + required + \": \" + type + \";\" +\n                    (comment.length > 0 ? \" // \" + comment : \"\")\n                );\n            }\n        }\n        lines.push(\"}\");\n\n        return lines.join(\"\\n\");\n    }\n}\n","import { DockLocation } from \"./DockLocation\";\nimport { IDropTarget } from \"./model/IDropTarget\";\nimport { Node } from \"./model/Node\";\nimport { Rect } from \"./Rect\";\n\nexport class DropInfo {\n    node: Node & IDropTarget;\n    rect: Rect;\n    location: DockLocation;\n    index: number;\n    className: string;\n\n    constructor(node: Node & IDropTarget, rect: Rect, location: DockLocation, index: number, className: string) {\n        this.node = node;\n        this.rect = rect;\n        this.location = location;\n        this.index = index;\n        this.className = className;\n    }\n}\n","export enum CLASSES {\n    FLEXLAYOUT__BORDER = \"flexlayout__border\",\n    FLEXLAYOUT__BORDER_ = \"flexlayout__border_\",\n\n    FLEXLAYOUT__BORDER_BUTTON = \"flexlayout__border_button\",\n    FLEXLAYOUT__BORDER_BUTTON_ = \"flexlayout__border_button_\",\n    FLEXLAYOUT__BORDER_BUTTON_CONTENT = \"flexlayout__border_button_content\",\n    FLEXLAYOUT__BORDER_BUTTON_LEADING = \"flexlayout__border_button_leading\",\n    FLEXLAYOUT__BORDER_BUTTON_TRAILING = \"flexlayout__border_button_trailing\",\n    FLEXLAYOUT__BORDER_BUTTON__SELECTED = \"flexlayout__border_button--selected\",\n    FLEXLAYOUT__BORDER_BUTTON__UNSELECTED = \"flexlayout__border_button--unselected\",\n    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW = \"flexlayout__border_toolbar_button_overflow\",\n    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_ = \"flexlayout__border_toolbar_button_overflow_\",\n\n    FLEXLAYOUT__BORDER_INNER = \"flexlayout__border_inner\",\n    FLEXLAYOUT__BORDER_INNER_ = \"flexlayout__border_inner_\",\n    FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER = \"flexlayout__border_inner_tab_container\",\n    FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_ = \"flexlayout__border_inner_tab_container_\",\n    FLEXLAYOUT__BORDER_TAB_DIVIDER = \"flexlayout__border_tab_divider\",\n\n    FLEXLAYOUT__BORDER_SIZER = \"flexlayout__border_sizer\",\n\n    FLEXLAYOUT__BORDER_TOOLBAR = \"flexlayout__border_toolbar\",\n    FLEXLAYOUT__BORDER_TOOLBAR_ = \"flexlayout__border_toolbar_\",\n    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON = \"flexlayout__border_toolbar_button\",\n    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT = \"flexlayout__border_toolbar_button-float\",\n\n    FLEXLAYOUT__DRAG_RECT = \"flexlayout__drag_rect\",\n    FLEXLAYOUT__EDGE_RECT = \"flexlayout__edge_rect\",\n\n    FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER = \"flexlayout__error_boundary_container\",\n    FLEXLAYOUT__ERROR_BOUNDARY_CONTENT = \"flexlayout__error_boundary_content\",\n\n    FLEXLAYOUT__FLOATING_WINDOW_CONTENT = \"flexlayout__floating_window_content\",\n    FLEXLAYOUT__FLOATING_WINDOW_TAB = \"flexlayout__floating_window_tab\",\n\n    FLEXLAYOUT__LAYOUT = \"flexlayout__layout\",\n\n    FLEXLAYOUT__OUTLINE_RECT = \"flexlayout__outline_rect\",\n    FLEXLAYOUT__OUTLINE_RECT_EDGE = \"flexlayout__outline_rect_edge\",\n\n    FLEXLAYOUT__SPLITTER = \"flexlayout__splitter\",\n    FLEXLAYOUT__SPLITTER_EXTRA = \"flexlayout__splitter_extra\",\n    FLEXLAYOUT__SPLITTER_ = \"flexlayout__splitter_\",\n    FLEXLAYOUT__SPLITTER_BORDER = \"flexlayout__splitter_border\",\n    FLEXLAYOUT__SPLITTER_DRAG = \"flexlayout__splitter_drag\",\n\n    FLEXLAYOUT__TAB = \"flexlayout__tab\",\n\n    FLEXLAYOUT__TABSET = \"flexlayout__tabset\",\n    FLEXLAYOUT__TABSET_HEADER = \"flexlayout__tabset_header\",\n    FLEXLAYOUT__TABSET_HEADER_SIZER = \"flexlayout__tabset_header_sizer\",\n    FLEXLAYOUT__TABSET_HEADER_CONTENT = \"flexlayout__tabset_header_content\",\n    FLEXLAYOUT__TABSET_MAXIMIZED = \"flexlayout__tabset-maximized\",\n    FLEXLAYOUT__TABSET_SELECTED = \"flexlayout__tabset-selected\",\n    FLEXLAYOUT__TABSET_SIZER = \"flexlayout__tabset_sizer\",\n    FLEXLAYOUT__TABSET_TAB_DIVIDER = \"flexlayout__tabset_tab_divider\",\n\n    FLEXLAYOUT__TABSET_CONTENT = \"flexlayout__tabset_content\",\n    FLEXLAYOUT__TABSET_TABBAR_INNER = \"flexlayout__tabset_tabbar_inner\",\n    FLEXLAYOUT__TABSET_TABBAR_INNER_ = \"flexlayout__tabset_tabbar_inner_\",\n    FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER = \"flexlayout__tabset_tabbar_inner_tab_container\",\n    FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_ = \"flexlayout__tabset_tabbar_inner_tab_container_\",\n\n    FLEXLAYOUT__TABSET_TABBAR_OUTER = \"flexlayout__tabset_tabbar_outer\",\n    FLEXLAYOUT__TABSET_TABBAR_OUTER_ = \"flexlayout__tabset_tabbar_outer_\",\n\n    FLEXLAYOUT__TAB_BORDER = \"flexlayout__tab_border\",\n    FLEXLAYOUT__TAB_BORDER_ = \"flexlayout__tab_border_\",\n    FLEXLAYOUT__TAB_BUTTON = \"flexlayout__tab_button\",\n    FLEXLAYOUT__TAB_BUTTON_CONTENT = \"flexlayout__tab_button_content\",\n    FLEXLAYOUT__TAB_BUTTON_LEADING = \"flexlayout__tab_button_leading\",\n    FLEXLAYOUT__TAB_BUTTON_OVERFLOW = \"flexlayout__tab_button_overflow\",\n    FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT = \"flexlayout__tab_button_overflow_count\",\n    FLEXLAYOUT__TAB_BUTTON_TEXTBOX = \"flexlayout__tab_button_textbox\",\n    FLEXLAYOUT__TAB_BUTTON_TRAILING = \"flexlayout__tab_button_trailing\",\n    FLEXLAYOUT__TAB_BUTTON_STAMP = \"flexlayout__tab_button_stamp\",\n\n    FLEXLAYOUT__TAB_FLOATING = \"flexlayout__tab_floating\",\n    FLEXLAYOUT__TAB_FLOATING_INNER = \"flexlayout__tab_floating_inner\",\n\n    FLEXLAYOUT__TAB_TOOLBAR = \"flexlayout__tab_toolbar\",\n    FLEXLAYOUT__TAB_TOOLBAR_BUTTON = \"flexlayout__tab_toolbar_button\",\n    FLEXLAYOUT__TAB_TOOLBAR_BUTTON_ = \"flexlayout__tab_toolbar_button-\",\n    FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT = \"flexlayout__tab_toolbar_button-float\",\n    FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER = \"flexlayout__tab_toolbar_sticky_buttons_container\",\n    FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE = \"flexlayout__tab_toolbar_button-close\",\n\n    FLEXLAYOUT__POPUP_MENU_CONTAINER = \"flexlayout__popup_menu_container\",\n    FLEXLAYOUT__POPUP_MENU_ITEM = \"flexlayout__popup_menu_item\",\n    FLEXLAYOUT__POPUP_MENU = \"flexlayout__popup_menu\",\n}\n","import { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IJsonBorderNode, IJsonRowNode, IJsonTabNode, IJsonTabSetNode } from \"./IJsonModel\";\nimport { Model, ILayoutMetrics } from \"./Model\";\n\nexport abstract class Node {\n    /** @internal */\n    protected _model: Model;\n    /** @internal */\n    protected _attributes: Record<string, any>;\n    /** @internal */\n    protected _parent?: Node;\n    /** @internal */\n    protected _children: Node[];\n    /** @internal */\n    protected _fixed: boolean;\n    /** @internal */\n    protected _rect: Rect;\n    /** @internal */\n    protected _visible: boolean;\n    /** @internal */\n    protected _listeners: Record<string, (params: any) => void>;\n    /** @internal */\n    protected _dirty: boolean = false;\n    /** @internal */\n    protected _tempSize: number = 0;\n\n    /** @internal */\n    protected constructor(model: Model) {\n        this._model = model;\n        this._attributes = {};\n        this._children = [];\n        this._fixed = false;\n        this._rect = Rect.empty();\n        this._visible = false;\n        this._listeners = {};\n    }\n\n    getId() {\n        let id = this._attributes.id;\n        if (id !== undefined) {\n            return id as string;\n        }\n\n        id = this._model._nextUniqueId();\n        this._setId(id);\n\n        return id as string;\n    }\n\n    getModel() {\n        return this._model;\n    }\n\n    getType() {\n        return this._attributes.type as string;\n    }\n\n    getParent() {\n        return this._parent;\n    }\n\n    getChildren() {\n        return this._children;\n    }\n\n    getRect() {\n        return this._rect;\n    }\n\n    isVisible() {\n        return this._visible;\n    }\n\n    getOrientation(): Orientation {\n        if (this._parent === undefined) {\n            return this._model.isRootOrientationVertical() ? Orientation.VERT : Orientation.HORZ;\n        } else {\n            return Orientation.flip(this._parent.getOrientation());\n        }\n    }\n\n    // event can be: resize, visibility, maximize (on tabset), close\n    setEventListener(event: string, callback: (params: any) => void) {\n        this._listeners[event] = callback;\n    }\n\n    removeEventListener(event: string) {\n        delete this._listeners[event];\n    }\n\n    abstract toJson(): IJsonRowNode | IJsonBorderNode | IJsonTabSetNode | IJsonTabNode | undefined;\n\n    /** @internal */\n    _setId(id: string) {\n        this._attributes.id = id;\n    }\n\n    /** @internal */\n    _fireEvent(event: string, params: any) {\n        // console.log(this._type, \" fireEvent \" + event + \" \" + JSON.stringify(params));\n        if (this._listeners[event] !== undefined) {\n            this._listeners[event](params);\n        }\n    }\n\n    /** @internal */\n    _getAttr(name: string) {\n        let val = this._attributes[name];\n\n        if (val === undefined) {\n            const modelName = this._getAttributeDefinitions().getModelName(name);\n            if (modelName !== undefined) {\n                val = this._model._getAttribute(modelName);\n            }\n        }\n\n        // console.log(name + \"=\" + val);\n        return val;\n    }\n\n    /** @internal */\n    _forEachNode(fn: (node: Node, level: number) => void, level: number) {\n        fn(this, level);\n        level++;\n        for (const node of this._children) {\n            node._forEachNode(fn, level);\n        }\n    }\n\n    /** @internal */\n    _setVisible(visible: boolean) {\n        if (visible !== this._visible) {\n            this._fireEvent(\"visibility\", { visible });\n            this._visible = visible;\n        }\n    }\n\n    /** @internal */\n    _getDrawChildren(): Node[] | undefined {\n        return this._children;\n    }\n\n    /** @internal */\n    _setParent(parent: Node) {\n        this._parent = parent;\n    }\n\n    /** @internal */\n    _setRect(rect: Rect) {\n        this._rect = rect;\n    }\n\n    /** @internal */\n    _setWeight(weight: number) {\n        this._attributes.weight = weight;\n    }\n\n    /** @internal */\n    _setSelected(index: number) {\n        this._attributes.selected = index;\n    }\n\n    /** @internal */\n    _isFixed() {\n        return this._fixed;\n    }\n\n    /** @internal */\n    _layout(rect: Rect, metrics: ILayoutMetrics) {\n        this._rect = rect;\n    }\n\n    /** @internal */\n    _findDropTargetNode(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        let rtn: DropInfo | undefined;\n        if (this._rect.contains(x, y)) {\n            if (this._model.getMaximizedTabset() !== undefined) {\n                rtn = this._model.getMaximizedTabset()!.canDrop(dragNode, x, y);\n            } else {\n                rtn = this.canDrop(dragNode, x, y);\n                if (rtn === undefined) {\n                    if (this._children.length !== 0) {\n                        for (const child of this._children) {\n                            rtn = child._findDropTargetNode(dragNode, x, y);\n                            if (rtn !== undefined) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return rtn;\n    }\n\n    /** @internal */\n    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        return undefined;\n    }\n\n    /** @internal */\n    _canDockInto(dragNode: Node & IDraggable, dropInfo: DropInfo | undefined): boolean {\n        if (dropInfo != null) {\n            if (dropInfo.location === DockLocation.CENTER && dropInfo.node.isEnableDrop() === false) {\n                return false;\n            }\n\n            // prevent named tabset docking into another tabset, since this would lose the header\n            if (dropInfo.location === DockLocation.CENTER && dragNode.getType() === \"tabset\" && dragNode.getName() !== undefined) {\n                return false;\n            }\n\n            if (dropInfo.location !== DockLocation.CENTER && dropInfo.node.isEnableDivide() === false) {\n                return false;\n            }\n\n            // finally check model callback to check if drop allowed\n            if (this._model._getOnAllowDrop()) {\n                return (this._model._getOnAllowDrop() as (dragNode: Node, dropInfo: DropInfo) => boolean)(dragNode, dropInfo);\n            }\n        }\n        return true;\n    }\n\n    /** @internal */\n    _removeChild(childNode: Node) {\n        const pos = this._children.indexOf(childNode);\n        if (pos !== -1) {\n            this._children.splice(pos, 1);\n        }\n        this._dirty = true;\n        return pos;\n    }\n\n    /** @internal */\n    _addChild(childNode: Node, pos?: number) {\n        if (pos != null) {\n            this._children.splice(pos, 0, childNode);\n        } else {\n            this._children.push(childNode);\n            pos = this._children.length - 1;\n        }\n        childNode._parent = this;\n        this._dirty = true;\n        return pos;\n    }\n\n    /** @internal */\n    _removeAll() {\n        this._children = [];\n        this._dirty = true;\n    }\n\n    /** @internal */\n    _styleWithPosition(style?: Record<string, any>) {\n        if (style == null) {\n            style = {};\n        }\n        return this._rect.styleWithPosition(style);\n    }\n\n    /** @internal */\n    _getTempSize() {\n        return this._tempSize;\n    }\n\n    /** @internal */\n    _setTempSize(value: number) {\n        this._tempSize = value;\n    }\n\n    /** @internal */\n    isEnableDivide() {\n        return true;\n    }\n\n    /** @internal */\n    _toAttributeString() {\n        return JSON.stringify(this._attributes, undefined, \"\\t\");\n    }\n\n    // implemented by subclasses\n    /** @internal */\n    abstract _updateAttrs(json: any): void;\n    /** @internal */\n    abstract _getAttributeDefinitions(): AttributeDefinitions;\n}\n","import { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { Orientation } from \"../Orientation\";\nimport { Model } from \"./Model\";\nimport { Node } from \"./Node\";\n\nexport class SplitterNode extends Node {\n    static readonly TYPE: string = \"splitter\";\n\n    /** @internal */\n    constructor(model: Model) {\n        super(model);\n        this._fixed = true;\n        this._attributes.type = SplitterNode.TYPE;\n        model._addNode(this);\n    }\n\n    /** @internal */\n    getWidth() {\n        return this._model.getSplitterSize();\n    }\n\n    /** @internal */\n    getMinWidth() {\n        if (this.getOrientation() === Orientation.VERT) {\n            return this._model.getSplitterSize();\n        } else {\n            return 0;\n        }\n    }\n\n    /** @internal */\n    getHeight() {\n        return this._model.getSplitterSize();\n    }\n\n    /** @internal */\n    getMinHeight() {\n        if (this.getOrientation() === Orientation.HORZ) {\n            return this._model.getSplitterSize();\n        } else {\n            return 0;\n        }\n    }\n\n    /** @internal */\n    getMinSize(orientation: Orientation) {\n        if (orientation === Orientation.HORZ) {\n            return this.getMinWidth();\n        } else {\n            return this.getMinHeight();\n        }\n    }\n\n    /** @internal */\n    getWeight(): number {\n        return 0;\n    }\n\n    /** @internal */\n    _setWeight(value: number): void { }\n\n    /** @internal */\n    _getPrefSize(orientation: Orientation): number {\n        return this._model.getSplitterSize();\n    }\n\n    /** @internal */\n    _updateAttrs(json: any): void { }\n\n    /** @internal */\n    _getAttributeDefinitions(): AttributeDefinitions {\n        return new AttributeDefinitions();\n    }\n\n    toJson(): undefined {\n        return undefined;\n    }\n}\n","import { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { Rect } from \"../Rect\";\nimport { BorderNode } from \"./BorderNode\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IJsonTabNode } from \"./IJsonModel\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\nimport { TabSetNode } from \"./TabSetNode\";\n\nexport class TabNode extends Node implements IDraggable {\n    static readonly TYPE = \"tab\";\n\n    /** @internal */\n    static _fromJson(json: any, model: Model, addToModel: boolean = true) {\n        const newLayoutNode = new TabNode(model, json, addToModel);\n        return newLayoutNode;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = TabNode._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n        attributeDefinitions.add(\"type\", TabNode.TYPE, true).setType(Attribute.STRING);\n        attributeDefinitions.add(\"id\", undefined).setType(Attribute.STRING);\n\n        attributeDefinitions.add(\"name\", \"[Unnamed Tab]\").setType(Attribute.STRING);\n        attributeDefinitions.add(\"altName\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"helpText\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"component\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"config\", undefined).setType(\"any\");\n        attributeDefinitions.add(\"floating\", false).setType(Attribute.BOOLEAN);\n\n        attributeDefinitions.addInherited(\"enableClose\", \"tabEnableClose\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"closeType\", \"tabCloseType\").setType(\"ICloseType\");\n        attributeDefinitions.addInherited(\"enableDrag\", \"tabEnableDrag\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"enableRename\", \"tabEnableRename\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"className\", \"tabClassName\").setType(Attribute.STRING);\n        attributeDefinitions.addInherited(\"icon\", \"tabIcon\").setType(Attribute.STRING);\n        attributeDefinitions.addInherited(\"enableRenderOnDemand\", \"tabEnableRenderOnDemand\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"enableFloat\", \"tabEnableFloat\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"borderWidth\", \"tabBorderWidth\").setType(Attribute.NUMBER);\n        attributeDefinitions.addInherited(\"borderHeight\", \"tabBorderHeight\").setType(Attribute.NUMBER);\n        return attributeDefinitions;\n    }\n\n    /** @internal */\n    private _tabRect?: Rect;\n    /** @internal */\n    private _renderedName?: string;\n    /** @internal */\n    private _extra: Record<string, any>;\n    /** @internal */\n    private _window?: Window;\n\n    /** @internal */\n    constructor(model: Model, json: any, addToModel: boolean = true) {\n        super(model);\n\n        this._extra = {}; // extra data added to node not saved in json\n\n        TabNode._attributeDefinitions.fromJson(json, this._attributes);\n        if (addToModel === true) {\n            model._addNode(this);\n        }\n    }\n\n    getWindow() {\n        return this._window;\n    }\n\n    getTabRect() {\n        return this._tabRect;\n    }\n\n    /** @internal */\n    _setTabRect(rect: Rect) {\n        this._tabRect = rect;\n    }\n\n    /** @internal */\n    _setRenderedName(name: string) {\n        this._renderedName = name;\n    }\n\n    /** @internal */\n    _getNameForOverflowMenu() {\n        const altName = this._getAttr(\"altName\") as string;\n        if (altName !== undefined) {\n            return altName;\n        }\n        return this._renderedName;\n    }\n\n    getName() {\n        return this._getAttr(\"name\") as string;\n    }\n\n    getHelpText() {\n        return this._getAttr(\"helpText\") as string | undefined;\n    }\n\n    getComponent() {\n        return this._getAttr(\"component\") as string | undefined;\n    }\n\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n    getConfig() {\n        return this._attributes.config;\n    }\n\n    /**\n     * Returns an object that can be used to store transient node specific data that will\n     * NOT be saved in the json.\n     */\n    getExtraData() {\n        return this._extra;\n    }\n\n    isFloating() {\n        return this._getAttr(\"floating\") as boolean;\n    }\n\n    getIcon() {\n        return this._getAttr(\"icon\") as string | undefined;\n    }\n\n    isEnableClose() {\n        return this._getAttr(\"enableClose\") as boolean;\n    }\n\n    getCloseType() {\n        return this._getAttr(\"closeType\") as number;\n    }\n\n    isEnableFloat() {\n        return this._getAttr(\"enableFloat\") as boolean;\n    }\n\n    isEnableDrag() {\n        return this._getAttr(\"enableDrag\") as boolean;\n    }\n\n    isEnableRename() {\n        return this._getAttr(\"enableRename\") as boolean;\n    }\n\n    getClassName() {\n        return this._getAttr(\"className\") as string | undefined;\n    }\n\n    isEnableRenderOnDemand() {\n        return this._getAttr(\"enableRenderOnDemand\") as boolean;\n    }\n\n    /** @internal */\n    _setName(name: string) {\n        this._attributes.name = name;\n        if (this._window && this._window.document) {\n            this._window.document.title = name;\n        }\n    }\n\n    /** @internal */\n    _setFloating(float: boolean) {\n        this._attributes.floating = float;\n    }\n\n    /** @internal */\n    _layout(rect: Rect, metrics: ILayoutMetrics) {\n        if (!rect.equals(this._rect)) {\n            this._fireEvent(\"resize\", { rect });\n        }\n        this._rect = rect;\n    }\n\n    /** @internal */\n    _delete() {\n        (this._parent as TabSetNode | BorderNode)._remove(this);\n        this._fireEvent(\"close\", {});\n    }\n\n    toJson(): IJsonTabNode {\n        const json = {};\n        TabNode._attributeDefinitions.toJson(json, this._attributes);\n        return json;\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        TabNode._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    _getAttributeDefinitions() {\n        return TabNode._attributeDefinitions;\n    }\n\n    /** @internal */\n    _setWindow(window: Window | undefined) {\n        this._window = window;\n    }\n\n    /** @internal */\n    _setBorderWidth(width: number) {\n        this._attributes.borderWidth = width;\n    }\n\n    /** @internal */\n    _setBorderHeight(height: number) {\n        this._attributes.borderHeight = height;\n    }\n\n    /** @internal */\n    static getAttributeDefinitions() {\n        return TabNode._attributeDefinitions;\n    }\n\n}\n","import { TabNode } from \"./TabNode\";\nimport { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderNode } from \"./BorderNode\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IDropTarget } from \"./IDropTarget\";\nimport { IJsonRowNode } from \"./IJsonModel\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\nimport { SplitterNode } from \"./SplitterNode\";\nimport { TabSetNode } from \"./TabSetNode\";\n\nexport class RowNode extends Node implements IDropTarget {\n    static readonly TYPE = \"row\";\n\n    /** @internal */\n    static _fromJson(json: any, model: Model) {\n        const newLayoutNode = new RowNode(model, json);\n\n        if (json.children != null) {\n            for (const jsonChild of json.children) {\n                if (jsonChild.type === TabSetNode.TYPE) {\n                    const child = TabSetNode._fromJson(jsonChild, model);\n                    newLayoutNode._addChild(child);\n                } else {\n                    const child = RowNode._fromJson(jsonChild, model);\n                    newLayoutNode._addChild(child);\n                }\n            }\n        }\n\n        return newLayoutNode;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = RowNode._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n        attributeDefinitions.add(\"type\", RowNode.TYPE, true).setType(Attribute.STRING).setFixed();\n        attributeDefinitions.add(\"id\", undefined).setType(Attribute.STRING);\n\n        attributeDefinitions.add(\"weight\", 100).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"width\", undefined).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"height\", undefined).setType(Attribute.NUMBER);\n\n        return attributeDefinitions;\n    }\n    /** @internal */\n    private _drawChildren: (TabSetNode | RowNode | SplitterNode)[];\n    /** @internal */\n    private _minHeight: number;\n    /** @internal */\n    private _minWidth: number;\n\n    /** @internal */\n    constructor(model: Model, json: any) {\n        super(model);\n\n        this._dirty = true;\n        this._drawChildren = [];\n        this._minHeight = 0;\n        this._minWidth = 0;\n        RowNode._attributeDefinitions.fromJson(json, this._attributes);\n        model._addNode(this);\n    }\n\n    getWeight() {\n        return this._attributes.weight as number;\n    }\n\n    getWidth() {\n        return this._getAttr(\"width\") as number | undefined;\n    }\n\n    getHeight() {\n        return this._getAttr(\"height\") as number | undefined;\n    }\n\n    /** @internal */\n    _setWeight(weight: number) {\n        this._attributes.weight = weight;\n    }\n\n    /** @internal */\n    _layout(rect: Rect, metrics: ILayoutMetrics) {\n        super._layout(rect, metrics);\n\n        const pixelSize = this._rect._getSize(this.getOrientation());\n\n        let totalWeight = 0;\n        let fixedPixels = 0;\n        let prefPixels = 0;\n        let totalPrefWeight = 0;\n        const drawChildren = this._getDrawChildren() as (RowNode | TabSetNode | SplitterNode)[];\n\n        for (const child of drawChildren) {\n            const prefSize = child._getPrefSize(this.getOrientation());\n            if (child._isFixed()) {\n                if (prefSize !== undefined) {\n                    fixedPixels += prefSize;\n                }\n            } else {\n                if (prefSize === undefined) {\n                    totalWeight += child.getWeight();\n                } else {\n                    prefPixels += prefSize;\n                    totalPrefWeight += child.getWeight();\n                }\n            }\n        }\n\n        let resizePreferred = false;\n        let availablePixels = pixelSize - fixedPixels - prefPixels;\n        if (availablePixels < 0) {\n            availablePixels = pixelSize - fixedPixels;\n            resizePreferred = true;\n            totalWeight += totalPrefWeight;\n        }\n        // assign actual pixel sizes\n        let totalSizeGiven = 0;\n        let variableSize = 0;\n        for (const child of drawChildren) {\n            const prefSize = child._getPrefSize(this.getOrientation());\n            if (child._isFixed()) {\n                if (prefSize !== undefined) {\n                    child._setTempSize(prefSize);\n                }\n            } else {\n                if (prefSize == null || resizePreferred) {\n                    if (totalWeight === 0) {\n                        child._setTempSize(0);\n                    } else {\n                        const minSize = child.getMinSize(this.getOrientation());\n                        const size = Math.floor(availablePixels * (child.getWeight() / totalWeight));\n                        child._setTempSize(Math.max(minSize, size));\n                    }\n                    variableSize += child._getTempSize();\n                } else {\n                    child._setTempSize(prefSize);\n                }\n            }\n\n            totalSizeGiven += child._getTempSize();\n        }\n\n        // adjust sizes to exactly fit\n        if (variableSize > 0) {\n            while (totalSizeGiven < pixelSize) {\n                for (const child of drawChildren) {\n                    if (!(child instanceof SplitterNode)) {\n                        const prefSize = child._getPrefSize(this.getOrientation());\n                        if (!child._isFixed() && (prefSize === undefined || resizePreferred) && totalSizeGiven < pixelSize) {\n                            child._setTempSize(child._getTempSize() + 1);\n                            totalSizeGiven++;\n                        }\n                    }\n                }\n            }\n\n            // decrease size using nodes not at there minimum\n            while (totalSizeGiven > pixelSize) {\n                let changed = false;\n                for (const child of drawChildren) {\n                    if (!(child instanceof SplitterNode)) {\n                        const minSize = child.getMinSize(this.getOrientation());\n                        const size = child._getTempSize();\n                        if (size > minSize && totalSizeGiven > pixelSize) {\n                            child._setTempSize(child._getTempSize() - 1);\n                            totalSizeGiven--;\n                            changed = true;\n                        }\n                    }\n                }\n                if (!changed) {\n                    // all children are at min values\n                    break;\n                }\n            }\n\n            // if still too big then simply reduce all nodes until fits\n            while (totalSizeGiven > pixelSize) {\n                let changed = false;\n                for (const child of drawChildren) {\n                    if (!(child instanceof SplitterNode)) {\n                        const size = child._getTempSize();\n                        if (size > 0 && totalSizeGiven > pixelSize) {\n                            child._setTempSize(child._getTempSize() - 1);\n                            totalSizeGiven--;\n                            changed = true;\n                        }\n                    }\n                }\n                if (!changed) {\n                    // all children are at 0 values\n                    break;\n                }\n            }\n        }\n\n        // layout children\n        let p = 0;\n        for (const child of drawChildren) {\n            if (this.getOrientation() === Orientation.HORZ) {\n                child._layout(new Rect(this._rect.x + p, this._rect.y, child._getTempSize(), this._rect.height), metrics);\n            } else {\n                child._layout(new Rect(this._rect.x, this._rect.y + p, this._rect.width, child._getTempSize()), metrics);\n            }\n            p += child._getTempSize();\n        }\n\n        return true;\n    }\n\n    /** @internal */\n    _getSplitterBounds(splitterNode: SplitterNode, useMinSize: boolean = false) {\n        const pBounds = [0, 0];\n        const drawChildren = this._getDrawChildren() as (RowNode | TabSetNode | SplitterNode)[];\n        const p = drawChildren.indexOf(splitterNode);\n        const node1 = drawChildren[p - 1];\n        const node2 = drawChildren[p + 1];\n        if (this.getOrientation() === Orientation.HORZ) {\n            const minSize1 = useMinSize ? node1.getMinWidth() : 0;\n            const minSize2 = useMinSize ? node2.getMinWidth() : 0;\n            pBounds[0] = node1.getRect().x + minSize1;\n            pBounds[1] = node2.getRect().getRight() - splitterNode.getWidth() - minSize2;\n        } else {\n            const minSize1 = useMinSize ? node1.getMinHeight() : 0;\n            const minSize2 = useMinSize ? node2.getMinHeight() : 0;\n            pBounds[0] = node1.getRect().y + minSize1;\n            pBounds[1] = node2.getRect().getBottom() - splitterNode.getHeight() - minSize2;\n        }\n        return pBounds;\n    }\n\n    /** @internal */\n    _calculateSplit(splitter: SplitterNode, splitterPos: number) {\n        let rtn;\n        const drawChildren = this._getDrawChildren() as (RowNode | TabSetNode | SplitterNode)[];\n        const p = drawChildren.indexOf(splitter);\n        const pBounds = this._getSplitterBounds(splitter);\n\n        const weightedLength = drawChildren[p - 1].getWeight() + drawChildren[p + 1].getWeight();\n\n        const pixelWidth1 = Math.max(0, splitterPos - pBounds[0]);\n        const pixelWidth2 = Math.max(0, pBounds[1] - splitterPos);\n\n        if (pixelWidth1 + pixelWidth2 > 0) {\n            const weight1 = (pixelWidth1 * weightedLength) / (pixelWidth1 + pixelWidth2);\n            const weight2 = (pixelWidth2 * weightedLength) / (pixelWidth1 + pixelWidth2);\n\n            rtn = {\n                node1Id: drawChildren[p - 1].getId(),\n                weight1,\n                pixelWidth1,\n                node2Id: drawChildren[p + 1].getId(),\n                weight2,\n                pixelWidth2,\n            };\n        }\n\n        return rtn;\n    }\n\n    /** @internal */\n    _getDrawChildren(): Node[] | undefined {\n        if (this._dirty) {\n            this._drawChildren = [];\n\n            for (let i = 0; i < this._children.length; i++) {\n                const child = this._children[i] as RowNode | TabSetNode;\n                if (i !== 0) {\n                    const newSplitter = new SplitterNode(this._model);\n                    newSplitter._setParent(this);\n                    this._drawChildren.push(newSplitter);\n                }\n                this._drawChildren.push(child);\n            }\n            this._dirty = false;\n        }\n\n        return this._drawChildren;\n    }\n\n    /** @internal */\n    getMinSize(orientation: Orientation) {\n        if (orientation === Orientation.HORZ) {\n            return this.getMinWidth();\n        } else {\n            return this.getMinHeight();\n        }\n    }\n\n    /** @internal */\n    getMinWidth() {\n        return this._minWidth;\n    }\n\n    /** @internal */\n    getMinHeight() {\n        return this._minHeight;\n    }\n\n    /** @internal */\n    calcMinSize() {\n        this._minHeight = 0;\n        this._minWidth = 0;\n        let first = true;\n        for (const child of this._children) {\n            const c = child as RowNode | TabSetNode;\n            if (c instanceof RowNode) {\n                c.calcMinSize();\n            }\n            if (this.getOrientation() === Orientation.VERT) {\n                this._minHeight += c.getMinHeight();\n                if (!first) {\n                    this._minHeight += this._model.getSplitterSize();\n                }\n                this._minWidth = Math.max(this._minWidth, c.getMinWidth());\n            } else {\n                this._minWidth += c.getMinWidth();\n                if (!first) {\n                    this._minWidth += this._model.getSplitterSize();\n                }\n                this._minHeight = Math.max(this._minHeight, c.getMinHeight());\n            }\n            first = false;\n        }\n    }\n\n    /** @internal */\n    _tidy() {\n        let i = 0;\n        while (i < this._children.length) {\n            const child = this._children[i];\n            if (child instanceof RowNode) {\n                child._tidy();\n\n                const childChildren = child.getChildren();\n                if (childChildren.length === 0) {\n                    this._removeChild(child);\n                } else if (childChildren.length === 1) {\n                    // hoist child/children up to this level\n                    const subchild = childChildren[0];\n                    this._removeChild(child);\n                    if (subchild instanceof RowNode) {\n                        let subChildrenTotal = 0;\n                        const subChildChildren = subchild.getChildren();\n                        for (const ssc of subChildChildren) {\n                            const subsubChild = ssc as RowNode | TabSetNode;\n                            subChildrenTotal += subsubChild.getWeight();\n                        }\n                        for (let j = 0; j < subChildChildren.length; j++) {\n                            const subsubChild = subChildChildren[j] as RowNode | TabSetNode;\n                            subsubChild._setWeight((child.getWeight() * subsubChild.getWeight()) / subChildrenTotal);\n                            this._addChild(subsubChild, i + j);\n                        }\n                    } else {\n                        subchild._setWeight(child.getWeight());\n                        this._addChild(subchild, i);\n                    }\n                } else {\n                    i++;\n                }\n            } else if (child instanceof TabSetNode && child.getChildren().length === 0) {\n                if (child.isEnableDeleteWhenEmpty()) {\n                    this._removeChild(child);\n                    if (child === this._model.getMaximizedTabset()) {\n                        this._model._setMaximizedTabset(undefined);\n                    }\n                } else {\n                    i++;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        // add tabset into empty root\n        if (this === this._model.getRoot() && this._children.length === 0) {\n            const callback = this._model._getOnCreateTabSet();\n            let attrs = callback ? callback() : {};\n            attrs = { ...attrs, selected: -1 };\n            const child = new TabSetNode(this._model, attrs);\n            this._model._setActiveTabset(child);\n            this._addChild(child);\n        }\n\n    }\n\n    /** @internal */\n    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        const yy = y - this._rect.y;\n        const xx = x - this._rect.x;\n        const w = this._rect.width;\n        const h = this._rect.height;\n        const margin = 10; // height of edge rect\n        const half = 50; // half width of edge rect\n        let dropInfo;\n\n        if (this._model.isEnableEdgeDock() && this._parent === undefined) {\n            // _root row\n            if (x < this._rect.x + margin && yy > h / 2 - half && yy < h / 2 + half) {\n                const dockLocation = DockLocation.LEFT;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.width = outlineRect.width / 2;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            } else if (x > this._rect.getRight() - margin && yy > h / 2 - half && yy < h / 2 + half) {\n                const dockLocation = DockLocation.RIGHT;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.width = outlineRect.width / 2;\n                outlineRect.x += outlineRect.width;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            } else if (y < this._rect.y + margin && xx > w / 2 - half && xx < w / 2 + half) {\n                const dockLocation = DockLocation.TOP;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.height = outlineRect.height / 2;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            } else if (y > this._rect.getBottom() - margin && xx > w / 2 - half && xx < w / 2 + half) {\n                const dockLocation = DockLocation.BOTTOM;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.height = outlineRect.height / 2;\n                outlineRect.y += outlineRect.height;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            }\n\n            if (dropInfo !== undefined) {\n                if (!dragNode._canDockInto(dragNode, dropInfo)) {\n                    return undefined;\n                }\n            }\n        }\n\n        return dropInfo;\n    }\n\n    /** @internal */\n    drop(dragNode: Node & IDraggable, location: DockLocation, index: number): void {\n        const dockLocation = location;\n\n        const parent = dragNode.getParent();\n\n        if (parent) {\n            parent._removeChild(dragNode);\n        }\n\n        if (parent !== undefined && parent!.getType() === TabSetNode.TYPE) {\n            parent._setSelected(0);\n        }\n\n        if (parent !== undefined && parent!.getType() === BorderNode.TYPE) {\n            parent._setSelected(-1);\n        }\n\n        let tabSet: TabSetNode | undefined;\n        if (dragNode instanceof TabSetNode) {\n            tabSet = dragNode;\n        } else {\n            const callback = this._model._getOnCreateTabSet();\n            tabSet = new TabSetNode(this._model, callback ? callback(dragNode as TabNode) : {});\n            tabSet._addChild(dragNode);\n        }\n        let size = this._children.reduce((sum, child) => {\n            return sum + (child as RowNode | TabSetNode).getWeight();\n        }, 0);\n\n        if (size === 0) {\n            size = 100;\n        }\n\n        tabSet._setWeight(size / 3);\n\n        const horz = !this._model.isRootOrientationVertical();\n\n        if (horz && dockLocation === DockLocation.LEFT || !horz && dockLocation === DockLocation.TOP) {\n            this._addChild(tabSet, 0);\n        } else if (horz && dockLocation === DockLocation.RIGHT || !horz && dockLocation === DockLocation.BOTTOM) {\n            this._addChild(tabSet);\n        } else if (horz && dockLocation === DockLocation.TOP || !horz && dockLocation === DockLocation.LEFT) {\n            const vrow = new RowNode(this._model, {});\n            const hrow = new RowNode(this._model, {});\n            hrow._setWeight(75);\n            tabSet._setWeight(25);\n            for (const child of this._children) {\n                hrow._addChild(child);\n            }\n            this._removeAll();\n            vrow._addChild(tabSet);\n            vrow._addChild(hrow);\n            this._addChild(vrow);\n        } else if (horz && dockLocation === DockLocation.BOTTOM || !horz && dockLocation === DockLocation.RIGHT) {\n            const vrow = new RowNode(this._model, {});\n            const hrow = new RowNode(this._model, {});\n            hrow._setWeight(75);\n            tabSet._setWeight(25);\n            for (const child of this._children) {\n                hrow._addChild(child);\n            }\n            this._removeAll();\n            vrow._addChild(hrow);\n            vrow._addChild(tabSet);\n            this._addChild(vrow);\n        }\n\n        this._model._setActiveTabset(tabSet);\n\n        this._model._tidy();\n    }\n\n    toJson(): IJsonRowNode {\n        const json: any = {};\n        RowNode._attributeDefinitions.toJson(json, this._attributes);\n\n        json.children = [];\n        for (const child of this._children) {\n            json.children.push(child.toJson());\n        }\n\n        return json;\n    }\n\n    isEnableDrop() {\n        return true;\n    }\n\n    /** @internal */\n    _getPrefSize(orientation: Orientation) {\n        let prefSize = this.getWidth();\n        if (orientation === Orientation.VERT) {\n            prefSize = this.getHeight();\n        }\n        return prefSize;\n    }\n\n    /** @internal */\n    _getAttributeDefinitions() {\n        return RowNode._attributeDefinitions;\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        RowNode._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    static getAttributeDefinitions() {\n        return RowNode._attributeDefinitions;\n    }\n\n}\n","import { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderNode } from \"./BorderNode\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IDropTarget } from \"./IDropTarget\";\nimport { IJsonTabSetNode } from \"./IJsonModel\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\nimport { RowNode } from \"./RowNode\";\nimport { TabNode } from \"./TabNode\";\nimport { adjustSelectedIndex } from \"./Utils\";\n\nexport class TabSetNode extends Node implements IDraggable, IDropTarget {\n    static readonly TYPE = \"tabset\";\n\n    /** @internal */\n    static _fromJson(json: any, model: Model) {\n        const newLayoutNode = new TabSetNode(model, json);\n\n        if (json.children != null) {\n            for (const jsonChild of json.children) {\n                const child = TabNode._fromJson(jsonChild, model);\n                newLayoutNode._addChild(child);\n            }\n        }\n        if (newLayoutNode._children.length === 0) {\n            newLayoutNode._setSelected(-1);\n        }\n\n        if (json.maximized && json.maximized === true) {\n            model._setMaximizedTabset(newLayoutNode);\n        }\n\n        if (json.active && json.active === true) {\n            model._setActiveTabset(newLayoutNode);\n        }\n\n        return newLayoutNode;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = TabSetNode._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n        attributeDefinitions.add(\"type\", TabSetNode.TYPE, true).setType(Attribute.STRING).setFixed();\n        attributeDefinitions.add(\"id\", undefined).setType(Attribute.STRING);\n\n        attributeDefinitions.add(\"weight\", 100).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"width\", undefined).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"height\", undefined).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"selected\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"name\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"config\", undefined).setType(\"any\");\n\n        attributeDefinitions.addInherited(\"enableDeleteWhenEmpty\", \"tabSetEnableDeleteWhenEmpty\");\n        attributeDefinitions.addInherited(\"enableDrop\", \"tabSetEnableDrop\");\n        attributeDefinitions.addInherited(\"enableDrag\", \"tabSetEnableDrag\");\n        attributeDefinitions.addInherited(\"enableDivide\", \"tabSetEnableDivide\");\n        attributeDefinitions.addInherited(\"enableMaximize\", \"tabSetEnableMaximize\");\n        attributeDefinitions.addInherited(\"enableClose\", \"tabSetEnableClose\");\n        attributeDefinitions.addInherited(\"classNameTabStrip\", \"tabSetClassNameTabStrip\");\n        attributeDefinitions.addInherited(\"classNameHeader\", \"tabSetClassNameHeader\");\n        attributeDefinitions.addInherited(\"enableTabStrip\", \"tabSetEnableTabStrip\");\n        attributeDefinitions.addInherited(\"borderInsets\", \"tabSetBorderInsets\");\n        attributeDefinitions.addInherited(\"marginInsets\", \"tabSetMarginInsets\");\n        attributeDefinitions.addInherited(\"minWidth\", \"tabSetMinWidth\");\n        attributeDefinitions.addInherited(\"minHeight\", \"tabSetMinHeight\");\n\n        attributeDefinitions.addInherited(\"headerHeight\", \"tabSetHeaderHeight\");\n        attributeDefinitions.addInherited(\"tabStripHeight\", \"tabSetTabStripHeight\");\n        attributeDefinitions.addInherited(\"tabLocation\", \"tabSetTabLocation\");\n        attributeDefinitions.addInherited(\"autoSelectTab\", \"tabSetAutoSelectTab\").setType(Attribute.BOOLEAN);\n        return attributeDefinitions;\n    }\n\n    /** @internal */\n    private _contentRect?: Rect;\n    /** @internal */\n    private _tabHeaderRect?: Rect;\n    /** @internal */\n    private _calculatedTabBarHeight: number;\n    /** @internal */\n    private _calculatedHeaderBarHeight: number;\n\n    /** @internal */\n    constructor(model: Model, json: any) {\n        super(model);\n\n        TabSetNode._attributeDefinitions.fromJson(json, this._attributes);\n        model._addNode(this);\n        this._calculatedTabBarHeight = 0;\n        this._calculatedHeaderBarHeight = 0;\n    }\n\n    getName() {\n        return this._getAttr(\"name\") as string | undefined;\n    }\n\n    getSelected() {\n        const selected = this._attributes.selected;\n        if (selected !== undefined) {\n            return selected as number;\n        }\n        return -1;\n    }\n\n    getSelectedNode() {\n        const selected = this.getSelected();\n        if (selected !== -1) {\n            return this._children[selected];\n        }\n        return undefined;\n    }\n\n    getWeight(): number {\n        return this._getAttr(\"weight\") as number;\n    }\n\n    getWidth() {\n        return this._getAttr(\"width\") as number | undefined;\n    }\n\n    getMinWidth() {\n        return this._getAttr(\"minWidth\") as number;\n    }\n\n    getHeight() {\n        return this._getAttr(\"height\") as number | undefined;\n    }\n\n    getMinHeight() {\n        return this._getAttr(\"minHeight\") as number;\n    }\n\n    /** @internal */\n    getMinSize(orientation: Orientation) {\n        if (orientation === Orientation.HORZ) {\n            return this.getMinWidth();\n        } else {\n            return this.getMinHeight();\n        }\n    }\n\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n    getConfig() {\n        return this._attributes.config;\n    }\n\n    isMaximized() {\n        return this._model.getMaximizedTabset() === this;\n    }\n\n    isActive() {\n        return this._model.getActiveTabset() === this;\n    }\n\n    isEnableDeleteWhenEmpty() {\n        return this._getAttr(\"enableDeleteWhenEmpty\") as boolean;\n    }\n\n    isEnableDrop() {\n        return this._getAttr(\"enableDrop\") as boolean;\n    }\n\n    isEnableDrag() {\n        return this._getAttr(\"enableDrag\") as boolean;\n    }\n\n    isEnableDivide() {\n        return this._getAttr(\"enableDivide\") as boolean;\n    }\n\n    isEnableMaximize() {\n        return this._getAttr(\"enableMaximize\") as boolean;\n    }\n\n    isEnableClose() {\n        return this._getAttr(\"enableClose\") as boolean;\n    }\n\n    canMaximize() {\n        if (this.isEnableMaximize()) {\n            // always allow maximize toggle if already maximized\n            if (this.getModel().getMaximizedTabset() === this) {\n                return true;\n            }\n            // only one tabset, so disable\n            if (this.getParent() === this.getModel().getRoot() && this.getModel().getRoot().getChildren().length === 1) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    isEnableTabStrip() {\n        return this._getAttr(\"enableTabStrip\") as boolean;\n    }\n\n    isAutoSelectTab() {\n        return this._getAttr(\"autoSelectTab\") as boolean;\n    }\n\n    getClassNameTabStrip() {\n        return this._getAttr(\"classNameTabStrip\") as string | undefined;\n    }\n\n    getClassNameHeader() {\n        return this._getAttr(\"classNameHeader\") as string | undefined;\n    }\n\n    /** @internal */\n    calculateHeaderBarHeight(metrics: ILayoutMetrics) {\n        const headerBarHeight = this._getAttr(\"headerHeight\") as number;\n        if (headerBarHeight !== 0) {\n            // its defined\n            this._calculatedHeaderBarHeight = headerBarHeight;\n        } else {\n            this._calculatedHeaderBarHeight = metrics.headerBarSize;\n        }\n    }\n\n    /** @internal */\n    calculateTabBarHeight(metrics: ILayoutMetrics) {\n        const tabBarHeight = this._getAttr(\"tabStripHeight\") as number;\n        if (tabBarHeight !== 0) {\n            // its defined\n            this._calculatedTabBarHeight = tabBarHeight;\n        } else {\n            this._calculatedTabBarHeight = metrics.tabBarSize;\n        }\n    }\n\n    getHeaderHeight() {\n        return this._calculatedHeaderBarHeight;\n    }\n\n    getTabStripHeight() {\n        return this._calculatedTabBarHeight;\n    }\n\n    getTabLocation() {\n        return this._getAttr(\"tabLocation\") as string;\n    }\n\n    /** @internal */\n    _setWeight(weight: number) {\n        this._attributes.weight = weight;\n    }\n\n    /** @internal */\n    _setSelected(index: number) {\n        this._attributes.selected = index;\n    }\n\n    /** @internal */\n    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        let dropInfo;\n\n        if (dragNode === this) {\n            const dockLocation = DockLocation.CENTER;\n            const outlineRect = this._tabHeaderRect;\n            dropInfo = new DropInfo(this, outlineRect!, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        } else if (this._contentRect!.contains(x, y)) {\n            let dockLocation = DockLocation.CENTER;\n            if (this._model.getMaximizedTabset() === undefined) {\n                dockLocation = DockLocation.getLocation(this._contentRect!, x, y);\n            }\n            const outlineRect = dockLocation.getDockRect(this._rect);\n            dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        } else if (this._tabHeaderRect != null && this._tabHeaderRect.contains(x, y)) {\n            let r: Rect;\n            let yy: number;\n            let h: number;\n            if (this._children.length === 0) {\n                r = this._tabHeaderRect.clone();\n                yy = r.y + 3;\n                h = r.height - 4;\n                r.width = 2;\n            } else {\n                let child = this._children[0] as TabNode;\n                r = child.getTabRect()!;\n                yy = r.y;\n                h = r.height;\n                let p = this._tabHeaderRect.x;\n                let childCenter = 0;\n                for (let i = 0; i < this._children.length; i++) {\n                    child = this._children[i] as TabNode;\n                    r = child.getTabRect()!;\n                    childCenter = r.x + r.width / 2;\n                    if (x >= p && x < childCenter) {\n                        const dockLocation = DockLocation.CENTER;\n                        const outlineRect = new Rect(r.x - 2, yy, 3, h);\n                        dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                        break;\n                    }\n                    p = childCenter;\n                }\n            }\n            if (dropInfo == null) {\n                const dockLocation = DockLocation.CENTER;\n                const outlineRect = new Rect(r.getRight() - 2, yy, 3, h);\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n            }\n        }\n\n        if (!dragNode._canDockInto(dragNode, dropInfo)) {\n            return undefined;\n        }\n\n        return dropInfo;\n    }\n\n    /** @internal */\n    _layout(rect: Rect, metrics: ILayoutMetrics) {\n        this.calculateHeaderBarHeight(metrics);\n        this.calculateTabBarHeight(metrics);\n\n        if (this.isMaximized()) {\n            rect = (this._model.getRoot() as Node).getRect();\n        }\n\n        rect = rect.removeInsets(this._getAttr(\"marginInsets\"));\n        this._rect = rect;\n        rect = rect.removeInsets(this._getAttr(\"borderInsets\"));\n\n        const showHeader = this.getName() !== undefined;\n        let y = 0;\n        let h = 0;\n        if (showHeader) {\n            y += this._calculatedHeaderBarHeight;\n            h += this._calculatedHeaderBarHeight;\n        }\n        if (this.isEnableTabStrip()) {\n            if (this.getTabLocation() === \"top\") {\n                this._tabHeaderRect = new Rect(rect.x, rect.y + y, rect.width, this._calculatedTabBarHeight);\n            } else {\n                this._tabHeaderRect = new Rect(rect.x, rect.y + rect.height - this._calculatedTabBarHeight, rect.width, this._calculatedTabBarHeight);\n            }\n            h += this._calculatedTabBarHeight;\n            if (this.getTabLocation() === \"top\") {\n                y += this._calculatedTabBarHeight;\n            }\n        }\n        this._contentRect = new Rect(rect.x, rect.y + y, rect.width, rect.height - h);\n\n        for (let i = 0; i < this._children.length; i++) {\n            const child = this._children[i];\n            child._layout(this._contentRect!, metrics);\n            child._setVisible(i === this.getSelected());\n        }\n    }\n\n    /** @internal */\n    _delete() {\n        (this._parent as RowNode)._removeChild(this);\n    }\n\n    /** @internal */\n    _remove(node: TabNode) {\n        const removedIndex = this._removeChild(node);\n        this._model._tidy();\n\n        adjustSelectedIndex(this, removedIndex);\n    }\n\n    /** @internal */\n    drop(dragNode: Node & IDraggable, location: DockLocation, index: number, select?: boolean) {\n        const dockLocation = location;\n\n        if (this === dragNode) {\n            // tabset drop into itself\n            return; // dock back to itself\n        }\n\n        let dragParent = dragNode.getParent() as BorderNode | TabSetNode | RowNode;\n        let fromIndex = 0;\n        if (dragParent !== undefined) {\n            fromIndex = dragParent._removeChild(dragNode);\n            // if selected node in border is being docked into tabset then deselect border tabs\n            if (dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {\n                dragParent._setSelected(-1);\n            } else {\n                adjustSelectedIndex(dragParent, fromIndex);\n            }\n        }\n\n        // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n        if (dragNode.getType() === TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {\n            index--;\n        }\n\n        // simple_bundled dock to existing tabset\n        if (dockLocation === DockLocation.CENTER) {\n            let insertPos = index;\n            if (insertPos === -1) {\n                insertPos = this._children.length;\n            }\n\n            if (dragNode.getType() === TabNode.TYPE) {\n                this._addChild(dragNode, insertPos);\n                if (select || (select !== false && this.isAutoSelectTab())) {\n                    this._setSelected(insertPos);\n                }\n                // console.log(\"added child at : \" + insertPos);\n            } else {\n                for (let i = 0; i < dragNode.getChildren().length; i++) {\n                    const child = dragNode.getChildren()[i];\n                    this._addChild(child, insertPos);\n                    // console.log(\"added child at : \" + insertPos);\n                    insertPos++;\n                }\n                if (this.getSelected() === -1 && this._children.length > 0) {\n                    this._setSelected(0);\n                }\n            }\n            this._model._setActiveTabset(this);\n        } else {\n            let tabSet: TabSetNode | undefined;\n            if (dragNode instanceof TabNode) {\n                // create new tabset parent\n                // console.log(\"create a new tabset\");\n                const callback = this._model._getOnCreateTabSet();\n                tabSet = new TabSetNode(this._model, callback ? callback(dragNode as TabNode) : {});\n                tabSet._addChild(dragNode);\n                // console.log(\"added child at end\");\n                dragParent = tabSet;\n            } else {\n                tabSet = dragNode as TabSetNode;\n            }\n\n            const parentRow = this._parent as Node;\n            const pos = parentRow.getChildren().indexOf(this);\n\n            if (parentRow.getOrientation() === dockLocation._orientation) {\n                tabSet._setWeight(this.getWeight() / 2);\n                this._setWeight(this.getWeight() / 2);\n                // console.log(\"added child 50% size at: \" +  pos + dockLocation.indexPlus);\n                parentRow._addChild(tabSet, pos + dockLocation._indexPlus);\n            } else {\n                // create a new row to host the new tabset (it will go in the opposite direction)\n                // console.log(\"create a new row\");\n                const newRow = new RowNode(this._model, {});\n                newRow._setWeight(this.getWeight());\n                newRow._addChild(this);\n                this._setWeight(50);\n                tabSet._setWeight(50);\n                // console.log(\"added child 50% size at: \" +  dockLocation.indexPlus);\n                newRow._addChild(tabSet, dockLocation._indexPlus);\n\n                parentRow._removeChild(this);\n                parentRow._addChild(newRow, pos);\n            }\n            this._model._setActiveTabset(tabSet);\n        }\n        this._model._tidy();\n    }\n\n    toJson(): IJsonTabSetNode {\n        const json: any = {};\n        TabSetNode._attributeDefinitions.toJson(json, this._attributes);\n        json.children = this._children.map((child) => child.toJson());\n\n        if (this.isActive()) {\n            json.active = true;\n        }\n\n        if (this.isMaximized()) {\n            json.maximized = true;\n        }\n\n        return json;\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        TabSetNode._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    _getAttributeDefinitions() {\n        return TabSetNode._attributeDefinitions;\n    }\n\n    /** @internal */\n    _getPrefSize(orientation: Orientation) {\n        let prefSize = this.getWidth();\n        if (orientation === Orientation.VERT) {\n            prefSize = this.getHeight();\n        }\n        return prefSize;\n    }\n\n\n    /** @internal */\n    static getAttributeDefinitions() {\n        return TabSetNode._attributeDefinitions;\n    }\n\n}\n","import { TabSetNode } from \"./TabSetNode\";\nimport { BorderNode } from \"./BorderNode\";\nimport { RowNode } from \"./RowNode\";\nimport { TabNode } from \"./TabNode\";\n\n/** @internal */\nexport function adjustSelectedIndexAfterFloat(node: TabNode) {\n    const parent = node.getParent();\n    if (parent !== null) {\n        if (parent instanceof TabSetNode) {\n            let found = false;\n            let newSelected = 0;\n            const children = parent.getChildren();\n            for (let i = 0; i < children.length; i++) {\n                const child = children[i] as TabNode;\n                if (child === node) {\n                    found = true;\n                } else {\n                    if (!child.isFloating()) {\n                        newSelected = i;\n                        if (found) break;\n                    }\n                }\n            }\n            parent._setSelected(newSelected);\n        } else if (parent instanceof BorderNode) {\n            parent._setSelected(-1);\n        }\n    }\n}\n\n/** @internal */\nexport function adjustSelectedIndexAfterDock(node: TabNode) {\n    const parent = node.getParent();\n    if (parent !== null && (parent instanceof TabSetNode || parent instanceof BorderNode)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i] as TabNode;\n            if (child === node) {\n                parent._setSelected(i);\n                return;\n            }\n        }\n    }\n}\n\n/** @internal */\nexport function adjustSelectedIndex(parent: TabSetNode | BorderNode | RowNode, removedIndex: number) {\n    // for the tabset/border being removed from set the selected index\n    if (parent !== undefined && (parent.getType() === TabSetNode.TYPE || parent.getType() === BorderNode.TYPE)) {\n        const selectedIndex = (parent as TabSetNode | BorderNode).getSelected();\n        if (selectedIndex !== -1) {\n            if (removedIndex === selectedIndex && parent.getChildren().length > 0) {\n                if (removedIndex >= parent.getChildren().length) {\n                    // removed last tab; select new last tab\n                    parent._setSelected(parent.getChildren().length - 1);\n                } else {\n                    // leave selected index as is, selecting next tab after this one\n                }\n            } else if (removedIndex < selectedIndex) {\n                parent._setSelected(selectedIndex - 1);\n            } else if (removedIndex > selectedIndex) {\n                // leave selected index as is\n            } else {\n                parent._setSelected(-1);\n            }\n        }\n    }\n}\n\nexport function randomUUID() {\n    // @ts-ignore\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    );\n  }\n\n\n","import { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IDropTarget } from \"./IDropTarget\";\nimport { IJsonBorderNode } from \"./IJsonModel\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\nimport { SplitterNode } from \"./SplitterNode\";\nimport { TabNode } from \"./TabNode\";\nimport { TabSetNode } from \"./TabSetNode\";\nimport { adjustSelectedIndex } from \"./Utils\";\n\nexport class BorderNode extends Node implements IDropTarget {\n    static readonly TYPE = \"border\";\n\n    /** @internal */\n    static _fromJson(json: any, model: Model) {\n        const location = DockLocation.getByName(json.location);\n        const border = new BorderNode(location, json, model);\n        if (json.children) {\n            border._children = json.children.map((jsonChild: any) => {\n                const child = TabNode._fromJson(jsonChild, model);\n                child._setParent(border);\n                return child;\n            });\n        }\n\n        return border;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = BorderNode._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n        attributeDefinitions.add(\"type\", BorderNode.TYPE, true).setType(Attribute.STRING).setFixed();\n\n        attributeDefinitions.add(\"selected\", -1).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"show\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"config\", undefined).setType(\"any\");\n\n        attributeDefinitions.addInherited(\"barSize\", \"borderBarSize\").setType(Attribute.NUMBER);\n        attributeDefinitions.addInherited(\"enableDrop\", \"borderEnableDrop\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"className\", \"borderClassName\").setType(Attribute.STRING);\n        attributeDefinitions.addInherited(\"autoSelectTabWhenOpen\", \"borderAutoSelectTabWhenOpen\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"autoSelectTabWhenClosed\", \"borderAutoSelectTabWhenClosed\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"size\", \"borderSize\").setType(Attribute.NUMBER);\n        attributeDefinitions.addInherited(\"minSize\", \"borderMinSize\").setType(Attribute.NUMBER);\n        attributeDefinitions.addInherited(\"enableAutoHide\", \"borderEnableAutoHide\").setType(Attribute.BOOLEAN);\n        return attributeDefinitions;\n    }\n\n    /** @internal */\n    private _contentRect?: Rect;\n    /** @internal */\n    private _tabHeaderRect?: Rect;\n    /** @internal */\n    private _location: DockLocation;\n    /** @internal */\n    private _drawChildren: Node[];\n    /** @internal */\n    private _adjustedSize: number = 0;\n    /** @internal */\n    private _calculatedBorderBarSize: number = 0;\n\n    /** @internal */\n    constructor(location: DockLocation, json: any, model: Model) {\n        super(model);\n\n        this._location = location;\n        this._drawChildren = [];\n        this._attributes.id = `border_${location.getName()}`;\n        BorderNode._attributeDefinitions.fromJson(json, this._attributes);\n        model._addNode(this);\n    }\n\n    getLocation() {\n        return this._location;\n    }\n\n    getTabHeaderRect() {\n        return this._tabHeaderRect;\n    }\n\n    getRect() {\n        return this._tabHeaderRect!;\n    }\n\n    getContentRect() {\n        return this._contentRect;\n    }\n\n    isEnableDrop() {\n        return this._getAttr(\"enableDrop\") as boolean;\n    }\n\n    isAutoSelectTab(whenOpen?: boolean) {\n        if (whenOpen == null) {\n            whenOpen = this.getSelected() !== -1;\n        }\n        if (whenOpen) {\n            return this._getAttr(\"autoSelectTabWhenOpen\") as boolean;\n        } else {\n            return this._getAttr(\"autoSelectTabWhenClosed\") as boolean;\n        }\n    }\n\n    getClassName() {\n        return this._getAttr(\"className\") as string | undefined;\n    }\n\n    /** @internal */\n    calcBorderBarSize(metrics: ILayoutMetrics) {\n        const barSize = this._getAttr(\"barSize\") as number;\n        if (barSize !== 0) {\n            // its defined\n            this._calculatedBorderBarSize = barSize;\n        } else {\n            this._calculatedBorderBarSize = metrics.borderBarSize;\n        }\n    }\n\n    getBorderBarSize() {\n        return this._calculatedBorderBarSize;\n    }\n\n    getSize() {\n        const defaultSize = this._getAttr(\"size\") as number;\n        const selected = this.getSelected();\n        if (selected === -1) {\n            return defaultSize;\n        } else {\n            const tabNode = this._children[selected] as TabNode;\n            const tabBorderSize = (this._location._orientation === Orientation.HORZ) ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n            if (tabBorderSize === -1) {\n                return defaultSize;\n            } else {\n                return tabBorderSize;\n            }\n        }\n    }\n\n    getMinSize() {\n        return this._getAttr(\"minSize\") as number;\n    }\n\n    getSelected(): number {\n        return this._attributes.selected as number;\n    }\n\n    getSelectedNode(): Node | undefined {\n        if (this.getSelected() !== -1) {\n            return this._children[this.getSelected()];\n        }\n        return undefined;\n    }\n\n    getOrientation() {\n        return this._location.getOrientation();\n    }\n\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n    getConfig() {\n        return this._attributes.config;\n    }\n\n    isMaximized() {\n        return false;\n    }\n\n    isShowing() {\n        const show = this._attributes.show as boolean;\n        if (show) {\n            if (this._model._getShowHiddenBorder() !== this._location && this.isAutoHide() && this._children.length === 0) {\n                return false;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    isAutoHide() {\n        return this._getAttr(\"enableAutoHide\") as boolean;\n    }\n\n    /** @internal */\n    _setSelected(index: number) {\n        this._attributes.selected = index;\n    }\n\n    /** @internal */\n    _setSize(pos: number) {\n        const selected = this.getSelected();\n        if (selected === -1) {\n            this._attributes.size = pos;\n        } else {\n            const tabNode = this._children[selected] as TabNode;\n            const tabBorderSize = (this._location._orientation === Orientation.HORZ) ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n            if (tabBorderSize === -1) {\n                this._attributes.size = pos;\n            } else {\n                if (this._location._orientation === Orientation.HORZ) {\n                    tabNode._setBorderWidth(pos);\n                } else {\n                    tabNode._setBorderHeight(pos);\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        BorderNode._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    _getDrawChildren() {\n        return this._drawChildren;\n    }\n\n    /** @internal */\n    _setAdjustedSize(size: number) {\n        this._adjustedSize = size;\n    }\n\n    /** @internal */\n    _getAdjustedSize() {\n        return this._adjustedSize;\n    }\n\n    /** @internal */\n    _layoutBorderOuter(outer: Rect, metrics: ILayoutMetrics) {\n        this.calcBorderBarSize(metrics);\n        const split1 = this._location.split(outer, this.getBorderBarSize()); // split border outer\n        this._tabHeaderRect = split1.start;\n        return split1.end;\n    }\n\n    /** @internal */\n    _layoutBorderInner(inner: Rect, metrics: ILayoutMetrics) {\n        this._drawChildren = [];\n        const location = this._location;\n\n        const split1 = location.split(inner, this._adjustedSize + this._model.getSplitterSize()); // split off tab contents\n        const split2 = location.reflect().split(split1.start, this._model.getSplitterSize()); // split contents into content and splitter\n\n        this._contentRect = split2.end;\n\n        for (let i = 0; i< this._children.length; i++) {\n            const child = this._children[i];\n            child._layout(this._contentRect!, metrics);\n            child._setVisible(i === this.getSelected());\n            this._drawChildren.push(child);\n        }\n\n        if (this.getSelected() === -1) {\n            return inner;\n        } else {\n            const newSplitter = new SplitterNode(this._model);\n            newSplitter._setParent(this);\n            newSplitter._setRect(split2.start);\n            this._drawChildren.push(newSplitter);\n\n            return split1.end;\n        }\n    }\n\n    /** @internal */\n    _remove(node: TabNode) {\n        const removedIndex = this._removeChild(node);\n        if (this.getSelected() !== -1) {\n            adjustSelectedIndex(this, removedIndex);\n        }\n    }\n\n    /** @internal */\n    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        if (dragNode.getType() !== TabNode.TYPE) {\n            return undefined;\n        }\n\n        let dropInfo;\n        const dockLocation = DockLocation.CENTER;\n\n        if (this._tabHeaderRect!.contains(x, y)) {\n            if (this._location._orientation === Orientation.VERT) {\n                if (this._children.length > 0) {\n                    let child = this._children[0];\n                    let childRect = (child as TabNode).getTabRect()!;\n                    const childY = childRect.y;\n\n                    const childHeight = childRect.height;\n\n                    let pos = this._tabHeaderRect!.x;\n                    let childCenter = 0;\n                    for (let i = 0; i < this._children.length; i++) {\n                        child = this._children[i];\n                        childRect = (child as TabNode).getTabRect()!;\n                        childCenter = childRect.x + childRect.width / 2;\n                        if (x >= pos && x < childCenter) {\n                            const outlineRect = new Rect(childRect.x - 2, childY, 3, childHeight);\n                            dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                            break;\n                        }\n                        pos = childCenter;\n                    }\n                    if (dropInfo == null) {\n                        const outlineRect = new Rect(childRect.getRight() - 2, childY, 3, childHeight);\n                        dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                    }\n                } else {\n                    const outlineRect = new Rect(this._tabHeaderRect!.x + 1, this._tabHeaderRect!.y + 2, 3, 18);\n                    dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                }\n            } else {\n                if (this._children.length > 0) {\n                    let child = this._children[0];\n                    let childRect = (child as TabNode).getTabRect()!;\n                    const childX = childRect.x;\n                    const childWidth = childRect.width;\n\n                    let pos = this._tabHeaderRect!.y;\n                    let childCenter = 0;\n                    for (let i = 0; i < this._children.length; i++) {\n                        child = this._children[i];\n                        childRect = (child as TabNode).getTabRect()!;\n                        childCenter = childRect.y + childRect.height / 2;\n                        if (y >= pos && y < childCenter) {\n                            const outlineRect = new Rect(childX, childRect.y - 2, childWidth, 3);\n                            dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                            break;\n                        }\n                        pos = childCenter;\n                    }\n                    if (dropInfo == null) {\n                        const outlineRect = new Rect(childX, childRect.getBottom() - 2, childWidth, 3);\n                        dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                    }\n                } else {\n                    const outlineRect = new Rect(this._tabHeaderRect!.x + 2, this._tabHeaderRect!.y + 1, 18, 3);\n                    dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                }\n            }\n            if (!dragNode._canDockInto(dragNode, dropInfo)) {\n                return undefined;\n            }\n        } else if (this.getSelected() !== -1 && this._contentRect!.contains(x, y)) {\n            const outlineRect = this._contentRect;\n            dropInfo = new DropInfo(this, outlineRect!, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n            if (!dragNode._canDockInto(dragNode, dropInfo)) {\n                return undefined;\n            }\n        }\n\n        return dropInfo;\n    }\n\n    /** @internal */\n    drop(dragNode: Node & IDraggable, location: DockLocation, index: number, select?: boolean): void {\n        let fromIndex = 0;\n        const dragParent = dragNode.getParent() as BorderNode | TabSetNode;\n        if (dragParent !== undefined) {\n            fromIndex = dragParent._removeChild(dragNode);\n            // if selected node in border is being docked into a different border then deselect border tabs\n            if (dragParent !== this && dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {\n                dragParent._setSelected(-1);\n            } else {\n                adjustSelectedIndex(dragParent, fromIndex);\n            }\n        }\n\n        // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n        if (dragNode.getType() === TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {\n            index--;\n        }\n\n        // simple_bundled dock to existing tabset\n        let insertPos = index;\n        if (insertPos === -1) {\n            insertPos = this._children.length;\n        }\n\n        if (dragNode.getType() === TabNode.TYPE) {\n            this._addChild(dragNode, insertPos);\n        }\n\n        if (select || (select !== false && this.isAutoSelectTab())) {\n            this._setSelected(insertPos);\n        }\n\n        this._model._tidy();\n    }\n\n    toJson(): IJsonBorderNode {\n        const json: any = {};\n        BorderNode._attributeDefinitions.toJson(json, this._attributes);\n        json.location = this._location.getName();\n        json.children = this._children.map((child) => (child as TabNode).toJson());\n        return json;\n    }\n\n    /** @internal */\n    _getSplitterBounds(splitter: SplitterNode, useMinSize: boolean = false) {\n        const pBounds = [0, 0];\n        const minSize = useMinSize ? this.getMinSize() : 0;\n        const outerRect = this._model._getOuterInnerRects().outer;\n        const innerRect = this._model._getOuterInnerRects().inner;\n        const rootRow = this._model.getRoot();\n        if (this._location === DockLocation.TOP) {\n            pBounds[0] = outerRect.y + minSize;\n            pBounds[1] = Math.max(pBounds[0], innerRect.getBottom() - splitter.getHeight() - rootRow.getMinHeight());\n        } else if (this._location === DockLocation.LEFT) {\n            pBounds[0] = outerRect.x + minSize;\n            pBounds[1] = Math.max(pBounds[0], innerRect.getRight() - splitter.getWidth() - rootRow.getMinWidth());\n        } else if (this._location === DockLocation.BOTTOM) {\n            pBounds[1] = outerRect.getBottom() - splitter.getHeight() - minSize;\n            pBounds[0] = Math.min(pBounds[1], innerRect.y + rootRow.getMinHeight());\n        } else if (this._location === DockLocation.RIGHT) {\n            pBounds[1] = outerRect.getRight() - splitter.getWidth() - minSize;\n            pBounds[0] = Math.min(pBounds[1], innerRect.x + rootRow.getMinWidth());\n        }\n        return pBounds;\n    }\n\n    /** @internal */\n    _calculateSplit(splitter: SplitterNode, splitterPos: number) {\n        const pBounds = this._getSplitterBounds(splitter);\n        if (this._location === DockLocation.BOTTOM || this._location === DockLocation.RIGHT) {\n            return Math.max(0, pBounds[1] - splitterPos);\n        } else {\n            return Math.max(0, splitterPos - pBounds[0]);\n        }\n    }\n\n    /** @internal */\n    _getAttributeDefinitions() {\n        return BorderNode._attributeDefinitions;\n    }\n\n    /** @internal */\n    static getAttributeDefinitions() {\n        return BorderNode._attributeDefinitions;\n    }\n\n}\n","export enum I18nLabel {\n    Close_Tab = \"Close\",\n    Close_Tabset = \"Close tabset\",\n    Move_Tab = \"Move: \", // no longer used\n    Move_Tabset = \"Move tabset\",\n    Maximize = \"Maximize tabset\",\n    Restore = \"Restore tabset\",\n    Float_Tab = \"Show selected tab in floating window\",\n    Overflow_Menu_Tooltip = \"Hidden tabs\",\n    Floating_Window_Message = \"This panel is shown in a floating window\",\n    Floating_Window_Show_Window = \"Show window\",\n    Floating_Window_Dock_Window = \"Dock window\",\n    Error_rendering_component = \"Error rendering component\",\n}\n","export enum ICloseType {\n    Visible = 1, // close if selected or hovered, i.e. when x is visible (will only close selected on mobile, where css hover is not available)\n    Always = 2, // close always (both selected and unselected when x rect tapped e.g where a custom image has been added for close)\n    Selected = 3, // close only if selected\n}\n","import * as React from \"react\";\nimport { TabNode } from \"../model/TabNode\";\nimport { IconFactory, ILayoutCallbacks, ITitleObject, TitleFactory } from \"./Layout\";\n\n/** @internal */\nexport function getRenderStateEx(\n    layout: ILayoutCallbacks,\n    node: TabNode,\n    iconFactory?: IconFactory,\n    titleFactory?: TitleFactory\n) {\n    let leadingContent = iconFactory ? iconFactory(node) : undefined;\n    let titleContent: React.ReactNode = node.getName();\n    let name = node.getName();\n\n    function isTitleObject(obj: any): obj is ITitleObject {\n        return obj.titleContent !== undefined\n    }\n\n    if (titleFactory !== undefined) {\n        const titleObj = titleFactory(node);\n        if (titleObj !== undefined) {\n            if (typeof titleObj === \"string\") {\n                titleContent = titleObj as string;\n                name = titleObj as string;\n            } else if (isTitleObject(titleObj)) {\n                titleContent = titleObj.titleContent;\n                name = titleObj.name;\n            } else {\n                titleContent = titleObj;\n            }\n        }\n    }\n\n    if (leadingContent === undefined && node.getIcon() !== undefined) {\n        leadingContent = <img style={{ width: \"1em\", height: \"1em\" }} src={node.getIcon()} alt=\"leadingContent\" />;\n    }\n\n    let buttons: any[] = [];\n\n    // allow customization of leading contents (icon) and contents\n    const renderState = { leading: leadingContent, content: titleContent, name, buttons };\n    layout.customizeTab(node, renderState);\n\n    node._setRenderedName(renderState.name);\n\n    return renderState;\n\n}\n\n/** @internal */\nexport function hideElement(style: Record<string, any>, useVisibility: ConstrainBoolean) {\n    if (useVisibility) {\n        style.visibility = \"hidden\";\n    } else {\n        style.display = \"none\";\n    }\n}\n\n\n/** @internal */\nexport function isAuxMouseEvent(event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>) {\n    let auxEvent = false;\n    if (event.nativeEvent instanceof MouseEvent) {\n        if (event.nativeEvent.button !== 0 || event.ctrlKey || event.altKey || event.metaKey || event.shiftKey) {\n            auxEvent = true;\n        }\n    }\n    return auxEvent;\n}\n\n","import * as React from \"react\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { Actions } from \"../model/Actions\";\nimport { TabNode } from \"../model/TabNode\";\nimport { Rect } from \"../Rect\";\nimport { IconFactory, IIcons, ILayoutCallbacks, TitleFactory } from \"./Layout\";\nimport { ICloseType } from \"../model/ICloseType\";\nimport { CLASSES } from \"../Types\";\nimport { getRenderStateEx, isAuxMouseEvent } from \"./Utils\";\n\n/** @internal */\nexport interface IBorderButtonProps {\n    layout: ILayoutCallbacks;\n    node: TabNode;\n    selected: boolean;\n    border: string;\n    iconFactory?: IconFactory;\n    titleFactory?: TitleFactory;\n    icons: IIcons;\n    path: string;\n}\n\n/** @internal */\nexport const BorderButton = (props: IBorderButtonProps) => {\n    const { layout, node, selected, border, iconFactory, titleFactory, icons, path } = props;\n    const selfRef = React.useRef<HTMLDivElement | null>(null);\n    const contentRef = React.useRef<HTMLInputElement | null>(null);\n\n    const onMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>) => {\n\n        if (!isAuxMouseEvent(event) && !layout.getEditingTab()) {\n            layout.dragStart(event, undefined, node, node.isEnableDrag(), onClick, onDoubleClick);\n        }\n    };\n\n    const onAuxMouseClick = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        if (isAuxMouseEvent(event)) {\n            layout.auxMouseClick(node, event);\n        }\n    };\n\n    const onContextMenu = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        layout.showContextMenu(node, event);\n    };\n\n    const onClick = () => {\n        layout.doAction(Actions.selectTab(node.getId()));\n    };\n\n    const onDoubleClick = (event: Event) => {\n        // if (node.isEnableRename()) {\n        //     onRename();\n        // }\n    };\n\n    // const onRename = () => {\n    //     layout.setEditingTab(node);\n    //     layout.getCurrentDocument()!.body.addEventListener(\"mousedown\", onEndEdit);\n    //     layout.getCurrentDocument()!.body.addEventListener(\"touchstart\", onEndEdit);\n    // };\n\n    const onEndEdit = (event: Event) => {\n        if (event.target !== contentRef.current!) {\n            layout.getCurrentDocument()!.body.removeEventListener(\"mousedown\", onEndEdit);\n            layout.getCurrentDocument()!.body.removeEventListener(\"touchstart\", onEndEdit);\n            layout.setEditingTab(undefined);\n        }\n    };\n\n    const isClosable = () => {\n        const closeType = node.getCloseType();\n        if (selected || closeType === ICloseType.Always) {\n            return true;\n        }\n        if (closeType === ICloseType.Visible) {\n            // not selected but x should be visible due to hover\n            if (window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    const onClose = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (isClosable()) {\n            layout.doAction(Actions.deleteTab(node.getId()));\n        } else {\n            onClick();\n        }\n    };\n\n    const onCloseMouseDown = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        event.stopPropagation();\n    };\n\n    React.useLayoutEffect(() => {\n        updateRect();\n        if (layout.getEditingTab() === node) {\n            (contentRef.current! as HTMLInputElement).select();\n        }\n    });\n\n    const updateRect = () => {\n        // record position of tab in node\n        const layoutRect = layout.getDomRect();\n        const r = selfRef.current!.getBoundingClientRect();\n        node._setTabRect(new Rect(r.left - layoutRect.left, r.top - layoutRect.top, r.width, r.height));\n    };\n\n    const onTextBoxMouseDown = (event: React.MouseEvent<HTMLInputElement> | React.TouchEvent<HTMLInputElement>) => {\n        // console.log(\"onTextBoxMouseDown\");\n        event.stopPropagation();\n    };\n\n    const onTextBoxKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        // console.log(event, event.keyCode);\n        if (event.keyCode === 27) {\n            // esc\n            layout.setEditingTab(undefined);\n        } else if (event.keyCode === 13) {\n            // enter\n            layout.setEditingTab(undefined);\n            layout.doAction(Actions.renameTab(node.getId(), (event.target as HTMLInputElement).value));\n        }\n    };\n\n    const cm = layout.getClassName;\n    let classNames = cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_ + border);\n\n    if (selected) {\n        classNames += \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON__SELECTED);\n    } else {\n        classNames += \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON__UNSELECTED);\n    }\n\n    if (node.getClassName() !== undefined) {\n        classNames += \" \" + node.getClassName();\n    }\n\n    const renderState = getRenderStateEx(layout, node, iconFactory, titleFactory);\n\n    let content = renderState.content ? (\n        <div className={cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_CONTENT)}>\n            {renderState.content}\n        </div>) : null;\n\n    const leading = renderState.leading ? (\n        <div className={cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_LEADING)}>\n            {renderState.leading}\n        </div>) : null;\n\n    if (layout.getEditingTab() === node) {\n        content = (\n            <input\n                ref={contentRef}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX)}\n                data-layout-path={path + \"/textbox\"}\n                type=\"text\"\n                autoFocus={true}\n                defaultValue={node.getName()}\n                onKeyDown={onTextBoxKeyPress}\n                onMouseDown={onTextBoxMouseDown}\n                onTouchStart={onTextBoxMouseDown}\n            />\n        );\n    }\n\n    if (node.isEnableClose()) {\n        const closeTitle = layout.i18nName(I18nLabel.Close_Tab);\n        renderState.buttons.push(\n            <div\n                key=\"close\"\n                data-layout-path={path + \"/button/close\"}\n                title={closeTitle}\n                className={cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_TRAILING)}\n                onMouseDown={onCloseMouseDown}\n                onClick={onClose}\n                onTouchStart={onCloseMouseDown}>\n                {(typeof icons.close === \"function\") ? icons.close(node) : icons.close}\n            </div>\n        );\n    }\n\n    return (\n        <div\n            ref={selfRef}\n            data-layout-path={path}\n            className={classNames}\n            onMouseDown={onMouseDown}\n            onClick={onAuxMouseClick}\n            onAuxClick={onAuxMouseClick}\n            onContextMenu={onContextMenu}\n            onTouchStart={onMouseDown}\n            title={node.getHelpText()}\n        >\n            {leading}\n            {content}\n            {renderState.buttons}\n        </div>\n    );\n};\n","import * as React from \"react\";\nimport { TabNode } from \"../model/TabNode\";\nimport { IconFactory, ILayoutCallbacks, TitleFactory } from \"./Layout\";\nimport { CLASSES } from \"../Types\";\nimport { getRenderStateEx } from \"./Utils\";\n\n/** @internal */\nexport interface ITabButtonStampProps {\n    node: TabNode;\n    layout: ILayoutCallbacks;\n    iconFactory?: IconFactory;\n    titleFactory?: TitleFactory;\n}\n\n/** @internal */\nexport const TabButtonStamp = (props: ITabButtonStampProps) => {\n    const { layout, node, iconFactory, titleFactory } = props;\n    const selfRef = React.useRef<HTMLDivElement | null>(null);\n\n    const cm = layout.getClassName;\n\n    let classNames = cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_STAMP);\n\n    const renderState = getRenderStateEx(layout, node, iconFactory, titleFactory);\n\n    let content = renderState.content ? (\n        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT)}>\n            {renderState.content}\n        </div>)\n        : node._getNameForOverflowMenu();\n\n    const leading = renderState.leading ? (\n        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING)}>\n            {renderState.leading}\n        </div>) : null;\n\n    return (\n        <div\n            ref={selfRef}\n            className={classNames}\n            title={node.getHelpText()}\n        >\n            {leading}\n            {content}\n        </div>\n    );\n};\n","import * as React from \"react\";\nimport { DragDrop } from \"./DragDrop\";\nimport { TabNode } from \"./model/TabNode\";\nimport { CLASSES } from \"./Types\";\nimport { IconFactory, ILayoutCallbacks, TitleFactory } from \"./view/Layout\";\nimport { TabButtonStamp } from \"./view/TabButtonStamp\";\n\n/** @internal */\nexport function showPopup(\n    triggerElement: Element,\n    items: { index: number; node: TabNode }[],\n    onSelect: (item: { index: number; node: TabNode }) => void,\n    layout: ILayoutCallbacks,\n    iconFactory?: IconFactory,\n    titleFactory?: TitleFactory,\n) {\n    const layoutDiv = layout.getRootDiv();\n    const classNameMapper = layout.getClassName;\n    const currentDocument = triggerElement.ownerDocument;\n    const triggerRect = triggerElement.getBoundingClientRect();\n    const layoutRect = layoutDiv.getBoundingClientRect();\n\n    const elm = currentDocument.createElement(\"div\");\n    elm.className = classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU_CONTAINER);\n    if (triggerRect.left < layoutRect.left + layoutRect.width / 2) {\n        elm.style.left = triggerRect.left - layoutRect.left + \"px\";\n    } else {\n        elm.style.right = layoutRect.right - triggerRect.right + \"px\";\n    }\n\n    if (triggerRect.top < layoutRect.top + layoutRect.height / 2) {\n        elm.style.top = triggerRect.top - layoutRect.top + \"px\";\n    } else {\n        elm.style.bottom = layoutRect.bottom - triggerRect.bottom + \"px\";\n    }\n    DragDrop.instance.addGlass(() => onHide());\n    DragDrop.instance.setGlassCursorOverride(\"default\");\n\n    layoutDiv.appendChild(elm);\n\n    const onHide = () => {\n        layout.hidePortal();\n        DragDrop.instance.hideGlass();\n        layoutDiv.removeChild(elm);\n        elm.removeEventListener(\"mousedown\", onElementMouseDown);\n        currentDocument.removeEventListener(\"mousedown\", onDocMouseDown);\n    };\n\n    const onElementMouseDown = (event: Event) => {\n        event.stopPropagation();\n    };\n\n    const onDocMouseDown = (event: Event) => {\n        onHide();\n    };\n\n    elm.addEventListener(\"mousedown\", onElementMouseDown);\n    currentDocument.addEventListener(\"mousedown\", onDocMouseDown);\n\n    layout.showPortal(<PopupMenu\n        currentDocument={currentDocument}\n        onSelect={onSelect}\n        onHide={onHide}\n        items={items}\n        classNameMapper={classNameMapper}\n        layout={layout}\n        iconFactory={iconFactory}\n        titleFactory={titleFactory}\n    />, elm);\n}\n\n/** @internal */\ninterface IPopupMenuProps {\n    items: { index: number; node: TabNode }[];\n    currentDocument: Document;\n    onHide: () => void;\n    onSelect: (item: { index: number; node: TabNode }) => void;\n    classNameMapper: (defaultClassName: string) => string;\n    layout: ILayoutCallbacks;\n    iconFactory?: IconFactory;\n    titleFactory?: TitleFactory;\n}\n\n/** @internal */\nconst PopupMenu = (props: IPopupMenuProps) => {\n    const { items, onHide, onSelect, classNameMapper, layout, iconFactory, titleFactory} = props;\n\n    const onItemClick = (item: { index: number; node: TabNode }, event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        onSelect(item);\n        onHide();\n        event.stopPropagation();\n    };\n\n    const itemElements = items.map((item, i) => (\n        <div key={item.index}\n            className={classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU_ITEM)}\n            data-layout-path={\"/popup-menu/tb\" + i}\n            onClick={(event) => onItemClick(item, event)}\n            title={item.node.getHelpText()} >\n            {item.node.getModel().isLegacyOverflowMenu() ? \n            item.node._getNameForOverflowMenu() :\n            <TabButtonStamp \n                node={item.node}\n                layout={layout}\n                iconFactory={iconFactory}\n                titleFactory={titleFactory}\n            />}\n        </div>\n    ));\n\n    return (\n        <div className={classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU)}\n        data-layout-path=\"/popup-menu\"\n        >\n            {itemElements}\n        </div>);\n};\n","import * as React from \"react\";\nimport { TabNode } from \"../model/TabNode\";\nimport { Rect } from \"../Rect\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { Orientation } from \"../Orientation\";\n\n/** @internal */\nexport const useTabOverflow = (\n    node: TabSetNode | BorderNode,\n    orientation: Orientation,\n    toolbarRef: React.MutableRefObject<HTMLDivElement | null>,\n    stickyButtonsRef: React.MutableRefObject<HTMLDivElement | null>\n) => {\n    const firstRender = React.useRef<boolean>(true);\n    const tabsTruncated = React.useRef<boolean>(false);\n    const lastRect = React.useRef<Rect>(new Rect(0, 0, 0, 0));\n    const selfRef = React.useRef<HTMLDivElement | null>(null);\n\n    const [position, setPosition] = React.useState<number>(0);\n    const userControlledLeft = React.useRef<boolean>(false);\n    const [hiddenTabs, setHiddenTabs] = React.useState<{ node: TabNode; index: number }[]>([]);\n    const lastHiddenCount = React.useRef<number>(0);\n\n    // if selected node or tabset/border rectangle change then unset usercontrolled (so selected tab will be kept in view)\n    React.useLayoutEffect(() => {\n        userControlledLeft.current = false;\n    }, [node.getSelectedNode(), node.getRect().width, node.getRect().height]);\n\n    React.useLayoutEffect(() => {\n        updateVisibleTabs();\n    });\n\n    React.useEffect(() => {\n        const instance = selfRef.current!;\n        instance.addEventListener('wheel', onWheel, { passive: false });\n        return () => {\n            instance.removeEventListener('wheel', onWheel);\n        }\n    }, []);\n\n    // needed to prevent default mouse wheel over tabset/border (cannot do with react event?)\n    const onWheel = (event: Event) => {\n        event.preventDefault();\n    };\n\n    const getNear = (rect: Rect) => {\n        if (orientation === Orientation.HORZ) {\n            return rect.x;\n        } else {\n            return rect.y;\n        }\n    };\n\n    const getFar = (rect: Rect) => {\n        if (orientation === Orientation.HORZ) {\n            return rect.getRight();\n        } else {\n            return rect.getBottom();\n        }\n    };\n\n    const getSize = (rect: DOMRect | Rect) => {\n        if (orientation === Orientation.HORZ) {\n            return rect.width;\n        } else {\n            return rect.height;\n        }\n    };\n\n    const updateVisibleTabs = () => {\n        const tabMargin = 2;\n        if (firstRender.current === true) {\n            tabsTruncated.current = false;\n        }\n        const nodeRect = node instanceof TabSetNode ? node.getRect() : (node as BorderNode).getTabHeaderRect()!;\n        let lastChild = node.getChildren()[node.getChildren().length - 1] as TabNode;\n        const stickyButtonsSize = stickyButtonsRef.current === null ? 0 : getSize(stickyButtonsRef.current!.getBoundingClientRect());\n\n        if (\n            firstRender.current === true ||\n            (lastHiddenCount.current === 0 && hiddenTabs.length !== 0) ||\n            nodeRect.width !== lastRect.current.width || // incase rect changed between first render and second\n            nodeRect.height !== lastRect.current.height\n        ) {\n            lastHiddenCount.current = hiddenTabs.length;\n            lastRect.current = nodeRect;\n            const enabled = node instanceof TabSetNode ? node.isEnableTabStrip() === true : true;\n            let endPos = getFar(nodeRect) - stickyButtonsSize;\n            if (toolbarRef.current !== null) {\n                endPos -= getSize(toolbarRef.current.getBoundingClientRect());\n            }\n            if (enabled && node.getChildren().length > 0) {\n                if (hiddenTabs.length === 0 && position === 0 && getFar(lastChild.getTabRect()!) + tabMargin < endPos) {\n                    return; // nothing to do all tabs are shown in available space\n                }\n\n                let shiftPos = 0;\n\n                const selectedTab = node.getSelectedNode() as TabNode;\n                if (selectedTab && !userControlledLeft.current) {\n                    const selectedRect = selectedTab.getTabRect()!;\n                    const selectedStart = getNear(selectedRect) - tabMargin;\n                    const selectedEnd = getFar(selectedRect) + tabMargin;\n\n                    // when selected tab is larger than available space then align left\n                    if (getSize(selectedRect) + 2 * tabMargin >= endPos - getNear(nodeRect)) {\n                        shiftPos = getNear(nodeRect) - selectedStart;\n                    } else {\n                        if (selectedEnd > endPos || selectedStart < getNear(nodeRect)) {\n                            if (selectedStart < getNear(nodeRect)) {\n                                shiftPos = getNear(nodeRect) - selectedStart;\n                            }\n                            // use second if statement to prevent tab moving back then forwards if not enough space for single tab\n                            if (selectedEnd + shiftPos > endPos) {\n                                shiftPos = endPos - selectedEnd;\n                            }\n                        }\n                    }\n                }\n\n                const extraSpace = Math.max(0, endPos - (getFar(lastChild.getTabRect()!) + tabMargin + shiftPos));\n                const newPosition = Math.min(0, position + shiftPos + extraSpace);\n\n                // find hidden tabs\n                const diff = newPosition - position;\n                const hidden: { node: TabNode; index: number }[] = [];\n                for (let i = 0; i < node.getChildren().length; i++) {\n                    const child = node.getChildren()[i] as TabNode;\n                    if (getNear(child.getTabRect()!) + diff < getNear(nodeRect!) || getFar(child.getTabRect()!) + diff > endPos) {\n                        hidden.push({ node: child, index: i });\n                    }\n                }\n\n                if (hidden.length > 0) {\n                    tabsTruncated.current = true;\n                }\n\n                firstRender.current = false; // need to do a second render\n                setHiddenTabs(hidden);\n                setPosition(newPosition);\n            }\n        } else {\n            firstRender.current = true;\n        }\n    };\n\n    const onMouseWheel = (event: React.WheelEvent<HTMLDivElement>) => {\n        let delta = 0;\n        if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {\n            delta = -event.deltaX;\n        } else {\n            delta = -event.deltaY;\n        }\n        if (event.deltaMode === 1) {\n            // DOM_DELTA_LINE\t0x01\tThe delta values are specified in lines.\n            delta *= 40;\n        }\n        setPosition(position + delta);\n        userControlledLeft.current = true;\n        event.stopPropagation();\n    };\n\n    return { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated: tabsTruncated.current };\n};\n","import * as React from \"react\";\nimport { DockLocation } from \"../DockLocation\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { TabNode } from \"../model/TabNode\";\nimport { BorderButton } from \"./BorderButton\";\nimport { IIcons, ILayoutCallbacks, ITitleObject } from \"./Layout\";\nimport { showPopup } from \"../PopupMenu\";\nimport { Actions } from \"../model/Actions\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { useTabOverflow } from \"./TabOverflowHook\";\nimport { Orientation } from \"../Orientation\";\nimport { CLASSES } from \"../Types\";\nimport { isAuxMouseEvent } from \"./Utils\";\n\n/** @internal */\nexport interface IBorderTabSetProps {\n    border: BorderNode;\n    layout: ILayoutCallbacks;\n    iconFactory?: (node: TabNode) => (React.ReactNode | undefined);\n    titleFactory?: (node: TabNode) => (ITitleObject | React.ReactNode | undefined);\n    icons: IIcons;\n    path: string;\n}\n\n/** @internal */\nexport const BorderTabSet = (props: IBorderTabSetProps) => {\n    const { border, layout, iconFactory, titleFactory, icons, path } = props;\n\n    const toolbarRef = React.useRef<HTMLDivElement | null>(null);\n    const overflowbuttonRef = React.useRef<HTMLButtonElement | null>(null);\n    const stickyButtonsRef = React.useRef<HTMLDivElement | null>(null);\n\n    const { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel } = useTabOverflow(border, Orientation.flip(border.getOrientation()), toolbarRef, stickyButtonsRef);\n\n    const onAuxMouseClick = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        if (isAuxMouseEvent(event)) {\n            layout.auxMouseClick(border, event);\n        }\n    };\n\n    const onContextMenu = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        layout.showContextMenu(border, event);\n    };\n\n    const onInterceptMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.MouseEvent<HTMLButtonElement, MouseEvent> | React.TouchEvent<HTMLButtonElement>) => {\n        event.stopPropagation();\n    };\n\n    const onOverflowClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n        const callback = layout.getShowOverflowMenu();\n        if (callback !== undefined) {\n            callback(border, event, hiddenTabs, onOverflowItemSelect);\n        } else {\n            const element = overflowbuttonRef.current!;\n            showPopup(element,\n                hiddenTabs,\n                onOverflowItemSelect,\n                layout,\n                iconFactory,\n                titleFactory);\n        }\n        event.stopPropagation();\n    };\n\n    const onOverflowItemSelect = (item: { node: TabNode; index: number }) => {\n        layout.doAction(Actions.selectTab(item.node.getId()));\n        userControlledLeft.current = false;\n    };\n\n    const onFloatTab = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n        const selectedTabNode = border.getChildren()[border.getSelected()] as TabNode;\n        if (selectedTabNode !== undefined) {\n            layout.doAction(Actions.floatTab(selectedTabNode.getId()));\n        }\n        event.stopPropagation();\n    };\n\n    const cm = layout.getClassName;\n\n    let style = border.getTabHeaderRect()!.styleWithPosition({});\n    const tabs: any = [];\n\n    const layoutTab = (i: number) => {\n        let isSelected = border.getSelected() === i;\n        let child = border.getChildren()[i] as TabNode;\n\n        tabs.push(\n            <BorderButton\n                layout={layout}\n                border={border.getLocation().getName()}\n                node={child}\n                path={path + \"/tb\" + i}\n                key={child.getId()}\n                selected={isSelected}\n                iconFactory={iconFactory}\n                titleFactory={titleFactory}\n                icons={icons}\n            />\n        );\n        if (i < border.getChildren().length-1) {\n            tabs.push(\n                <div key={\"divider\" + i} className={cm(CLASSES.FLEXLAYOUT__BORDER_TAB_DIVIDER)}></div>\n            );\n        }\n\n    };\n\n    for (let i = 0; i < border.getChildren().length; i++) {\n        layoutTab(i);\n    }\n\n    let borderClasses = cm(CLASSES.FLEXLAYOUT__BORDER) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_ + border.getLocation().getName());\n    if (border.getClassName() !== undefined) {\n        borderClasses += \" \" + border.getClassName();\n    }\n\n    // allow customization of tabset right/bottom buttons\n    let buttons: any[] = [];\n    const renderState = { headerContent: undefined, buttons, stickyButtons: [], headerButtons: [] };\n    layout.customizeTabSet(border, renderState);\n    buttons = renderState.buttons;\n\n    let toolbar;\n\n    if (hiddenTabs.length > 0) {\n        const overflowTitle = layout.i18nName(I18nLabel.Overflow_Menu_Tooltip);\n        let overflowContent;\n        if (typeof icons.more === \"function\") {\n            overflowContent = icons.more(border, hiddenTabs);\n        } else {\n            overflowContent = (<>\n                {icons.more}\n                <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT)}>{hiddenTabs.length}</div>\n            </>);\n        }\n        buttons.push(\n            <button\n                key=\"overflowbutton\"\n                ref={overflowbuttonRef}\n                className={cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_ + border.getLocation().getName())}\n                title={overflowTitle}\n                onClick={onOverflowClick}\n                onMouseDown={onInterceptMouseDown}\n                onTouchStart={onInterceptMouseDown}\n            >\n                {overflowContent}\n            </button>\n        );\n    }\n\n    const selectedIndex = border.getSelected();\n    if (selectedIndex !== -1) {\n        const selectedTabNode = border.getChildren()[selectedIndex] as TabNode;\n        if (selectedTabNode !== undefined && layout.isSupportsPopout() && selectedTabNode.isEnableFloat() && !selectedTabNode.isFloating()) {\n            const floatTitle = layout.i18nName(I18nLabel.Float_Tab);\n            buttons.push(\n                <button\n                    key=\"float\"\n                    title={floatTitle}\n                    className={cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT)}\n                    onClick={onFloatTab}\n                    onMouseDown={onInterceptMouseDown}\n                    onTouchStart={onInterceptMouseDown}\n                >\n                    {(typeof icons.popout === \"function\") ? icons.popout(selectedTabNode) : icons.popout}\n                </button>\n            );\n        }\n    }\n    toolbar = (\n        <div key=\"toolbar\" ref={toolbarRef} className={cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_ + border.getLocation().getName())}>\n            {buttons}\n        </div>\n    );\n\n    style = layout.styleFont(style);\n\n    let innerStyle = {};\n    const borderHeight = border.getBorderBarSize() - 1;\n    if (border.getLocation() === DockLocation.LEFT) {\n        innerStyle = { right: borderHeight, height: borderHeight, top: position };\n    } else if (border.getLocation() === DockLocation.RIGHT) {\n        innerStyle = { left: borderHeight, height: borderHeight, top: position };\n    } else {\n        innerStyle = { height: borderHeight, left: position };\n    }\n\n    return (\n        <div ref={selfRef} dir=\"ltr\" style={style} className={borderClasses}\n            data-layout-path={path}\n            onClick={onAuxMouseClick}\n            onAuxClick={onAuxMouseClick}\n            onContextMenu={onContextMenu}\n            onWheel={onMouseWheel}>\n            <div style={{ height: borderHeight }} className={cm(CLASSES.FLEXLAYOUT__BORDER_INNER) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_INNER_ + border.getLocation().getName())}>\n                <div style={innerStyle} className={cm(CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER) + \" \" + cm(CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_ + border.getLocation().getName())}>\n                    {tabs}\n                </div>\n            </div>\n            {toolbar}\n        </div>\n    );\n};\n","import * as React from \"react\";\nimport { DragDrop } from \"../DragDrop\";\nimport { Actions } from \"../model/Actions\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { Node } from \"../model/Node\";\nimport { RowNode } from \"../model/RowNode\";\nimport { SplitterNode } from \"../model/SplitterNode\";\nimport { Orientation } from \"../Orientation\";\nimport { CLASSES } from \"../Types\";\nimport { ILayoutCallbacks } from \"./Layout\";\n\n/** @internal */\nexport interface ISplitterProps {\n    layout: ILayoutCallbacks;\n    node: SplitterNode;\n    path: string;\n}\n\n/** @internal */\nexport const Splitter = (props: ISplitterProps) => {\n    const { layout, node, path } = props;\n\n    const pBounds = React.useRef<number[]>([]);\n    const outlineDiv = React.useRef<HTMLDivElement | undefined>(undefined);\n    const parentNode = node.getParent() as RowNode | BorderNode;\n\n    const onMouseDown = (event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>) => {\n        DragDrop.instance.setGlassCursorOverride(node.getOrientation() === Orientation.HORZ ? \"ns-resize\" : \"ew-resize\");\n        DragDrop.instance.startDrag(event, onDragStart, onDragMove, onDragEnd, onDragCancel, undefined, undefined, layout.getCurrentDocument(), layout.getRootDiv());\n        pBounds.current = parentNode._getSplitterBounds(node, true);\n        const rootdiv = layout.getRootDiv();\n        outlineDiv.current = layout.getCurrentDocument()!.createElement(\"div\");\n        outlineDiv.current.style.position = \"absolute\";\n        outlineDiv.current.className = layout.getClassName(CLASSES.FLEXLAYOUT__SPLITTER_DRAG);\n        outlineDiv.current.style.cursor = node.getOrientation() === Orientation.HORZ ? \"ns-resize\" : \"ew-resize\";\n        const r = node.getRect();\n        if (node.getOrientation() === Orientation.VERT && r.width < 2) {\n            r.width = 2;\n        } else if (node.getOrientation() === Orientation.HORZ && r.height < 2) {\n            r.height = 2;\n        }\n\n        r.positionElement(outlineDiv.current);\n        rootdiv.appendChild(outlineDiv.current);\n    };\n\n    const onDragCancel = (wasDragging: boolean) => {\n        const rootdiv = layout.getRootDiv();\n        rootdiv.removeChild(outlineDiv.current as Element);\n    };\n\n    const onDragStart = () => {\n        return true;\n    };\n\n    const onDragMove = (event: React.MouseEvent<Element, MouseEvent>) => {\n        const clientRect = layout.getDomRect();\n        const pos = {\n            x: event.clientX - clientRect.left,\n            y: event.clientY - clientRect.top,\n        };\n\n        if (outlineDiv) {\n            if (node.getOrientation() === Orientation.HORZ) {\n                outlineDiv.current!.style.top = getBoundPosition(pos.y - 4) + \"px\";\n            } else {\n                outlineDiv.current!.style.left = getBoundPosition(pos.x - 4) + \"px\";\n            }\n        }\n\n        if (layout.isRealtimeResize()) {\n            updateLayout();\n        }\n    };\n\n    const updateLayout = () => {\n        let value = 0;\n        if (outlineDiv) {\n            if (node.getOrientation() === Orientation.HORZ) {\n                value = outlineDiv.current!.offsetTop;\n            } else {\n                value = outlineDiv.current!.offsetLeft;\n            }\n        }\n\n        if (parentNode instanceof BorderNode) {\n            const pos = (parentNode as BorderNode)._calculateSplit(node, value);\n            layout.doAction(Actions.adjustBorderSplit((node.getParent() as Node).getId(), pos));\n        } else {\n            const splitSpec = parentNode._calculateSplit(node, value);\n            if (splitSpec !== undefined) {\n                layout.doAction(Actions.adjustSplit(splitSpec));\n            }\n        }\n    };\n\n    const onDragEnd = () => {\n        updateLayout();\n\n        const rootdiv = layout.getRootDiv();\n        rootdiv.removeChild(outlineDiv.current as HTMLDivElement);\n    };\n\n    const getBoundPosition = (p: number) => {\n        const bounds = pBounds.current as number[];\n        let rtn = p;\n        if (p < bounds[0]) {\n            rtn = bounds[0];\n        }\n        if (p > bounds[1]) {\n            rtn = bounds[1];\n        }\n\n        return rtn;\n    };\n\n    const cm = layout.getClassName;\n    let r = node.getRect();\n    const style = r.styleWithPosition({\n        cursor: node.getOrientation() === Orientation.HORZ ? \"ns-resize\" : \"ew-resize\",\n    });\n    let className = cm(CLASSES.FLEXLAYOUT__SPLITTER) + \" \" + cm(CLASSES.FLEXLAYOUT__SPLITTER_ + node.getOrientation().getName());\n\n    if (parentNode instanceof BorderNode) {\n        className += \" \" + cm(CLASSES.FLEXLAYOUT__SPLITTER_BORDER);\n    } else {\n        if (node.getModel().getMaximizedTabset() !== undefined) {\n            style.display = \"none\";\n        }\n    }\n\n    const extra = node.getModel().getSplitterExtra();\n    if (extra === 0) {\n        return (<div\n            style={style}\n            data-layout-path={path}\n            className={className}\n            onTouchStart={onMouseDown}\n            onMouseDown={onMouseDown}>\n        </div>);\n    } else {\n        // add extended transparent div for hit testing\n        // extends forward only, so as not to interfere with scrollbars\n        let r2 = r.clone();\n        r2.x = 0;\n        r2.y = 0;\n        if (node.getOrientation() === Orientation.VERT) {\n            r2.width += extra;\n        } else {\n            r2.height += extra;\n        }\n        const style2 = r2.styleWithPosition({\n            cursor: node.getOrientation() === Orientation.HORZ ? \"ns-resize\" : \"ew-resize\"\n        });\n\n        const className2 = cm(CLASSES.FLEXLAYOUT__SPLITTER_EXTRA);\n\n        return (\n            <div\n                style={style}\n                data-layout-path={path}\n                className={className}>\n                <div\n                    style={style2}\n                    className={className2}\n                    onTouchStart={onMouseDown}\n                    onMouseDown={onMouseDown}>\n                </div>\n            </div>);\n    }\n\n};\n","import * as React from \"react\";\nimport { ErrorInfo } from \"react\";\nimport { CLASSES } from \"../Types\";\n\n/** @internal */\nexport interface IErrorBoundaryProps {\n    message: string;\n    children: React.ReactNode;\n}\n/** @internal */\nexport interface IErrorBoundaryState {\n    hasError: boolean;\n}\n\n/** @internal */\nexport class ErrorBoundary extends React.Component<IErrorBoundaryProps, IErrorBoundaryState> {\n    constructor(props: IErrorBoundaryProps) {\n        super(props);\n        this.state = { hasError: false };\n    }\n\n    static getDerivedStateFromError(error: Error) {\n        return { hasError: true };\n    }\n\n    componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n        console.debug(error);\n        console.debug(errorInfo);\n    }\n\n    render() {\n        if (this.state.hasError) {\n            return (\n                <div className={CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER}>\n                    <div className={CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTENT}>{this.props.message}</div>\n                </div>\n            );\n        }\n\n        return this.props.children;\n    }\n}\n","import * as React from \"react\";\nimport { Fragment } from \"react\";\nimport { Actions } from \"../model/Actions\";\nimport { TabNode } from \"../model/TabNode\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { CLASSES } from \"../Types\";\nimport { ILayoutCallbacks } from \"./Layout\";\nimport { ErrorBoundary } from \"./ErrorBoundary\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { hideElement } from \"./Utils\";\n\n/** @internal */\nexport interface ITabProps {\n    layout: ILayoutCallbacks;\n    selected: boolean;\n    node: TabNode;\n    factory: (node: TabNode) => React.ReactNode;\n    path: string;\n}\n\n/** @internal */\nexport const Tab = (props: ITabProps) => {\n    const { layout, selected, node, factory, path } = props;\n    const [renderComponent, setRenderComponent] = React.useState<boolean>(!props.node.isEnableRenderOnDemand() || props.selected);\n\n    React.useLayoutEffect(() => {\n        if (!renderComponent && selected) {\n            // load on demand\n            // console.log(\"load on demand: \" + node.getName());\n            setRenderComponent(true);\n        }\n    });\n\n    const onMouseDown = () => {\n        const parent = node.getParent() as TabSetNode;\n        if (parent.getType() === TabSetNode.TYPE) {\n            if (!parent.isActive()) {\n                layout.doAction(Actions.setActiveTabset(parent.getId()));\n            }\n        }\n    };\n\n    const cm = layout.getClassName;\n    const useVisibility = node.getModel().isUseVisibility();\n\n    const parentNode = node.getParent() as TabSetNode | BorderNode;\n    const style: Record<string, any> = node._styleWithPosition();\n    if (!selected) {\n        hideElement(style, useVisibility);\n    }\n\n    if (parentNode instanceof TabSetNode) {\n        if (node.getModel().getMaximizedTabset() !== undefined && !parentNode.isMaximized()) {\n            hideElement(style, useVisibility);\n        }\n    }\n\n    let child;\n    if (renderComponent) {\n        child = factory(node);\n    }\n\n    let className = cm(CLASSES.FLEXLAYOUT__TAB);\n    if (parentNode instanceof BorderNode) {\n        className += \" \" + cm(CLASSES.FLEXLAYOUT__TAB_BORDER);\n        className += \" \" + cm(CLASSES.FLEXLAYOUT__TAB_BORDER_ + parentNode.getLocation().getName());\n    }\n\n    return (\n        <div\n            className={className}\n            data-layout-path={path}\n            onMouseDown={onMouseDown}\n            onTouchStart={onMouseDown}\n            style={style}>\n            <ErrorBoundary message={props.layout.i18nName(I18nLabel.Error_rendering_component)}>\n                <Fragment>{child}</Fragment>\n            </ErrorBoundary>\n        </div>\n    );\n};\n\n\n","import * as React from \"react\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { Actions } from \"../model/Actions\";\nimport { TabNode } from \"../model/TabNode\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { Rect } from \"../Rect\";\nimport { IconFactory, IIcons, ILayoutCallbacks, TitleFactory } from \"./Layout\";\nimport { ICloseType } from \"../model/ICloseType\";\nimport { CLASSES } from \"../Types\";\nimport { getRenderStateEx, isAuxMouseEvent } from \"./Utils\";\n\n/** @internal */\nexport interface ITabButtonProps {\n    layout: ILayoutCallbacks;\n    node: TabNode;\n    selected: boolean;\n    iconFactory?: IconFactory;\n    titleFactory?: TitleFactory;\n    icons: IIcons;\n    path: string;\n}\n\n/** @internal */\nexport const TabButton = (props: ITabButtonProps) => {\n    const { layout, node, selected, iconFactory, titleFactory, icons, path } = props;\n    const selfRef = React.useRef<HTMLDivElement | null>(null);\n    const contentRef = React.useRef<HTMLInputElement | null>(null);\n\n    const onMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>) => {\n\n        if (!isAuxMouseEvent(event) && !layout.getEditingTab()) {\n            layout.dragStart(event, undefined, node, node.isEnableDrag(), onClick, onDoubleClick);\n        }\n    };\n\n    const onAuxMouseClick = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        if (isAuxMouseEvent(event)) {\n            layout.auxMouseClick(node, event);\n        }\n    };\n\n    const onContextMenu = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        layout.showContextMenu(node, event);\n    };\n\n    const onClick = () => {\n        layout.doAction(Actions.selectTab(node.getId()));\n    };\n\n    const onDoubleClick = (event: Event) => {\n        if (node.isEnableRename()) {\n            onRename();\n        }\n    };\n\n    const onRename = () => {\n        layout.setEditingTab(node);\n        layout.getCurrentDocument()!.body.addEventListener(\"mousedown\", onEndEdit);\n        layout.getCurrentDocument()!.body.addEventListener(\"touchstart\", onEndEdit);\n    };\n\n    const onEndEdit = (event: Event) => {\n        if (event.target !== contentRef.current!) {\n            layout.getCurrentDocument()!.body.removeEventListener(\"mousedown\", onEndEdit);\n            layout.getCurrentDocument()!.body.removeEventListener(\"touchstart\", onEndEdit);\n            layout.setEditingTab(undefined);\n        }\n    };\n\n    const isClosable = () => {\n        const closeType = node.getCloseType();\n        if (selected || closeType === ICloseType.Always) {\n            return true;\n        }\n        if (closeType === ICloseType.Visible) {\n            // not selected but x should be visible due to hover\n            if (window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    const onClose = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (isClosable()) {\n            layout.doAction(Actions.deleteTab(node.getId()));\n        } else {\n            onClick();\n        }\n    };\n\n    const onCloseMouseDown = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        event.stopPropagation();\n    };\n\n    React.useLayoutEffect(() => {\n        updateRect();\n        if (layout.getEditingTab() === node) {\n            (contentRef.current! as HTMLInputElement).select();\n        }\n    });\n\n    const updateRect = () => {\n        // record position of tab in node\n        const layoutRect = layout.getDomRect();\n        const r = selfRef.current!.getBoundingClientRect();\n        node._setTabRect(new Rect(r.left - layoutRect.left, r.top - layoutRect.top, r.width, r.height));\n    };\n\n    const onTextBoxMouseDown = (event: React.MouseEvent<HTMLInputElement> | React.TouchEvent<HTMLInputElement>) => {\n        // console.log(\"onTextBoxMouseDown\");\n        event.stopPropagation();\n    };\n\n    const onTextBoxKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        // console.log(event, event.keyCode);\n        if (event.keyCode === 27) {\n            // esc\n            layout.setEditingTab(undefined);\n        } else if (event.keyCode === 13) {\n            // enter\n            layout.setEditingTab(undefined);\n            layout.doAction(Actions.renameTab(node.getId(), (event.target as HTMLInputElement).value));\n        }\n    };\n\n    const cm = layout.getClassName;\n    const parentNode = node.getParent() as TabSetNode;\n\n    let baseClassName = CLASSES.FLEXLAYOUT__TAB_BUTTON;\n    let classNames = cm(baseClassName);\n    classNames += \" \" + cm(baseClassName + \"_\" + parentNode.getTabLocation());\n\n    if (selected) {\n        classNames += \" \" + cm(baseClassName + \"--selected\");\n    } else {\n        classNames += \" \" + cm(baseClassName + \"--unselected\");\n    }\n\n    if (node.getClassName() !== undefined) {\n        classNames += \" \" + node.getClassName();\n    }\n\n    const renderState = getRenderStateEx(layout, node, iconFactory, titleFactory);\n\n    let content = renderState.content ? (\n        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT)}>\n            {renderState.content}\n        </div>) : null;\n\n    const leading = renderState.leading ? (\n        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING)}>\n            {renderState.leading}\n        </div>) : null;\n\n    if (layout.getEditingTab() === node) {\n        content = (\n            <input\n                ref={contentRef}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX)}\n                data-layout-path={path + \"/textbox\"}\n                type=\"text\"\n                autoFocus={true}\n                defaultValue={node.getName()}\n                onKeyDown={onTextBoxKeyPress}\n                onMouseDown={onTextBoxMouseDown}\n                onTouchStart={onTextBoxMouseDown}\n            />\n        );\n    }\n\n    if (node.isEnableClose()) {\n        const closeTitle = layout.i18nName(I18nLabel.Close_Tab);\n        renderState.buttons.push(\n            <div\n                key=\"close\"\n                data-layout-path={path + \"/button/close\"}\n                title={closeTitle}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TRAILING)}\n                onMouseDown={onCloseMouseDown}\n                onClick={onClose}\n                onTouchStart={onCloseMouseDown}>\n                {(typeof icons.close === \"function\") ? icons.close(node) : icons.close}\n            </div>\n        );\n    }\n\n    return (\n        <div\n            ref={selfRef}\n            data-layout-path={path}\n            className={classNames}\n            onMouseDown={onMouseDown}\n            onClick={onAuxMouseClick}\n            onAuxClick={onAuxMouseClick}\n            onContextMenu={onContextMenu}\n            onTouchStart={onMouseDown}\n            title={node.getHelpText()}\n        >\n            {leading}\n            {content}\n            {renderState.buttons}\n        </div>\n    );\n};\n","import * as React from \"react\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { Actions } from \"../model/Actions\";\nimport { TabNode } from \"../model/TabNode\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { showPopup } from \"../PopupMenu\";\nimport { IIcons, ILayoutCallbacks, ITitleObject } from \"./Layout\";\nimport { TabButton } from \"./TabButton\";\nimport { useTabOverflow } from \"./TabOverflowHook\";\nimport { Orientation } from \"../Orientation\";\nimport { CLASSES } from \"../Types\";\nimport { hideElement, isAuxMouseEvent } from \"./Utils\";\n\n/** @internal */\nexport interface ITabSetProps {\n    layout: ILayoutCallbacks;\n    node: TabSetNode;\n    iconFactory?: (node: TabNode) => (React.ReactNode | undefined);\n    titleFactory?: (node: TabNode) => (ITitleObject | React.ReactNode | undefined);\n    icons: IIcons;\n    editingTab?: TabNode;\n    path?: string;\n}\n\n/** @internal */\nexport const TabSet = (props: ITabSetProps) => {\n    const { node, layout, iconFactory, titleFactory, icons, path } = props;\n\n    const toolbarRef = React.useRef<HTMLDivElement | null>(null);\n    const overflowbuttonRef = React.useRef<HTMLButtonElement | null>(null);\n    const tabbarInnerRef = React.useRef<HTMLDivElement | null>(null);\n    const stickyButtonsRef = React.useRef<HTMLDivElement | null>(null);\n\n    const { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated } = useTabOverflow(node, Orientation.HORZ, toolbarRef, stickyButtonsRef);\n\n    const onOverflowClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n        const callback = layout.getShowOverflowMenu();\n        if (callback !== undefined) {\n            callback(node, event, hiddenTabs, onOverflowItemSelect);\n        } else {\n            const element = overflowbuttonRef.current!;\n            showPopup(\n                element,\n                hiddenTabs,\n                onOverflowItemSelect,\n                layout,\n                iconFactory,\n                titleFactory,\n            );\n        }\n        event.stopPropagation();\n    };\n\n    const onOverflowItemSelect = (item: { node: TabNode; index: number }) => {\n        layout.doAction(Actions.selectTab(item.node.getId()));\n        userControlledLeft.current = false;\n    };\n\n    const onMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>) => {\n        if (!isAuxMouseEvent(event)) {\n            let name = node.getName();\n            if (name === undefined) {\n                name = \"\";\n            } else {\n                name = \": \" + name;\n            }\n            layout.doAction(Actions.setActiveTabset(node.getId()));\n            if (!layout.getEditingTab()) {\n                const message = layout.i18nName(I18nLabel.Move_Tabset, name);\n                if (node.getModel().getMaximizedTabset() !== undefined) {\n                    layout.dragStart(event, message, node, false, (event2: Event) => undefined, onDoubleClick);\n                } else {\n                    layout.dragStart(event, message, node, node.isEnableDrag(), (event2: Event) => undefined, onDoubleClick);\n                }\n            }\n        }\n    };\n\n    const onAuxMouseClick = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        if (isAuxMouseEvent(event)) {\n            layout.auxMouseClick(node, event);\n        }\n    };\n\n    const onContextMenu = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        layout.showContextMenu(node, event);\n    };\n\n    const onInterceptMouseDown = (event: React.MouseEvent | React.TouchEvent) => {\n        event.stopPropagation();\n    };\n\n    const onMaximizeToggle = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n        if (node.canMaximize()) {\n            layout.maximize(node);\n        }\n        event.stopPropagation();\n    };\n\n    const onClose = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n        layout.doAction(Actions.deleteTabset(node.getId()));\n        event.stopPropagation();\n    };\n\n    const onFloatTab = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n        if (selectedTabNode !== undefined) {\n            layout.doAction(Actions.floatTab(selectedTabNode.getId()));\n        }\n        event.stopPropagation();\n    };\n\n    const onDoubleClick = (event: Event) => {\n        if (node.canMaximize()) {\n            layout.maximize(node);\n        }\n    };\n\n    // Start Render\n    const cm = layout.getClassName;\n\n    // tabbar inner can get shifted left via tab rename, this resets scrollleft to 0\n    if (tabbarInnerRef.current !== null && tabbarInnerRef.current!.scrollLeft !== 0) {\n        tabbarInnerRef.current.scrollLeft = 0;\n    }\n\n    const selectedTabNode: TabNode = node.getSelectedNode() as TabNode;\n    let style = node._styleWithPosition();\n\n    if (node.getModel().getMaximizedTabset() !== undefined && !node.isMaximized()) {\n        hideElement(style, node.getModel().isUseVisibility())\n    }\n\n    const tabs = [];\n    if (node.isEnableTabStrip()) {\n        for (let i = 0; i < node.getChildren().length; i++) {\n            const child = node.getChildren()[i] as TabNode;\n            let isSelected = node.getSelected() === i;\n            tabs.push(\n                <TabButton\n                    layout={layout}\n                    node={child}\n                    path={path + \"/tb\" + i}\n                    key={child.getId()}\n                    selected={isSelected}\n                    iconFactory={iconFactory}\n                    titleFactory={titleFactory}\n                    icons={icons}\n                />);\n                if (i < node.getChildren().length-1) {\n                    tabs.push(\n                        <div  key={\"divider\" + i} className={cm(CLASSES.FLEXLAYOUT__TABSET_TAB_DIVIDER)}></div>\n                    );\n                }\n        }\n    }\n\n    const showHeader = node.getName() !== undefined;\n    let stickyButtons: React.ReactNode[] = [];\n    let buttons: React.ReactNode[] = [];\n    let headerButtons: React.ReactNode[] = [];\n\n    // allow customization of header contents and buttons\n    const renderState = { headerContent: node.getName(), stickyButtons, buttons, headerButtons };\n    layout.customizeTabSet(node, renderState);\n    const headerContent = renderState.headerContent;\n    stickyButtons = renderState.stickyButtons;\n    buttons = renderState.buttons;\n    headerButtons = renderState.headerButtons;\n\n    if (stickyButtons.length > 0) {\n        if (tabsTruncated) {\n            buttons = [...stickyButtons, ...buttons];\n        } else {\n            tabs.push(<div\n                ref={stickyButtonsRef}\n                key=\"sticky_buttons_container\"\n                onMouseDown={onInterceptMouseDown}\n                onTouchStart={onInterceptMouseDown}\n                onDragStart={(e) => { e.preventDefault() }}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER)}\n            >\n                {stickyButtons}\n            </div>);\n        }\n    }\n\n    let toolbar;\n    if (hiddenTabs.length > 0) {\n        const overflowTitle = layout.i18nName(I18nLabel.Overflow_Menu_Tooltip);\n        let overflowContent;\n        if (typeof icons.more === \"function\") {\n            overflowContent = icons.more(node, hiddenTabs);\n        } else {\n            overflowContent = (<>\n                {icons.more}\n                <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT)}>{hiddenTabs.length}</div>\n            </>);\n        }\n        buttons.push(\n            <button\n                key=\"overflowbutton\"\n                data-layout-path={path + \"/button/overflow\"}\n\n                ref={overflowbuttonRef}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW)}\n                title={overflowTitle}\n                onClick={onOverflowClick}\n                onMouseDown={onInterceptMouseDown}\n                onTouchStart={onInterceptMouseDown}\n            >\n                {overflowContent}\n            </button>\n        );\n    }\n\n    if (selectedTabNode !== undefined && layout.isSupportsPopout() && selectedTabNode.isEnableFloat() && !selectedTabNode.isFloating()) {\n        const floatTitle = layout.i18nName(I18nLabel.Float_Tab);\n        buttons.push(\n            <button\n                key=\"float\"\n                data-layout-path={path + \"/button/float\"}\n                title={floatTitle}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT)}\n                onClick={onFloatTab}\n                onMouseDown={onInterceptMouseDown}\n                onTouchStart={onInterceptMouseDown}\n            >\n                {(typeof icons.popout === \"function\") ? icons.popout(selectedTabNode) : icons.popout}\n            </button>\n        );\n    }\n    if (node.canMaximize()) {\n        const minTitle = layout.i18nName(I18nLabel.Restore);\n        const maxTitle = layout.i18nName(I18nLabel.Maximize);\n        const btns = showHeader ? headerButtons : buttons;\n        btns.push(\n            <button\n                key=\"max\"\n                data-layout-path={path + \"/button/max\"}\n                title={node.isMaximized() ? minTitle : maxTitle}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_ + (node.isMaximized() ? \"max\" : \"min\"))}\n                onClick={onMaximizeToggle}\n                onMouseDown={onInterceptMouseDown}\n                onTouchStart={onInterceptMouseDown}\n            >\n                {node.isMaximized() ?\n                    (typeof icons.restore === \"function\") ? icons.restore(node) : icons.restore :\n                    (typeof icons.maximize === \"function\") ? icons.maximize(node) : icons.maximize}\n            </button>\n        );\n    }\n\n    if (!node.isMaximized() && node.isEnableClose()) {\n        const title = layout.i18nName(I18nLabel.Close_Tabset);\n        const btns = showHeader ? headerButtons : buttons;\n        btns.push(\n            <button\n                key=\"close\"\n                data-layout-path={path + \"/button/close\"}\n                title={title}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE)}\n                onClick={onClose}\n                onMouseDown={onInterceptMouseDown}\n                onTouchStart={onInterceptMouseDown}\n            >\n                {(typeof icons.closeTabset === \"function\") ? icons.closeTabset(node) : icons.closeTabset}\n            </button>\n        );\n    }\n\n    toolbar = (\n        <div key=\"toolbar\" ref={toolbarRef}\n            className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR)}\n            onMouseDown={onInterceptMouseDown}\n            onTouchStart={onInterceptMouseDown}\n            onDragStart={(e) => { e.preventDefault() }}\n        >\n            {buttons}\n        </div>\n    );\n\n    let header;\n    let tabStrip;\n\n    let tabStripClasses = cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER);\n    if (node.getClassNameTabStrip() !== undefined) {\n        tabStripClasses += \" \" + node.getClassNameTabStrip();\n    }\n    tabStripClasses += \" \" + CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER_ + node.getTabLocation();\n\n    if (node.isActive() && !showHeader) {\n        tabStripClasses += \" \" + cm(CLASSES.FLEXLAYOUT__TABSET_SELECTED);\n    }\n\n    if (node.isMaximized() && !showHeader) {\n        tabStripClasses += \" \" + cm(CLASSES.FLEXLAYOUT__TABSET_MAXIMIZED);\n    }\n\n    if (showHeader) {\n\n        const headerToolbar = (\n            <div key=\"toolbar\" ref={toolbarRef}\n                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR)}\n                onMouseDown={onInterceptMouseDown}\n                onTouchStart={onInterceptMouseDown}\n                onDragStart={(e) => { e.preventDefault() }}\n            >\n                {headerButtons}\n            </div>\n        );\n\n        let tabHeaderClasses = cm(CLASSES.FLEXLAYOUT__TABSET_HEADER);\n        if (node.isActive()) {\n            tabHeaderClasses += \" \" + cm(CLASSES.FLEXLAYOUT__TABSET_SELECTED);\n        }\n        if (node.isMaximized()) {\n            tabHeaderClasses += \" \" + cm(CLASSES.FLEXLAYOUT__TABSET_MAXIMIZED);\n        }\n        if (node.getClassNameHeader() !== undefined) {\n            tabHeaderClasses += \" \" + node.getClassNameHeader();\n        }\n\n        header = (\n            <div className={tabHeaderClasses} style={{ height: node.getHeaderHeight() + \"px\" }}\n                data-layout-path={path + \"/header\"}\n                onMouseDown={onMouseDown}\n                onContextMenu={onContextMenu}\n                onClick={onAuxMouseClick}\n                onAuxClick={onAuxMouseClick}\n                onTouchStart={onMouseDown}>\n                <div className={cm(CLASSES.FLEXLAYOUT__TABSET_HEADER_CONTENT)}>{headerContent}</div>\n                {headerToolbar}\n            </div>\n        );\n    }\n\n    const tabStripStyle: { [key: string]: string } = { height: node.getTabStripHeight() + \"px\" };\n    tabStrip = (\n        <div className={tabStripClasses} style={tabStripStyle}\n            data-layout-path={path + \"/tabstrip\"}\n            onMouseDown={onMouseDown}\n            onContextMenu={onContextMenu}\n            onClick={onAuxMouseClick}\n            onAuxClick={onAuxMouseClick}\n            onTouchStart={onMouseDown}>\n            <div ref={tabbarInnerRef} className={cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER) + \" \" + cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_ + node.getTabLocation())}>\n                <div\n                    style={{ left: position }}\n                    className={cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER) + \" \" + cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_ + node.getTabLocation())}\n                >\n                    {tabs}\n                </div>\n            </div>\n            {toolbar}\n        </div>\n    );\n\n    style = layout.styleFont(style);\n\n    var placeHolder: React.ReactNode = undefined;\n    if (node.getChildren().length === 0) {\n        const placeHolderCallback = layout.getTabSetPlaceHolderCallback();\n        if (placeHolderCallback) {\n            placeHolder = placeHolderCallback(node);\n        }\n    }\n\n    const center = <div className={cm(CLASSES.FLEXLAYOUT__TABSET_CONTENT)}>\n        {placeHolder}\n    </div>\n\n    var content;\n    if (node.getTabLocation() === \"top\") {\n        content = <>{header}{tabStrip}{center}</>;\n    } else {\n        content = <>{header}{center}{tabStrip}</>;\n    }\n\n    return (\n        <div ref={selfRef}\n            dir=\"ltr\"\n            data-layout-path={path}\n            style={style}\n            className={cm(CLASSES.FLEXLAYOUT__TABSET)}\n            onWheel={onMouseWheel}>\n            {content}\n        </div>\n    );\n};\n\n\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\n\n/** @internal */\nexport interface IFloatingWindowProps {\n    title: string;\n    id: string;\n    url: string;\n    rect: Rect;\n    onCloseWindow: (id: string) => void;\n    onSetWindow: (id: string, window: Window) => void;\n}\n\ninterface IStyleSheet {\n    href: string | null;\n    type: string;\n    rules: string[] | null;\n}\n\n/** @internal */\nexport const FloatingWindow = (props: React.PropsWithChildren<IFloatingWindowProps>) => {\n    const { title, id, url, rect, onCloseWindow, onSetWindow, children } = props;\n    const popoutWindow = React.useRef<Window | null>(null);\n    const timerId = React.useRef<any>(null);\n    const [content, setContent] = React.useState<HTMLElement | undefined>(undefined);\n\n    React.useLayoutEffect(() => {\n        if (timerId.current) {\n            clearTimeout(timerId.current);\n        }\n        const r = rect;\n        // Make a local copy of the styles from the current window which will be passed into\n        // the floating window. window.document.styleSheets is mutable and we can't guarantee\n        // the styles will exist when 'popoutWindow.load' is called below.\n        const styles = Array.from(window.document.styleSheets).reduce((result, styleSheet) => {\n            let rules: CSSRuleList | undefined = undefined;\n            try {\n                rules = styleSheet.cssRules;\n            } catch (e) {\n                // styleSheet.cssRules can throw security exception\n            }\n\n            try {\n                return [\n                    ...result,\n                    {\n                        href: styleSheet.href,\n                        type: styleSheet.type,\n                        rules: rules ? Array.from(rules).map(rule => rule.cssText) : null,\n                    }\n                ];\n            } catch (e) {\n                return result;\n            }\n        }, [] as IStyleSheet[]);\n        popoutWindow.current = window.open(url, id, `left=${r.x},top=${r.y},width=${r.width},height=${r.height}`);\n        if (popoutWindow.current !== null) {\n            onSetWindow(id, popoutWindow.current);\n\n            // listen for parent unloading to remove all popouts\n            window.addEventListener(\"beforeunload\", () => {\n                if (popoutWindow.current) {\n                    popoutWindow.current.close();\n                    popoutWindow.current = null;\n                }\n            });\n\n            popoutWindow.current.addEventListener(\"load\", () => {\n                const popoutDocument = popoutWindow.current!.document;\n                popoutDocument.title = title;\n                const popoutContent = popoutDocument.createElement(\"div\");\n                popoutContent.className = CLASSES.FLEXLAYOUT__FLOATING_WINDOW_CONTENT;\n                popoutDocument.body.appendChild(popoutContent);\n                copyStyles(popoutDocument, styles).then(() => {\n                    setContent(popoutContent);\n                });\n\n                // listen for popout unloading (needs to be after load for safari)\n                popoutWindow.current!.addEventListener(\"beforeunload\", () => {\n                    onCloseWindow(id);\n                });\n            });\n        } else {\n            console.warn(`Unable to open window ${url}`);\n            onCloseWindow(id);\n        }\n\n        return () => {\n            // delay so refresh will close window\n            timerId.current = setTimeout(() => {\n                if (popoutWindow.current) {\n                    popoutWindow.current.close();\n                    popoutWindow.current = null;\n                }\n            }, 0);\n        };\n    }, []);\n\n    if (content !== undefined) {\n        return createPortal(children, content!);\n    } else {\n        return null;\n    }\n};\n\n/** @internal */\nfunction copyStyles(doc: Document, styleSheets: IStyleSheet[]): Promise<boolean[]> {\n    const head = doc.head;\n    const promises: Promise<boolean>[] = [];\n    for (const styleSheet of styleSheets) {\n        if (styleSheet.href) {\n            // prefer links since they will keep paths to images etc\n            const styleElement = doc.createElement(\"link\");\n            styleElement.type = styleSheet.type;\n            styleElement.rel = \"stylesheet\";\n            styleElement.href = styleSheet.href!;\n            head.appendChild(styleElement);\n            promises.push(\n                new Promise((resolve, reject) => {\n                    styleElement.onload = () => resolve(true);\n                })\n            );\n        } else {\n            if (styleSheet.rules) {\n                const style = doc.createElement(\"style\");\n                for (const rule of styleSheet.rules) {\n                    style.appendChild(doc.createTextNode(rule));\n                }\n                head.appendChild(style);\n            }\n        }\n    }\n    return Promise.all(promises);\n}\n","import * as React from \"react\";\nimport { TabNode } from \"../model/TabNode\";\nimport { ILayoutCallbacks } from \"./Layout\";\nimport { ErrorBoundary } from \"./ErrorBoundary\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { Fragment } from \"react\";\nimport { CLASSES } from \"../Types\";\n\n/** @internal */\nexport interface IFloatingWindowTabProps {\n    layout: ILayoutCallbacks;\n    node: TabNode;\n    factory: (node: TabNode) => React.ReactNode;\n}\n\n/** @internal */\nexport const FloatingWindowTab = (props: IFloatingWindowTabProps) => {\n    const { layout, node, factory } = props;\n    const cm = layout.getClassName;\n    const child = factory(node);\n\n    return (\n        <div className={cm(CLASSES.FLEXLAYOUT__FLOATING_WINDOW_TAB)}>\n            <ErrorBoundary message={props.layout.i18nName(I18nLabel.Error_rendering_component)}>\n                <Fragment>{child}</Fragment>\n            </ErrorBoundary>\n        </div>\n    );\n};\n","import * as React from \"react\";\nimport { Actions } from \"../model/Actions\";\nimport { TabNode } from \"../model/TabNode\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { CLASSES } from \"../Types\";\nimport { ILayoutCallbacks } from \"./Layout\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { hideElement } from \"./Utils\";\nimport { BorderNode } from \"../model/BorderNode\";\n\n/** @internal */\nexport interface ITabFloatingProps {\n    layout: ILayoutCallbacks;\n    selected: boolean;\n    node: TabNode;\n    path: string;\n}\n\n/** @internal */\nexport const TabFloating = (props: ITabFloatingProps) => {\n    const { layout, selected, node, path } = props;\n\n    const showPopout = () => {\n        if (node.getWindow()) {\n            node.getWindow()!.focus();\n        }\n    }\n\n    const dockPopout = () => {\n        layout.doAction(Actions.unFloatTab(node.getId()));\n    }\n\n    const onMouseDown = () => {\n        const parent = node.getParent() as TabSetNode;\n        if (parent.getType() === TabSetNode.TYPE) {\n            if (!parent.isActive()) {\n                layout.doAction(Actions.setActiveTabset(parent.getId()));\n            }\n        }\n    };\n\n    const onClickFocus = (event: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {\n        event.preventDefault();\n        showPopout();\n    };\n\n    const onClickDock = (event: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {\n        event.preventDefault();\n        dockPopout();\n    };\n\n    const cm = layout.getClassName;\n\n\n    const parentNode = node.getParent() as TabSetNode | BorderNode;\n    const style: Record<string, any> = node._styleWithPosition();\n    if (!selected) {\n        hideElement(style, node.getModel().isUseVisibility());\n    }\n\n    if (parentNode instanceof TabSetNode) {\n        if (node.getModel().getMaximizedTabset() !== undefined && !parentNode.isMaximized()) {\n            hideElement(style, node.getModel().isUseVisibility());\n        }\n    }\n\n    const message = layout.i18nName(I18nLabel.Floating_Window_Message);\n    const showMessage = layout.i18nName(I18nLabel.Floating_Window_Show_Window);\n    const dockMessage = layout.i18nName(I18nLabel.Floating_Window_Dock_Window);\n\n    const customRenderCallback = layout.getOnRenderFloatingTabPlaceholder();\n    if (customRenderCallback) {\n        return (\n            <div className={cm(CLASSES.FLEXLAYOUT__TAB_FLOATING)} onMouseDown={onMouseDown} onTouchStart={onMouseDown} style={style}>\n                {customRenderCallback(dockPopout, showPopout)}\n            </div>\n        );\n    } else {\n        return (\n            <div className={cm(CLASSES.FLEXLAYOUT__TAB_FLOATING)}\n                data-layout-path={path}\n                onMouseDown={onMouseDown}\n                onTouchStart={onMouseDown}\n                style={style}>\n                <div className={cm(CLASSES.FLEXLAYOUT__TAB_FLOATING_INNER)}>\n                    <div>{message}</div>\n                    <div>\n                        <a href=\"#\" onClick={onClickFocus}>\n                            {showMessage}\n                        </a>\n                    </div>\n                    <div>\n                        <a href=\"#\" onClick={onClickDock}>\n                            {dockMessage}\n                        </a>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n};\n","import * as React from \"react\";\n\nconst style = { width: \"1em\", height: \"1em\", display: \"flex\", alignItems: \"center\" };\n\nexport const CloseIcon = () => {\n    return (\n        <svg xmlns=\"http://www.w3.org/2000/svg\" style={style} viewBox=\"0 0 24 24\" >\n            <path fill=\"none\" d=\"M0 0h24v24H0z\" />\n            <path stroke=\"var(--color-icon)\" fill=\"var(--color-icon)\" d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n        </svg>\n    );\n}\n\nexport const MaximizeIcon = () => {\n    return (\n        <svg xmlns=\"http://www.w3.org/2000/svg\" style={style} viewBox=\"0 0 24 24\" fill=\"var(--color-icon)\"><path d=\"M0 0h24v24H0z\" fill=\"none\" /><path stroke=\"var(--color-icon)\" d=\"M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z\" /></svg>\n    );\n}\n\nexport const OverflowIcon = () => {\n    return (\n        <svg xmlns=\"http://www.w3.org/2000/svg\" style={style} viewBox=\"0 0 24 24\" fill=\"var(--color-icon)\"><path d=\"M0 0h24v24H0z\" fill=\"none\" /><path stroke=\"var(--color-icon)\" d=\"M7 10l5 5 5-5z\" /></svg>\n    );\n}\n\nexport const PopoutIcon = () => {\n    return (\n        // <svg xmlns=\"http://www.w3.org/2000/svg\"  style={style}  viewBox=\"0 0 24 24\" fill=\"var(--color-icon)\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path stroke=\"var(--color-icon)\" d=\"M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5z\"/></svg>\n        \n        // <svg xmlns=\"http://www.w3.org/2000/svg\" style={style} fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"var(--color-icon)\" stroke-width=\"2\">\n        //     <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14\" />\n        // </svg>\n\n        <svg xmlns=\"http://www.w3.org/2000/svg\" style={style} viewBox=\"0 0 20 20\" fill=\"var(--color-icon)\">\n            <path d=\"M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z\" />\n            <path d=\"M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z\" />\n        </svg>\n\n    );\n}\n\nexport const RestoreIcon = () => {\n    return (\n        <svg xmlns=\"http://www.w3.org/2000/svg\" style={style} viewBox=\"0 0 24 24\" fill=\"var(--color-icon)\"><path d=\"M0 0h24v24H0z\" fill=\"none\" /><path stroke=\"var(--color-icon)\" d=\"M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z\" /></svg>\n    );\n}\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DragDrop } from \"../DragDrop\";\nimport { DropInfo } from \"../DropInfo\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { Action } from \"../model/Action\";\nimport { Actions } from \"../model/Actions\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { BorderSet } from \"../model/BorderSet\";\nimport { IDraggable } from \"../model/IDraggable\";\nimport { Model, ILayoutMetrics } from \"../model/Model\";\nimport { Node } from \"../model/Node\";\nimport { RowNode } from \"../model/RowNode\";\nimport { SplitterNode } from \"../model/SplitterNode\";\nimport { TabNode } from \"../model/TabNode\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderTabSet } from \"./BorderTabSet\";\nimport { Splitter } from \"./Splitter\";\nimport { Tab } from \"./Tab\";\nimport { TabSet } from \"./TabSet\";\nimport { FloatingWindow } from \"./FloatingWindow\";\nimport { FloatingWindowTab } from \"./FloatingWindowTab\";\nimport { TabFloating } from \"./TabFloating\";\nimport { IJsonTabNode } from \"../model/IJsonModel\";\nimport { Orientation } from \"../Orientation\";\nimport { CloseIcon, MaximizeIcon, OverflowIcon, PopoutIcon, RestoreIcon } from \"./Icons\";\nimport { TabButtonStamp } from \"./TabButtonStamp\";\n\nexport type CustomDragCallback = (dragging: TabNode | IJsonTabNode, over: TabNode, x: number, y: number, location: DockLocation) => void;\nexport type DragRectRenderCallback = (content: React.ReactElement | undefined, node?: Node, json?: IJsonTabNode) => React.ReactElement | undefined;\nexport type FloatingTabPlaceholderRenderCallback = (dockPopout: () => void, showPopout: () => void) => React.ReactElement | undefined;\nexport type NodeMouseEvent = (node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) => void;\nexport type ShowOverflowMenuCallback = (\n    node: TabSetNode | BorderNode,\n    mouseEvent: React.MouseEvent<HTMLElement, MouseEvent>,\n    items: { index: number; node: TabNode }[],\n    onSelect: (item: { index: number; node: TabNode }) => void,\n) => void;\nexport type TabSetPlaceHolderCallback = (node: TabSetNode) => React.ReactNode;\nexport type IconFactory = (node: TabNode) => React.ReactNode;\nexport type TitleFactory = (node: TabNode) => ITitleObject | React.ReactNode;\n\nexport interface ILayoutProps {\n    model: Model;\n    factory: (node: TabNode) => React.ReactNode;\n    font?: IFontValues;\n    fontFamily?: string;\n    iconFactory?: IconFactory;\n    titleFactory?: TitleFactory;\n    icons?: IIcons;\n    onAction?: (action: Action) => Action | undefined;\n    onRenderTab?: (\n        node: TabNode,\n        renderValues: ITabRenderValues, // change the values in this object as required\n    ) => void;\n    onRenderTabSet?: (\n        tabSetNode: TabSetNode | BorderNode,\n        renderValues: ITabSetRenderValues, // change the values in this object as required\n    ) => void;\n    onModelChange?: (model: Model, action: Action) => void;\n    onExternalDrag?: (event: React.DragEvent<HTMLDivElement>) => undefined | {\n        dragText: string,\n        json: any,\n        onDrop?: (node?: Node, event?: Event) => void\n    };\n    classNameMapper?: (defaultClassName: string) => string;\n    i18nMapper?: (id: I18nLabel, param?: string) => string | undefined;\n    supportsPopout?: boolean | undefined;\n    popoutURL?: string | undefined;\n    realtimeResize?: boolean | undefined;\n    onTabDrag?: (dragging: TabNode | IJsonTabNode, over: TabNode, x: number, y: number, location: DockLocation, refresh: () => void) => undefined | {\n        x: number,\n        y: number,\n        width: number,\n        height: number,\n        callback: CustomDragCallback,\n        // Called once when `callback` is not going to be called anymore (user canceled the drag, moved mouse and you returned a different callback, etc)\n        invalidated?: () => void,\n        cursor?: string | undefined\n    };\n    onRenderDragRect?: DragRectRenderCallback;\n    onRenderFloatingTabPlaceholder?: FloatingTabPlaceholderRenderCallback;\n    onContextMenu?: NodeMouseEvent;\n    onAuxMouseClick?: NodeMouseEvent;\n    onShowOverflowMenu?: ShowOverflowMenuCallback;\n    onTabSetPlaceHolder?: TabSetPlaceHolderCallback;\n}\nexport interface IFontValues {\n    size?: string;\n    family?: string;\n    style?: string;\n    weight?: string;\n}\n\nexport interface ITabSetRenderValues {\n    headerContent?: React.ReactNode;\n    centerContent?: React.ReactNode;\n    stickyButtons: React.ReactNode[];\n    buttons: React.ReactNode[];\n    headerButtons: React.ReactNode[];\n}\n\nexport interface ITabRenderValues {\n    leading: React.ReactNode;\n    content: React.ReactNode;\n    name: string;\n    buttons: React.ReactNode[];\n}\n\nexport interface ITitleObject {\n    titleContent: React.ReactNode;\n    name: string;\n}\n\nexport interface ILayoutState {\n    rect: Rect;\n    calculatedHeaderBarSize: number;\n    calculatedTabBarSize: number;\n    calculatedBorderBarSize: number;\n    editingTab?: TabNode;\n    showHiddenBorder: DockLocation;\n    portal?: React.ReactPortal;\n    showEdges?: boolean;\n}\n\nexport interface IIcons {\n    close?: (React.ReactNode | ((tabNode: TabNode) => React.ReactNode));\n    closeTabset?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));\n    popout?: (React.ReactNode | ((tabNode: TabNode) => React.ReactNode));\n    maximize?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));\n    restore?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));\n    more?: (React.ReactNode | ((tabSetNode: (TabSetNode | BorderNode), hiddenTabs: { node: TabNode; index: number }[]) => React.ReactNode));\n}\n\nconst defaultIcons = {\n    close: <CloseIcon />,\n    closeTabset: <CloseIcon />,\n    popout: <PopoutIcon />,\n    maximize: <MaximizeIcon />,\n    restore: <RestoreIcon />,\n    more: <OverflowIcon />,\n};\n\nexport interface ICustomDropDestination {\n    rect: Rect;\n    callback: CustomDragCallback;\n    invalidated: (() => void) | undefined;\n    dragging: TabNode | IJsonTabNode;\n    over: TabNode;\n    x: number;\n    y: number;\n    location: DockLocation;\n    cursor: string | undefined;\n}\n\n/** @internal */\nexport interface ILayoutCallbacks {\n    i18nName(id: I18nLabel, param?: string): string;\n    maximize(tabsetNode: TabSetNode): void;\n    getPopoutURL(): string;\n    isSupportsPopout(): boolean;\n    isRealtimeResize(): boolean;\n    getCurrentDocument(): HTMLDocument | undefined;\n    getClassName(defaultClassName: string): string;\n    doAction(action: Action): Node | undefined;\n    getDomRect(): any;\n    getRootDiv(): HTMLDivElement;\n    dragStart(\n        event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<HTMLDivElement> | undefined,\n        dragDivText: string | undefined,\n        node: Node & IDraggable,\n        allowDrag: boolean,\n        onClick?: (event: Event) => void,\n        onDoubleClick?: (event: Event) => void\n    ): void;\n    customizeTab(\n        tabNode: TabNode,\n        renderValues: ITabRenderValues,\n    ): void;\n    customizeTabSet(\n        tabSetNode: TabSetNode | BorderNode,\n        renderValues: ITabSetRenderValues,\n    ): void;\n    styleFont: (style: Record<string, string>) => Record<string, string>;\n    setEditingTab(tabNode?: TabNode): void;\n    getEditingTab(): TabNode | undefined;\n    getOnRenderFloatingTabPlaceholder(): FloatingTabPlaceholderRenderCallback | undefined;\n    showContextMenu(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>): void;\n    auxMouseClick(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>): void;\n    showPortal: (portal: React.ReactNode, portalDiv: HTMLDivElement) => void;\n    hidePortal: () => void;\n    getShowOverflowMenu(): ShowOverflowMenuCallback | undefined;\n    getTabSetPlaceHolderCallback(): TabSetPlaceHolderCallback | undefined;\n}\n\n// Popout windows work in latest browsers based on webkit (Chrome, Opera, Safari, latest Edge) and Firefox. They do\n// not work on any version if IE or the original Edge browser\n// Assume any recent desktop browser not IE or original Edge will work\n/** @internal */\n// @ts-ignore\nconst isIEorEdge = typeof window !== \"undefined\" && (window.document.documentMode || /Edge\\//.test(window.navigator.userAgent));\n/** @internal */\nconst isDesktop = typeof window !== \"undefined\" && window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches;\n/** @internal */\nconst defaultSupportsPopout: boolean = isDesktop && !isIEorEdge;\n\n/**\n * A React component that hosts a multi-tabbed layout\n */\nexport class Layout extends React.Component<ILayoutProps, ILayoutState> {\n\n    /** @internal */\n    private selfRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private findHeaderBarSizeRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private findTabBarSizeRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private findBorderBarSizeRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private previousModel?: Model;\n    /** @internal */\n    private centerRect?: Rect;\n\n    /** @internal */\n    // private start: number = 0;\n    /** @internal */\n    // private layoutTime: number = 0;\n\n    /** @internal */\n    private tabIds: string[];\n    /** @internal */\n    private newTabJson: IJsonTabNode | undefined;\n    /** @internal */\n    private firstMove: boolean = false;\n    /** @internal */\n    private dragNode?: Node & IDraggable;\n    /** @internal */\n    private dragDiv?: HTMLDivElement;\n    /** @internal */\n    private dragRectRendered: boolean = true;\n    /** @internal */\n    private dragDivText: string | undefined = undefined;\n    /** @internal */\n    private dropInfo: DropInfo | undefined;\n    /** @internal */\n    private customDrop: ICustomDropDestination | undefined;\n    /** @internal */\n    private outlineDiv?: HTMLDivElement;\n    /** @internal */\n    private edgeRectLength = 100;\n    /** @internal */\n    private edgeRectWidth = 10;\n    /** @internal */\n    private fnNewNodeDropped?: (node?: Node, event?: Event) => void;\n    /** @internal */\n    private currentDocument?: HTMLDocument;\n    /** @internal */\n    private currentWindow?: Window;\n    /** @internal */\n    private supportsPopout: boolean;\n    /** @internal */\n    private popoutURL: string;\n    /** @internal */\n    private icons: IIcons;\n    /** @internal */\n    private resizeObserver?: ResizeObserver;\n\n    constructor(props: ILayoutProps) {\n        super(props);\n        this.props.model._setChangeListener(this.onModelChange);\n        this.tabIds = [];\n        this.selfRef = React.createRef<HTMLDivElement>();\n        this.findHeaderBarSizeRef = React.createRef<HTMLDivElement>();\n        this.findTabBarSizeRef = React.createRef<HTMLDivElement>();\n        this.findBorderBarSizeRef = React.createRef<HTMLDivElement>();\n        this.supportsPopout = props.supportsPopout !== undefined ? props.supportsPopout : defaultSupportsPopout;\n        this.popoutURL = props.popoutURL ? props.popoutURL : \"popout.html\";\n        this.icons = { ...defaultIcons, ...props.icons };\n\n        this.state = {\n            rect: new Rect(0, 0, 0, 0),\n            calculatedHeaderBarSize: 25,\n            calculatedTabBarSize: 26,\n            calculatedBorderBarSize: 30,\n            editingTab: undefined,\n            showHiddenBorder: DockLocation.CENTER,\n            showEdges: false,\n        };\n\n        this.onDragEnter = this.onDragEnter.bind(this);\n    }\n\n    /** @internal */\n    styleFont(style: Record<string, string>): Record<string, string> {\n        if (this.props.font) {\n            if (this.selfRef.current) {\n                if (this.props.font.size) {\n                    this.selfRef.current.style.setProperty(\"--font-size\", this.props.font.size);\n                }\n                if (this.props.font.family) {\n                    this.selfRef.current.style.setProperty(\"--font-family\", this.props.font.family);\n                }\n            }\n            if (this.props.font.style) {\n                style.fontStyle = this.props.font.style;\n            }\n            if (this.props.font.weight) {\n                style.fontWeight = this.props.font.weight;\n            }\n        }\n        return style;\n    }\n\n    /** @internal */\n    onModelChange = (action: Action) => {\n        this.forceUpdate();\n        if (this.props.onModelChange) {\n            this.props.onModelChange(this.props.model, action);\n        }\n    };\n\n    /** @internal */\n    doAction(action: Action): Node | undefined {\n        if (this.props.onAction !== undefined) {\n            const outcome = this.props.onAction(action);\n            if (outcome !== undefined) {\n                return this.props.model.doAction(outcome);\n            }\n            return undefined;\n        } else {\n            return this.props.model.doAction(action);\n        }\n    }\n\n    /** @internal */\n    componentDidMount() {\n        this.updateRect();\n        this.updateLayoutMetrics();\n\n        // need to re-render if size changes\n        this.currentDocument = (this.selfRef.current as HTMLDivElement).ownerDocument;\n        this.currentWindow = this.currentDocument.defaultView!;\n        this.resizeObserver = new ResizeObserver(entries => {\n            this.updateRect(entries[0].contentRect);\n        });\n        this.resizeObserver.observe(this.selfRef.current!);\n    }\n\n    /** @internal */\n    componentDidUpdate() {\n        this.updateLayoutMetrics();\n        if (this.props.model !== this.previousModel) {\n            if (this.previousModel !== undefined) {\n                this.previousModel._setChangeListener(undefined); // stop listening to old model\n            }\n            this.props.model._setChangeListener(this.onModelChange);\n            this.previousModel = this.props.model;\n        }\n        // console.log(\"Layout time: \" + this.layoutTime + \"ms Render time: \" + (Date.now() - this.start) + \"ms\");\n    }\n\n    /** @internal */\n    updateRect = (domRect: DOMRectReadOnly = this.getDomRect()) => {\n        const rect = new Rect(0, 0, domRect.width, domRect.height);\n        if (!rect.equals(this.state.rect) && rect.width !== 0 && rect.height !== 0) {\n            this.setState({ rect });\n        }\n    };\n\n    /** @internal */\n    updateLayoutMetrics = () => {\n        if (this.findHeaderBarSizeRef.current) {\n            const headerBarSize = this.findHeaderBarSizeRef.current.getBoundingClientRect().height;\n            if (headerBarSize !== this.state.calculatedHeaderBarSize) {\n                this.setState({ calculatedHeaderBarSize: headerBarSize });\n            }\n        }\n        if (this.findTabBarSizeRef.current) {\n            const tabBarSize = this.findTabBarSizeRef.current.getBoundingClientRect().height;\n            if (tabBarSize !== this.state.calculatedTabBarSize) {\n                this.setState({ calculatedTabBarSize: tabBarSize });\n            }\n        }\n        if (this.findBorderBarSizeRef.current) {\n            const borderBarSize = this.findBorderBarSizeRef.current.getBoundingClientRect().height;\n            if (borderBarSize !== this.state.calculatedBorderBarSize) {\n                this.setState({ calculatedBorderBarSize: borderBarSize });\n            }\n        }\n    };\n\n    /** @internal */\n    getClassName = (defaultClassName: string) => {\n        if (this.props.classNameMapper === undefined) {\n            return defaultClassName;\n        } else {\n            return this.props.classNameMapper(defaultClassName);\n        }\n    };\n\n    /** @internal */\n    getCurrentDocument() {\n        return this.currentDocument;\n    }\n\n    /** @internal */\n    getDomRect() {\n        return this.selfRef.current!.getBoundingClientRect();\n    }\n\n    /** @internal */\n    getRootDiv() {\n        return this.selfRef.current!;\n    }\n\n    /** @internal */\n    isSupportsPopout() {\n        return this.supportsPopout;\n    }\n\n    /** @internal */\n    isRealtimeResize() {\n        return this.props.realtimeResize ?? false;\n    }\n\n    /** @internal */\n    onTabDrag(...args: Parameters<Required<ILayoutProps>['onTabDrag']>) {\n        return this.props.onTabDrag?.(...args);\n    }\n\n    /** @internal */\n    getPopoutURL() {\n        return this.popoutURL;\n    }\n\n    /** @internal */\n    componentWillUnmount() {\n        this.resizeObserver?.unobserve(this.selfRef.current!)\n    }\n\n    /** @internal */\n    setEditingTab(tabNode?: TabNode) {\n        this.setState({ editingTab: tabNode });\n    }\n\n    /** @internal */\n    getEditingTab() {\n        return this.state.editingTab;\n    }\n\n    /** @internal */\n    render() {\n        // first render will be used to find the size (via selfRef)\n        if (!this.selfRef.current) {\n            return (\n                <div ref={this.selfRef} className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT)}>\n                    {this.metricsElements()}\n                </div>\n            );\n        }\n\n        this.props.model._setPointerFine(window && window.matchMedia && window.matchMedia(\"(pointer: fine)\").matches);\n        // this.start = Date.now();\n        const borderComponents: React.ReactNode[] = [];\n        const tabSetComponents: React.ReactNode[] = [];\n        const floatingWindows: React.ReactNode[] = [];\n        const tabComponents: Record<string, React.ReactNode> = {};\n        const splitterComponents: React.ReactNode[] = [];\n\n        const metrics: ILayoutMetrics = {\n            headerBarSize: this.state.calculatedHeaderBarSize,\n            tabBarSize: this.state.calculatedTabBarSize,\n            borderBarSize: this.state.calculatedBorderBarSize\n        };\n        this.props.model._setShowHiddenBorder(this.state.showHiddenBorder);\n\n        this.centerRect = this.props.model._layout(this.state.rect, metrics);\n\n        this.renderBorder(this.props.model.getBorderSet(), borderComponents, tabComponents, floatingWindows, splitterComponents);\n        this.renderChildren(\"\", this.props.model.getRoot(), tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n\n        const nextTopIds: string[] = [];\n        const nextTopIdsMap: Record<string, string> = {};\n\n        // Keep any previous tabs in the same DOM order as before, removing any that have been deleted\n        for (const t of this.tabIds) {\n            if (tabComponents[t]) {\n                nextTopIds.push(t);\n                nextTopIdsMap[t] = t;\n            }\n        }\n        this.tabIds = nextTopIds;\n\n        // Add tabs that have been added to the DOM\n        for (const t of Object.keys(tabComponents)) {\n            if (!nextTopIdsMap[t]) {\n                this.tabIds.push(t);\n            }\n        }\n\n        const edges: React.ReactNode[] = [];\n        if (this.state.showEdges) {\n            const r = this.centerRect;\n            const length = this.edgeRectLength;\n            const width = this.edgeRectWidth;\n            const offset = this.edgeRectLength / 2;\n            const className = this.getClassName(CLASSES.FLEXLAYOUT__EDGE_RECT);\n            const radius = 50;\n            edges.push(<div key=\"North\" style={{ top: r.y, left: r.x + r.width / 2 - offset, width: length, height: width, borderBottomLeftRadius: radius, borderBottomRightRadius: radius }} className={className}></div>)\n            edges.push(<div key=\"West\" style={{ top: r.y + r.height / 2 - offset, left: r.x, width: width, height: length, borderTopRightRadius: radius, borderBottomRightRadius: radius }} className={className}></div>)\n            edges.push(<div key=\"South\" style={{ top: r.y + r.height - width, left: r.x + r.width / 2 - offset, width: length, height: width, borderTopLeftRadius: radius, borderTopRightRadius: radius }} className={className}></div>)\n            edges.push(<div key=\"East\" style={{ top: r.y + r.height / 2 - offset, left: r.x + r.width - width, width: width, height: length, borderTopLeftRadius: radius, borderBottomLeftRadius: radius }} className={className}></div>)\n        }\n\n        // this.layoutTime = (Date.now() - this.start);\n\n        return (\n            <div ref={this.selfRef} className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT)} onDragEnter={this.props.onExternalDrag ? this.onDragEnter : undefined}>\n                {tabSetComponents}\n                {this.tabIds.map((t) => {\n                    return tabComponents[t];\n                })}\n                {borderComponents}\n                {splitterComponents}\n                {edges}\n                {floatingWindows}\n                {this.metricsElements()}\n                {this.state.portal}\n            </div>\n        );\n    }\n\n    /** @internal */\n    metricsElements() {\n        // used to measure the tab and border tab sizes\n        const fontStyle = this.styleFont({ visibility: \"hidden\" });\n        return (\n            <React.Fragment>\n                <div key=\"findHeaderBarSize\" ref={this.findHeaderBarSizeRef} style={fontStyle} className={this.getClassName(CLASSES.FLEXLAYOUT__TABSET_HEADER_SIZER)}>\n                    FindHeaderBarSize\n                </div>\n                <div key=\"findTabBarSize\" ref={this.findTabBarSizeRef} style={fontStyle} className={this.getClassName(CLASSES.FLEXLAYOUT__TABSET_SIZER)}>\n                    FindTabBarSize\n                </div>\n                <div key=\"findBorderBarSize\" ref={this.findBorderBarSizeRef} style={fontStyle} className={this.getClassName(CLASSES.FLEXLAYOUT__BORDER_SIZER)}>\n                    FindBorderBarSize\n                </div>\n            </React.Fragment>\n        );\n    }\n\n    /** @internal */\n    onCloseWindow = (id: string) => {\n        this.doAction(Actions.unFloatTab(id));\n        try {\n            (this.props.model.getNodeById(id) as TabNode)._setWindow(undefined);\n        } catch (e) {\n            // catch incase it was a model change\n        }\n    };\n\n    /** @internal */\n    onSetWindow = (id: string, window: Window) => {\n        (this.props.model.getNodeById(id) as TabNode)._setWindow(window);\n    };\n\n    /** @internal */\n    renderBorder(borderSet: BorderSet, borderComponents: React.ReactNode[], tabComponents: Record<string, React.ReactNode>, floatingWindows: React.ReactNode[], splitterComponents: React.ReactNode[]) {\n        for (const border of borderSet.getBorders()) {\n            const borderPath = `/border/${border.getLocation().getName()}`;\n            if (border.isShowing()) {\n                borderComponents.push(\n                    <BorderTabSet\n                        key={`border_${border.getLocation().getName()}`}\n                        path={borderPath}\n                        border={border}\n                        layout={this}\n                        iconFactory={this.props.iconFactory}\n                        titleFactory={this.props.titleFactory}\n                        icons={this.icons}\n                    />\n                );\n                const drawChildren = border._getDrawChildren();\n                let i = 0;\n                let tabCount = 0;\n                for (const child of drawChildren) {\n                    if (child instanceof SplitterNode) {\n                        let path = borderPath + \"/s\";\n                        splitterComponents.push(<Splitter key={child.getId()} layout={this} node={child} path={path} />);\n                    } else if (child instanceof TabNode) {\n                        let path = borderPath + \"/t\" + tabCount++;\n                        if (this.supportsPopout && child.isFloating()) {\n                            const rect = this._getScreenRect(child);\n                            floatingWindows.push(\n                                <FloatingWindow\n                                    key={child.getId()}\n                                    url={this.popoutURL}\n                                    rect={rect}\n                                    title={child.getName()}\n                                    id={child.getId()}\n                                    onSetWindow={this.onSetWindow}\n                                    onCloseWindow={this.onCloseWindow}\n                                >\n                                    <FloatingWindowTab layout={this} node={child} factory={this.props.factory} />\n                                </FloatingWindow>\n                            );\n                            tabComponents[child.getId()] = <TabFloating key={child.getId()}\n                                layout={this}\n                                path={path}\n                                node={child}\n                                selected={i === border.getSelected()\n                                } />;\n                        } else {\n                            tabComponents[child.getId()] = <Tab key={child.getId()}\n                                layout={this}\n                                path={path}\n                                node={child}\n                                selected={i === border.getSelected()}\n                                factory={this.props.factory} />;\n                        }\n                    }\n                    i++;\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    renderChildren(path: string, node: RowNode | TabSetNode, tabSetComponents: React.ReactNode[], tabComponents: Record<string, React.ReactNode>, floatingWindows: React.ReactNode[], splitterComponents: React.ReactNode[]) {\n        const drawChildren = node._getDrawChildren();\n        let splitterCount = 0;\n        let tabCount = 0;\n        let rowCount = 0;\n\n        for (const child of drawChildren!) {\n            if (child instanceof SplitterNode) {\n                const newPath = path + \"/s\" + (splitterCount++);\n                splitterComponents.push(<Splitter key={child.getId()} layout={this} path={newPath} node={child} />);\n            } else if (child instanceof TabSetNode) {\n                const newPath = path + \"/ts\" + (rowCount++);\n                tabSetComponents.push(<TabSet key={child.getId()} layout={this} path={newPath} node={child} iconFactory={this.props.iconFactory} titleFactory={this.props.titleFactory} icons={this.icons} />);\n                this.renderChildren(newPath, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n            } else if (child instanceof TabNode) {\n                const newPath = path + \"/t\" + (tabCount++);\n                const selectedTab = child.getParent()!.getChildren()[(child.getParent() as TabSetNode).getSelected()];\n                if (selectedTab === undefined) {\n                    // this should not happen!\n                    console.warn(\"undefined selectedTab should not happen\");\n                }\n                if (this.supportsPopout && child.isFloating()) {\n                    const rect = this._getScreenRect(child);\n                    floatingWindows.push(\n                        <FloatingWindow\n                            key={child.getId()}\n                            url={this.popoutURL}\n                            rect={rect}\n                            title={child.getName()}\n                            id={child.getId()}\n                            onSetWindow={this.onSetWindow}\n                            onCloseWindow={this.onCloseWindow}\n                        >\n                            <FloatingWindowTab layout={this} node={child} factory={this.props.factory} />\n                        </FloatingWindow>\n                    );\n                    tabComponents[child.getId()] = <TabFloating key={child.getId()} layout={this} path={newPath} node={child} selected={child === selectedTab} />;\n                } else {\n                    tabComponents[child.getId()] = <Tab key={child.getId()} layout={this} path={newPath} node={child} selected={child === selectedTab} factory={this.props.factory} />;\n                }\n            } else {\n                // is row\n                const newPath = path + ((child.getOrientation() === Orientation.HORZ) ? \"/r\" : \"/c\") + (rowCount++);\n                this.renderChildren(newPath, child as RowNode, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n            }\n        }\n    }\n\n    /** @internal */\n    _getScreenRect(node: TabNode) {\n        const rect = node!.getRect()!.clone();\n        const bodyRect: DOMRect = this.selfRef.current!.getBoundingClientRect();\n        const navHeight = Math.min(80, this.currentWindow!.outerHeight - this.currentWindow!.innerHeight);\n        const navWidth = Math.min(80, this.currentWindow!.outerWidth - this.currentWindow!.innerWidth);\n        rect.x = rect.x + bodyRect.x + this.currentWindow!.screenX + navWidth;\n        rect.y = rect.y + bodyRect.y + this.currentWindow!.screenY + navHeight;\n        return rect;\n    }\n\n    /**\n     * Adds a new tab to the given tabset\n     * @param tabsetId the id of the tabset where the new tab will be added\n     * @param json the json for the new tab node\n     */\n    addTabToTabSet(tabsetId: string, json: IJsonTabNode) {\n        const tabsetNode = this.props.model.getNodeById(tabsetId);\n        if (tabsetNode !== undefined) {\n            this.doAction(Actions.addNode(json, tabsetId, DockLocation.CENTER, -1));\n        }\n    }\n\n    /**\n     * Adds a new tab to the active tabset (if there is one)\n     * @param json the json for the new tab node\n     */\n    addTabToActiveTabSet(json: IJsonTabNode) {\n        const tabsetNode = this.props.model.getActiveTabset();\n        if (tabsetNode !== undefined) {\n            this.doAction(Actions.addNode(json, tabsetNode.getId(), DockLocation.CENTER, -1));\n        }\n    }\n\n    /**\n     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts immediatelly\n     * @param dragText the text to show on the drag panel\n     * @param json the json for the new tab node\n     * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n     */\n    addTabWithDragAndDrop(dragText: string | undefined, json: IJsonTabNode, onDrop?: (node?: Node, event?: Event) => void) {\n        this.fnNewNodeDropped = onDrop;\n        this.newTabJson = json;\n        this.dragStart(undefined, dragText, TabNode._fromJson(json, this.props.model, false), true, undefined, undefined);\n    }\n\n    /**\n     * Move a tab/tabset using drag and drop\n     * @param node the tab or tabset to drag\n     * @param dragText the text to show on the drag panel\n     */\n    moveTabWithDragAndDrop(node: (TabNode | TabSetNode), dragText?: string) {\n        this.dragStart(undefined, dragText, node, true, undefined, undefined);\n    }\n\n    /**\n     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts when you\n     * mouse down on the panel\n     *\n     * @param dragText the text to show on the drag panel\n     * @param json the json for the new tab node\n     * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n     */\n    addTabWithDragAndDropIndirect(dragText: string | undefined, json: IJsonTabNode, onDrop?: (node?: Node, event?: Event) => void) {\n        this.fnNewNodeDropped = onDrop;\n        this.newTabJson = json;\n\n        DragDrop.instance.addGlass(this.onCancelAdd);\n\n        this.dragDivText = dragText;\n        this.dragDiv = this.currentDocument!.createElement(\"div\");\n        this.dragDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);\n        this.dragDiv.addEventListener(\"mousedown\", this.onDragDivMouseDown);\n        this.dragDiv.addEventListener(\"touchstart\", this.onDragDivMouseDown, { passive: false });\n\n        this.dragRectRender(this.dragDivText, undefined, this.newTabJson, () => {\n            if (this.dragDiv) {\n                // now it's been rendered into the dom it can be centered\n                this.dragDiv.style.visibility = \"visible\";\n                const domRect = this.dragDiv.getBoundingClientRect();\n                const r = new Rect(0, 0, domRect?.width, domRect?.height);\n                r.centerInRect(this.state.rect);\n                this.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n                this.dragDiv.style.left = r.x + \"px\";\n                this.dragDiv.style.top = r.y + \"px\";\n            }\n        });\n\n        const rootdiv = this.selfRef.current;\n        rootdiv!.appendChild(this.dragDiv);\n    }\n\n    /** @internal */\n    onCancelAdd = () => {\n        const rootdiv = this.selfRef.current;\n        rootdiv!.removeChild(this.dragDiv!);\n        this.dragDiv = undefined;\n        this.hidePortal();\n        if (this.fnNewNodeDropped != null) {\n            this.fnNewNodeDropped();\n            this.fnNewNodeDropped = undefined;\n        }\n\n        try {\n            this.customDrop?.invalidated?.()\n        } catch (e) {\n            console.error(e)\n        }\n\n        DragDrop.instance.hideGlass();\n        this.newTabJson = undefined;\n        this.customDrop = undefined;\n    };\n\n    /** @internal */\n    onCancelDrag = (wasDragging: boolean) => {\n        if (wasDragging) {\n            const rootdiv = this.selfRef.current!;\n\n            try {\n                rootdiv.removeChild(this.outlineDiv!);\n            } catch (e) { }\n\n            try {\n                rootdiv.removeChild(this.dragDiv!);\n            } catch (e) { }\n\n            this.dragDiv = undefined;\n            this.hidePortal();\n            this.setState({ showEdges: false });\n            if (this.fnNewNodeDropped != null) {\n                this.fnNewNodeDropped();\n                this.fnNewNodeDropped = undefined;\n            }\n\n            try {\n                this.customDrop?.invalidated?.()\n            } catch (e) {\n                console.error(e)\n            }\n\n            DragDrop.instance.hideGlass();\n            this.newTabJson = undefined;\n            this.customDrop = undefined;\n        }\n        this.setState({ showHiddenBorder: DockLocation.CENTER });\n\n    };\n\n    /** @internal */\n    onDragDivMouseDown = (event: Event) => {\n        event.preventDefault();\n        this.dragStart(event, this.dragDivText, TabNode._fromJson(this.newTabJson, this.props.model, false), true, undefined, undefined);\n    };\n\n    /** @internal */\n    dragStart = (\n        event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<HTMLDivElement> | undefined,\n        dragDivText: string | undefined,\n        node: Node & IDraggable,\n        allowDrag: boolean,\n        onClick?: (event: Event) => void,\n        onDoubleClick?: (event: Event) => void\n    ) => {\n        if (!allowDrag) {\n            DragDrop.instance.startDrag(event, undefined, undefined, undefined, undefined, onClick, onDoubleClick, this.currentDocument, this.selfRef.current!);\n        } else {\n            this.dragNode = node;\n            this.dragDivText = dragDivText;\n            DragDrop.instance.startDrag(event, this.onDragStart, this.onDragMove, this.onDragEnd, this.onCancelDrag, onClick, onDoubleClick, this.currentDocument, this.selfRef.current!);\n        }\n    };\n\n    /** @internal */\n    dragRectRender = (text: String | undefined, node?: Node, json?: IJsonTabNode, onRendered?: () => void) => {\n        let content: React.ReactElement | undefined;\n\n        if (text !== undefined) {\n            content = <div style={{ whiteSpace: \"pre\" }}>{text.replace(\"<br>\", \"\\n\")}</div>;\n        } else {\n            if (node && node instanceof TabNode) {\n                content = (<TabButtonStamp\n                    node={node}\n                    layout={this}\n                    iconFactory={this.props.iconFactory}\n                    titleFactory={this.props.titleFactory}\n                />);\n            }\n        }\n\n        if (this.props.onRenderDragRect !== undefined) {\n            const customContent = this.props.onRenderDragRect(content, node, json);\n            if (customContent !== undefined) {\n                content = customContent;\n            }\n        }\n\n        // hide div until the render is complete\n        this.dragDiv!.style.visibility = \"hidden\";\n        this.dragRectRendered = false;\n        this.showPortal(\n            <DragRectRenderWrapper\n                // wait for it to be rendered\n                onRendered={() => {\n                    this.dragRectRendered = true;\n                    onRendered?.();\n                }}>\n                {content}\n            </DragRectRenderWrapper>,\n            this.dragDiv!);\n    };\n\n    /** @internal */\n    showPortal = (control: React.ReactNode, element: HTMLElement) => {\n        const portal = createPortal(control, element) as React.ReactPortal;\n        this.setState({ portal });\n    };\n\n    /** @internal */\n    hidePortal = () => {\n        this.setState({ portal: undefined });\n    };\n\n    /** @internal */\n    onDragStart = () => {\n        this.dropInfo = undefined;\n        this.customDrop = undefined;\n        const rootdiv = this.selfRef.current!;\n        this.outlineDiv = this.currentDocument!.createElement(\"div\");\n        this.outlineDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        this.outlineDiv.style.visibility = \"hidden\";\n        rootdiv.appendChild(this.outlineDiv);\n\n        if (this.dragDiv == null) {\n            this.dragDiv = this.currentDocument!.createElement(\"div\");\n            this.dragDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);\n            this.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n            this.dragRectRender(this.dragDivText, this.dragNode, this.newTabJson);\n\n            rootdiv.appendChild(this.dragDiv);\n        }\n        // add edge indicators\n        if (this.props.model.getMaximizedTabset() === undefined) {\n            this.setState({ showEdges: true });\n        }\n\n        if (this.dragNode !== undefined && this.dragNode instanceof TabNode && this.dragNode.getTabRect() !== undefined) {\n            this.dragNode.getTabRect()!.positionElement(this.outlineDiv);\n        }\n        this.firstMove = true;\n\n        return true;\n    };\n\n    /** @internal */\n    onDragMove = (event: React.MouseEvent<Element>) => {\n        if (this.firstMove === false) {\n            const speed = this.props.model._getAttribute(\"tabDragSpeed\") as number;\n            this.outlineDiv!.style.transition = `top ${speed}s, left ${speed}s, width ${speed}s, height ${speed}s`;\n        }\n        this.firstMove = false;\n        const clientRect = this.selfRef.current!.getBoundingClientRect();\n        const pos = {\n            x: event.clientX - clientRect.left,\n            y: event.clientY - clientRect.top,\n        };\n\n        this.checkForBorderToShow(pos.x, pos.y);\n\n        // keep it between left & right\n        const dragRect = this.dragDiv!.getBoundingClientRect();\n        let newLeft = pos.x - dragRect.width / 2;\n        if (newLeft + dragRect.width > clientRect.width) {\n            newLeft = clientRect.width - dragRect.width;\n        }\n        newLeft = Math.max(0, newLeft);\n\n        this.dragDiv!.style.left = newLeft + \"px\";\n        this.dragDiv!.style.top = pos.y + 5 + \"px\";\n        if (this.dragRectRendered && this.dragDiv!.style.visibility === \"hidden\") {\n            // make visible once the drag rect has been rendered\n            this.dragDiv!.style.visibility = \"visible\";\n        }\n\n        let dropInfo = this.props.model._findDropTargetNode(this.dragNode!, pos.x, pos.y);\n        if (dropInfo) {\n            if (this.props.onTabDrag) {\n                this.handleCustomTabDrag(dropInfo, pos, event);\n            } else {\n                this.dropInfo = dropInfo;\n                this.outlineDiv!.className = this.getClassName(dropInfo.className);\n                dropInfo.rect.positionElement(this.outlineDiv!);\n                this.outlineDiv!.style.visibility = \"visible\";\n            }\n        }\n    };\n\n    /** @internal */\n    onDragEnd = (event: Event) => {\n        const rootdiv = this.selfRef.current!;\n        rootdiv.removeChild(this.outlineDiv!);\n        rootdiv.removeChild(this.dragDiv!);\n        this.dragDiv = undefined;\n        this.hidePortal();\n\n        this.setState({ showEdges: false });\n        DragDrop.instance.hideGlass();\n\n        if (this.dropInfo) {\n            if (this.customDrop) {\n                this.newTabJson = undefined;\n\n                try {\n                    const { callback, dragging, over, x, y, location } = this.customDrop;\n                    callback(dragging, over, x, y, location);\n                    if (this.fnNewNodeDropped != null) {\n                        this.fnNewNodeDropped();\n                        this.fnNewNodeDropped = undefined;\n                    }\n                } catch (e) {\n                    console.error(e)\n                }\n            } else if (this.newTabJson !== undefined) {\n                const newNode = this.doAction(Actions.addNode(this.newTabJson, this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));\n\n                if (this.fnNewNodeDropped != null) {\n                    this.fnNewNodeDropped(newNode, event);\n                    this.fnNewNodeDropped = undefined;\n                }\n                this.newTabJson = undefined;\n            } else if (this.dragNode !== undefined) {\n                this.doAction(Actions.moveNode(this.dragNode.getId(), this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));\n            }\n        }\n        this.setState({ showHiddenBorder: DockLocation.CENTER });\n    };\n\n    /** @internal */\n    private handleCustomTabDrag(dropInfo: DropInfo, pos: { x: number; y: number; }, event: React.MouseEvent<Element, MouseEvent>) {\n        let invalidated = this.customDrop?.invalidated;\n        const currentCallback = this.customDrop?.callback;\n        this.customDrop = undefined;\n\n        const dragging = this.newTabJson || (this.dragNode instanceof TabNode ? this.dragNode : undefined);\n        if (dragging && (dropInfo.node instanceof TabSetNode || dropInfo.node instanceof BorderNode) && dropInfo.index === -1) {\n            const selected = dropInfo.node.getSelectedNode() as TabNode | undefined;\n            const tabRect = selected?.getRect();\n\n            if (selected && tabRect?.contains(pos.x, pos.y)) {\n                let customDrop: ICustomDropDestination | undefined = undefined;\n\n                try {\n                    const dest = this.onTabDrag(dragging, selected, pos.x - tabRect.x, pos.y - tabRect.y, dropInfo.location, () => this.onDragMove(event));\n\n                    if (dest) {\n                        customDrop = {\n                            rect: new Rect(dest.x + tabRect.x, dest.y + tabRect.y, dest.width, dest.height),\n                            callback: dest.callback,\n                            invalidated: dest.invalidated,\n                            dragging: dragging,\n                            over: selected,\n                            x: pos.x - tabRect.x,\n                            y: pos.y - tabRect.y,\n                            location: dropInfo.location,\n                            cursor: dest.cursor\n                        };\n                    }\n                } catch (e) {\n                    console.error(e);\n                }\n\n                if (customDrop?.callback === currentCallback) {\n                    invalidated = undefined;\n                }\n\n                this.customDrop = customDrop;\n            }\n        }\n\n        this.dropInfo = dropInfo;\n        this.outlineDiv!.className = this.getClassName(this.customDrop ? CLASSES.FLEXLAYOUT__OUTLINE_RECT : dropInfo.className);\n\n        if (this.customDrop) {\n            this.customDrop.rect.positionElement(this.outlineDiv!);\n        } else {\n            dropInfo.rect.positionElement(this.outlineDiv!);\n        }\n\n        DragDrop.instance.setGlassCursorOverride(this.customDrop?.cursor);\n        this.outlineDiv!.style.visibility = \"visible\";\n\n        try {\n            invalidated?.();\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    /** @internal */\n    onDragEnter(event: React.DragEvent<HTMLDivElement>) {\n        // DragDrop keeps track of number of dragenters minus the number of\n        // dragleaves. Only start a new drag if there isn't one already.\n        if (DragDrop.instance.isDragging())\n            return;\n        const drag = this.props.onExternalDrag!(event);\n        if (drag) {\n            // Mimic addTabWithDragAndDrop, but pass in DragEvent\n            this.fnNewNodeDropped = drag.onDrop;\n            this.newTabJson = drag.json;\n            this.dragStart(event, drag.dragText, TabNode._fromJson(drag.json, this.props.model, false), true, undefined, undefined);\n        }\n    }\n\n\n    /** @internal */\n    checkForBorderToShow(x: number, y: number) {\n        const r = this.props.model._getOuterInnerRects().outer;\n        const c = r.getCenter();\n        const margin = this.edgeRectWidth;\n        const offset = this.edgeRectLength / 2;\n\n        let overEdge = false;\n        if (this.props.model.isEnableEdgeDock() && this.state.showHiddenBorder === DockLocation.CENTER) {\n            if ((y > c.y - offset && y < c.y + offset) ||\n                (x > c.x - offset && x < c.x + offset)) {\n                overEdge = true;\n            }\n        }\n\n        let location = DockLocation.CENTER;\n        if (!overEdge) {\n            if (x <= r.x + margin) {\n                location = DockLocation.LEFT;\n            } else if (x >= r.getRight() - margin) {\n                location = DockLocation.RIGHT;\n            } else if (y <= r.y + margin) {\n                location = DockLocation.TOP;\n            } else if (y >= r.getBottom() - margin) {\n                location = DockLocation.BOTTOM;\n            }\n        }\n\n        if (location !== this.state.showHiddenBorder) {\n            this.setState({ showHiddenBorder: location });\n        }\n    }\n\n    /** @internal */\n    maximize(tabsetNode: TabSetNode) {\n        this.doAction(Actions.maximizeToggle(tabsetNode.getId()));\n    }\n\n    /** @internal */\n    customizeTab(\n        tabNode: TabNode,\n        renderValues: ITabRenderValues,\n    ) {\n        if (this.props.onRenderTab) {\n            this.props.onRenderTab(tabNode, renderValues);\n        }\n    }\n\n    /** @internal */\n    customizeTabSet(\n        tabSetNode: TabSetNode | BorderNode,\n        renderValues: ITabSetRenderValues,\n    ) {\n        if (this.props.onRenderTabSet) {\n            this.props.onRenderTabSet(tabSetNode, renderValues);\n        }\n    }\n\n    /** @internal */\n    i18nName(id: I18nLabel, param?: string) {\n        let message;\n        if (this.props.i18nMapper) {\n            message = this.props.i18nMapper(id, param);\n        }\n        if (message === undefined) {\n            message = id + (param === undefined ? \"\" : param);\n        }\n        return message;\n    }\n\n    /** @internal */\n    getOnRenderFloatingTabPlaceholder() {\n        return this.props.onRenderFloatingTabPlaceholder;\n    }\n\n    /** @internal */\n    getShowOverflowMenu() {\n        return this.props.onShowOverflowMenu;\n    }\n\n    /** @internal */\n    getTabSetPlaceHolderCallback() {\n        return this.props.onTabSetPlaceHolder;\n    }\n    /** @internal */\n    showContextMenu(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) {\n        if (this.props.onContextMenu) {\n            this.props.onContextMenu(node, event);\n        }\n    }\n\n    /** @internal */\n    auxMouseClick(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) {\n        if (this.props.onAuxMouseClick) {\n            this.props.onAuxMouseClick(node, event);\n        }\n    }\n}\n\n// wrapper round the drag rect renderer that can call\n// a method once the rendering is written to the dom\n\n/** @internal */\ninterface IDragRectRenderWrapper {\n    onRendered?: () => void;\n    children: React.ReactNode;\n}\n\n/** @internal */\nconst DragRectRenderWrapper = (props: IDragRectRenderWrapper) => {\n    React.useEffect(() => {\n        props.onRendered?.();\n    }, [props]);\n\n    return (<React.Fragment>\n        {props.children}\n    </React.Fragment>)\n}\n","import { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { BorderNode } from \"./BorderNode\";\nimport { IDraggable } from \"./IDraggable\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\n\nexport class BorderSet {\n    /** @internal */\n    static _fromJson(json: any, model: Model) {\n        const borderSet = new BorderSet(model);\n        borderSet._borders = json.map((borderJson: any) => BorderNode._fromJson(borderJson, model));\n        return borderSet;\n    }\n    /** @internal */\n    private _model: Model;\n    /** @internal */\n    private _borders: BorderNode[];\n\n    /** @internal */\n    constructor(model: Model) {\n        this._model = model;\n        this._borders = [];\n    }\n\n    getBorders() {\n        return this._borders;\n    }\n\n    /** @internal */\n    _forEachNode(fn: (node: Node, level: number) => void) {\n        for (const borderNode of this._borders) {\n            fn(borderNode, 0);\n            for (const node of borderNode.getChildren()) {\n                node._forEachNode(fn, 1);\n            }\n        }\n    }\n\n    /** @internal */\n    _toJson() {\n        return this._borders.map((borderNode) => borderNode.toJson());\n    }\n\n    /** @internal */\n    _layoutBorder(outerInnerRects: { inner: Rect; outer: Rect }, metrics: ILayoutMetrics) {\n        const rect = outerInnerRects.outer;\n        const rootRow = this._model.getRoot();\n        let height = Math.max(0, rect.height - rootRow.getMinHeight());\n        let width = Math.max(0, rect.width - rootRow.getMinWidth());\n        let sumHeight = 0;\n        let sumWidth = 0;\n        let adjustableHeight = 0;\n        let adjustableWidth = 0;\n\n        const showingBorders = this._borders.filter((border) => border.isShowing());\n\n        // sum size of borders to see they will fit\n        for (const border of showingBorders) {\n            border._setAdjustedSize(border.getSize());\n            const visible = border.getSelected() !== -1;\n            if (border.getLocation().getOrientation() === Orientation.HORZ) {\n                sumWidth += border.getBorderBarSize();\n                if (visible) {\n                    width -= this._model.getSplitterSize();\n                    sumWidth += border.getSize();\n                    adjustableWidth += border.getSize();\n                }\n            } else {\n                sumHeight += border.getBorderBarSize();\n                if (visible) {\n                    height -= this._model.getSplitterSize();\n                    sumHeight += border.getSize();\n                    adjustableHeight += border.getSize();\n                }\n            }\n        }\n\n        // adjust border sizes if too large\n        let j = 0;\n        let adjusted = false;\n        while ((sumWidth > width && adjustableWidth > 0) || (sumHeight > height && adjustableHeight > 0)) {\n            const border = showingBorders[j];\n            if (border.getSelected() !== -1) {\n                // visible\n                const size = border._getAdjustedSize();\n                if (sumWidth > width && adjustableWidth > 0 && border.getLocation().getOrientation() === Orientation.HORZ && size > 0\n                    && size > border.getMinSize()) {\n                    border._setAdjustedSize(size - 1);\n                    sumWidth--;\n                    adjustableWidth--;\n                    adjusted = true;\n                } else if (sumHeight > height && adjustableHeight > 0 && border.getLocation().getOrientation() === Orientation.VERT && size > 0\n                    && size > border.getMinSize()) {\n                    border._setAdjustedSize(size - 1);\n                    sumHeight--;\n                    adjustableHeight--;\n                    adjusted = true;\n                }\n            }\n            j = (j + 1) % showingBorders.length;\n            if (j === 0) {\n                if (adjusted) {\n                    adjusted = false;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        for (const border of showingBorders) {\n            outerInnerRects.outer = border._layoutBorderOuter(outerInnerRects.outer, metrics);\n        }\n\n        outerInnerRects.inner = outerInnerRects.outer;\n\n        for (const border of showingBorders) {\n            outerInnerRects.inner = border._layoutBorderInner(outerInnerRects.inner, metrics);\n        }\n        return outerInnerRects;\n    }\n\n    /** @internal */\n    _findDropTargetNode(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        for (const border of this._borders) {\n            if (border.isShowing()) {\n                const dropInfo = border.canDrop(dragNode, x, y);\n                if (dropInfo !== undefined) {\n                    return dropInfo;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n","import { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { Action } from \"./Action\";\nimport { Actions } from \"./Actions\";\nimport { BorderNode } from \"./BorderNode\";\nimport { BorderSet } from \"./BorderSet\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IDropTarget } from \"./IDropTarget\";\nimport { IJsonModel, ITabSetAttributes } from \"./IJsonModel\";\nimport { Node } from \"./Node\";\nimport { RowNode } from \"./RowNode\";\nimport { TabNode } from \"./TabNode\";\nimport { TabSetNode } from \"./TabSetNode\";\nimport { adjustSelectedIndexAfterDock, adjustSelectedIndexAfterFloat, randomUUID } from \"./Utils\";\n\n/** @internal */\nexport interface ILayoutMetrics {\n    headerBarSize: number;\n    tabBarSize: number;\n    borderBarSize: number;\n}\n\n/**\n * Class containing the Tree of Nodes used by the FlexLayout component\n */\nexport class Model {\n    /**\n     * Loads the model from the given json object\n     * @param json the json model to load\n     * @returns {Model} a new Model object\n     */\n    static fromJson(json: IJsonModel) {\n        const model = new Model();\n        Model._attributeDefinitions.fromJson(json.global, model._attributes);\n\n        if (json.borders) {\n            model._borders = BorderSet._fromJson(json.borders, model);\n        }\n        model._root = RowNode._fromJson(json.layout, model);\n        model._tidy(); // initial tidy of node tree\n        return model;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = Model._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n\n        attributeDefinitions.add(\"legacyOverflowMenu\", false).setType(Attribute.BOOLEAN);\n\n        // splitter\n        attributeDefinitions.add(\"splitterSize\", -1).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"splitterExtra\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"enableEdgeDock\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"rootOrientationVertical\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"marginInsets\", { top: 0, right: 0, bottom: 0, left: 0 })\n            .setType(\"IInsets\");\n        attributeDefinitions.add(\"enableUseVisibility\", false).setType(Attribute.BOOLEAN);\n\n        // tab\n        attributeDefinitions.add(\"tabEnableClose\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabCloseType\", 1).setType(\"ICloseType\");\n        attributeDefinitions.add(\"tabEnableFloat\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabEnableDrag\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabEnableRename\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabClassName\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabIcon\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabEnableRenderOnDemand\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabDragSpeed\", 0.3).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabBorderWidth\", -1).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabBorderHeight\", -1).setType(Attribute.NUMBER);\n\n        // tabset\n        attributeDefinitions.add(\"tabSetEnableDeleteWhenEmpty\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDrop\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDrag\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDivide\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableMaximize\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableClose\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetAutoSelectTab\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetClassNameTabStrip\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabSetClassNameHeader\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabSetEnableTabStrip\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetHeaderHeight\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetTabStripHeight\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMarginInsets\", { top: 0, right: 0, bottom: 0, left: 0 })\n            .setType(\"IInsets\");\n        attributeDefinitions.add(\"tabSetBorderInsets\", { top: 0, right: 0, bottom: 0, left: 0 })\n            .setType(\"IInsets\");\n        attributeDefinitions.add(\"tabSetTabLocation\", \"top\").setType(\"ITabLocation\");\n        attributeDefinitions.add(\"tabSetMinWidth\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMinHeight\", 0).setType(Attribute.NUMBER);\n\n        // border\n        attributeDefinitions.add(\"borderSize\", 200).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"borderMinSize\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"borderBarSize\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"borderEnableDrop\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderAutoSelectTabWhenOpen\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderAutoSelectTabWhenClosed\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderClassName\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"borderEnableAutoHide\", false).setType(Attribute.BOOLEAN);\n\n        return attributeDefinitions;\n    }\n\n    /** @internal */\n    private _attributes: Record<string, any>;\n    /** @internal */\n    private _idMap: Record<string, Node>;\n    /** @internal */\n    private _changeListener?: (action: Action) => void;\n    /** @internal */\n    private _root?: RowNode;\n    /** @internal */\n    private _borders: BorderSet;\n    /** @internal */\n    private _onAllowDrop?: (dragNode: Node, dropInfo: DropInfo) => boolean;\n    /** @internal */\n    private _maximizedTabSet?: TabSetNode;\n    /** @internal */\n    private _activeTabSet?: TabSetNode;\n    /** @internal */\n    private _borderRects: { inner: Rect; outer: Rect } = { inner: Rect.empty(), outer: Rect.empty() };\n    /** @internal */\n    private _pointerFine: boolean;\n    /** @internal */\n    private _onCreateTabSet?: (tabNode?: TabNode) => ITabSetAttributes;\n    /** @internal */\n    private _showHiddenBorder: DockLocation;\n\n\n    /**\n     * 'private' constructor. Use the static method Model.fromJson(json) to create a model\n     *  @internal\n     */\n\n    private constructor() {\n        this._attributes = {};\n        this._idMap = {};\n        this._borders = new BorderSet(this);\n        this._pointerFine = true;\n        this._showHiddenBorder = DockLocation.CENTER;\n    }\n\n    /** @internal */\n    _setChangeListener(listener: ((action: Action) => void) | undefined) {\n        this._changeListener = listener;\n    }\n\n    /**\n     * Get the currently active tabset node\n     */\n    getActiveTabset() {\n        if (this._activeTabSet && this.getNodeById(this._activeTabSet.getId())) {\n            return this._activeTabSet;\n        } else {\n            return undefined;\n        }\n    }\n\n    /** @internal */\n    _getShowHiddenBorder() {\n        return this._showHiddenBorder;\n    }\n\n    /** @internal */\n    _setShowHiddenBorder(location: DockLocation) {\n        this._showHiddenBorder = location;\n    }\n\n    /** @internal */\n    _setActiveTabset(tabsetNode: TabSetNode | undefined) {\n        this._activeTabSet = tabsetNode;\n    }\n\n    /**\n     * Get the currently maximized tabset node\n     */\n    getMaximizedTabset() {\n        return this._maximizedTabSet;\n    }\n\n    /** @internal */\n    _setMaximizedTabset(tabsetNode: (TabSetNode | undefined)) {\n        this._maximizedTabSet = tabsetNode;\n    }\n\n    /**\n     * Gets the root RowNode of the model\n     * @returns {RowNode}\n     */\n    getRoot() {\n        return this._root as RowNode;\n    }\n\n    isRootOrientationVertical() {\n        return this._attributes.rootOrientationVertical as boolean;\n    }\n\n    isUseVisibility() {\n        return this._attributes.enableUseVisibility as boolean;\n    }\n\n    /**\n     * Gets the\n     * @returns {BorderSet|*}\n     */\n    getBorderSet() {\n        return this._borders;\n    }\n\n    /** @internal */\n    _getOuterInnerRects() {\n        return this._borderRects;\n    }\n\n    /** @internal */\n    _getPointerFine() {\n        return this._pointerFine;\n    }\n\n    /** @internal */\n    _setPointerFine(pointerFine: boolean) {\n        this._pointerFine = pointerFine;\n    }\n\n    /**\n     * Visits all the nodes in the model and calls the given function for each\n     * @param fn a function that takes visited node and a integer level as parameters\n     */\n    visitNodes(fn: (node: Node, level: number) => void) {\n        this._borders._forEachNode(fn);\n        (this._root as RowNode)._forEachNode(fn, 0);\n    }\n\n    /**\n     * Gets a node by its id\n     * @param id the id to find\n     */\n    getNodeById(id: string): Node | undefined {\n        return this._idMap[id];\n    }\n\n    /**\n     * Update the node tree by performing the given action,\n     * Actions should be generated via static methods on the Actions class\n     * @param action the action to perform\n     * @returns added Node for Actions.addNode; undefined otherwise\n     */\n    doAction(action: Action): Node | undefined {\n        let returnVal = undefined;\n        // console.log(action);\n        switch (action.type) {\n            case Actions.ADD_NODE: {\n                const newNode = new TabNode(this, action.data.json, true);\n                const toNode = this._idMap[action.data.toNode] as Node & IDraggable;\n                if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {\n                    toNode.drop(newNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n                    returnVal = newNode;\n                }\n                break;\n            }\n            case Actions.MOVE_NODE: {\n                const fromNode = this._idMap[action.data.fromNode] as Node & IDraggable;\n                if (fromNode instanceof TabNode || fromNode instanceof TabSetNode) {\n                    const toNode = this._idMap[action.data.toNode] as Node & IDropTarget;\n                    if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {\n                        toNode.drop(fromNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n                    }\n                }\n                break;\n            }\n            case Actions.DELETE_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._delete();\n                }\n                break;\n            }\n            case Actions.DELETE_TABSET: {\n                const node = this._idMap[action.data.node];\n\n                if (node instanceof TabSetNode) {\n                    // first delete all child tabs that are closeable\n                    const children = [...node.getChildren()];\n                    for (let i = 0; i < children.length; i++) {\n                        const child = children[i];\n                        if ((child as TabNode).isEnableClose()) {\n                            (child as TabNode)._delete();\n                        }\n                    }\n\n                    if (node.getChildren().length === 0) {\n                        node._delete();\n                    }\n                    this._tidy();\n                }\n                break;\n            }\n            case Actions.FLOAT_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._setFloating(true);\n                    adjustSelectedIndexAfterFloat(node);\n                }\n                break;\n            }\n            case Actions.UNFLOAT_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._setFloating(false);\n                    adjustSelectedIndexAfterDock(node);\n                }\n                break;\n            }\n            case Actions.RENAME_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._setName(action.data.text);\n                }\n                break;\n            }\n            case Actions.SELECT_TAB: {\n                const tabNode = this._idMap[action.data.tabNode];\n                if (tabNode instanceof TabNode) {\n                    const parent = tabNode.getParent() as Node;\n                    const pos = parent.getChildren().indexOf(tabNode);\n\n                    if (parent instanceof BorderNode) {\n                        if (parent.getSelected() === pos) {\n                            parent._setSelected(-1);\n                        } else {\n                            parent._setSelected(pos);\n                        }\n                    } else if (parent instanceof TabSetNode) {\n                        if (parent.getSelected() !== pos) {\n                            parent._setSelected(pos);\n                        }\n                        this._activeTabSet = parent;\n                    }\n                }\n                break;\n            }\n            case Actions.SET_ACTIVE_TABSET: {\n                const tabsetNode = this._idMap[action.data.tabsetNode];\n                if (tabsetNode instanceof TabSetNode) {\n                    this._activeTabSet = tabsetNode;\n                }\n                break;\n            }\n            case Actions.ADJUST_SPLIT: {\n                const node1 = this._idMap[action.data.node1];\n                const node2 = this._idMap[action.data.node2];\n\n                if ((node1 instanceof TabSetNode || node1 instanceof RowNode) && (node2 instanceof TabSetNode || node2 instanceof RowNode)) {\n                    this._adjustSplitSide(node1, action.data.weight1, action.data.pixelWidth1);\n                    this._adjustSplitSide(node2, action.data.weight2, action.data.pixelWidth2);\n                }\n                break;\n            }\n            case Actions.ADJUST_BORDER_SPLIT: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof BorderNode) {\n                    node._setSize(action.data.pos);\n                }\n                break;\n            }\n            case Actions.MAXIMIZE_TOGGLE: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabSetNode) {\n                    if (node === this._maximizedTabSet) {\n                        this._maximizedTabSet = undefined;\n                    } else {\n                        this._maximizedTabSet = node;\n                        this._activeTabSet = node;\n                    }\n                }\n\n                break;\n            }\n            case Actions.UPDATE_MODEL_ATTRIBUTES: {\n                this._updateAttrs(action.data.json);\n                break;\n            }\n\n            case Actions.UPDATE_NODE_ATTRIBUTES: {\n                const node = this._idMap[action.data.node];\n                node._updateAttrs(action.data.json);\n                break;\n            }\n            default:\n                break;\n        }\n\n        this._updateIdMap();\n\n        if (this._changeListener !== undefined) {\n            this._changeListener(action);\n        }\n\n        return returnVal;\n    }\n\n    /** @internal */\n    _updateIdMap() {\n        // regenerate idMap to stop it building up\n        this._idMap = {};\n        this.visitNodes((node) => (this._idMap[node.getId()] = node));\n        // console.log(JSON.stringify(Object.keys(this._idMap)));\n    }\n\n    /** @internal */\n    _adjustSplitSide(node: TabSetNode | RowNode, weight: number, pixels: number) {\n        node._setWeight(weight);\n        if (node.getWidth() != null && node.getOrientation() === Orientation.VERT) {\n            node._updateAttrs({ width: pixels });\n        } else if (node.getHeight() != null && node.getOrientation() === Orientation.HORZ) {\n            node._updateAttrs({ height: pixels });\n        }\n    }\n\n    /**\n     * Converts the model to a json object\n     * @returns {IJsonModel} json object that represents this model\n     */\n    toJson(): IJsonModel {\n        const global: any = {};\n        Model._attributeDefinitions.toJson(global, this._attributes);\n\n        // save state of nodes\n        this.visitNodes((node) => {\n            node._fireEvent(\"save\", undefined);\n        });\n\n        return { global, borders: this._borders._toJson(), layout: (this._root as RowNode).toJson() };\n    }\n\n    getSplitterSize() {\n        let splitterSize = this._attributes.splitterSize as number;\n        if (splitterSize === -1) {\n            // use defaults\n            splitterSize = this._pointerFine ? 8 : 12; // larger for mobile\n        }\n        return splitterSize;\n    }\n\n    isLegacyOverflowMenu() {\n        return this._attributes.legacyOverflowMenu as boolean;\n    }\n\n    getSplitterExtra() {\n        return this._attributes.splitterExtra as number;\n    }\n\n    isEnableEdgeDock() {\n        return this._attributes.enableEdgeDock as boolean;\n    }\n\n    /** @internal */\n    _addNode(node: Node) {\n        const id = node.getId();\n        if (this._idMap[id] !== undefined) {\n            throw new Error(`Error: each node must have a unique id, duplicate id:${node.getId()}`);\n        }\n\n        if (node.getType() !== \"splitter\") {\n            this._idMap[id] = node;\n        }\n    }\n\n    /** @internal */\n    _layout(rect: Rect, metrics: ILayoutMetrics) {\n        // let start = Date.now();\n        this._borderRects = this._borders._layoutBorder({ outer: rect, inner: rect }, metrics);\n        rect = this._borderRects.inner.removeInsets(this._getAttribute(\"marginInsets\"));\n\n        this._root?.calcMinSize();\n        (this._root as RowNode)._layout(rect, metrics);\n        // console.log(\"layout time: \" + (Date.now() - start));\n        return rect;\n    }\n\n    /** @internal */\n    _findDropTargetNode(dragNode: Node & IDraggable, x: number, y: number) {\n        let node = (this._root as RowNode)._findDropTargetNode(dragNode, x, y);\n        if (node === undefined) {\n            node = this._borders._findDropTargetNode(dragNode, x, y);\n        }\n        return node;\n    }\n\n    /** @internal */\n    _tidy() {\n        // console.log(\"before _tidy\", this.toString());\n        (this._root as RowNode)._tidy();\n        // console.log(\"after _tidy\", this.toString());\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        Model._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    _nextUniqueId() {\n        return '#' + randomUUID();\n    }\n\n    /** @internal */\n    _getAttribute(name: string): any {\n        return this._attributes[name];\n    }\n\n    /**\n     * Sets a function to allow/deny dropping a node\n     * @param onAllowDrop function that takes the drag node and DropInfo and returns true if the drop is allowed\n     */\n    setOnAllowDrop(onAllowDrop: (dragNode: Node, dropInfo: DropInfo) => boolean) {\n        this._onAllowDrop = onAllowDrop;\n    }\n\n    /** @internal */\n    _getOnAllowDrop() {\n        return this._onAllowDrop;\n    }\n\n    /**\n     * set callback called when a new TabSet is created.\n     * The tabNode can be undefined if it's the auto created first tabset in the root row (when the last\n     * tab is deleted, the root tabset can be recreated)\n     * @param onCreateTabSet \n     */\n    setOnCreateTabSet(onCreateTabSet: (tabNode?: TabNode) => ITabSetAttributes) {\n        this._onCreateTabSet = onCreateTabSet;\n    }\n\n    /** @internal */\n    _getOnCreateTabSet() {\n        return this._onCreateTabSet;\n    }\n\n    static toTypescriptInterfaces() {\n        console.log(Model._attributeDefinitions.toTypescriptInterface(\"Global\", undefined));\n        console.log(RowNode.getAttributeDefinitions().toTypescriptInterface(\"Row\", Model._attributeDefinitions));\n        console.log(TabSetNode.getAttributeDefinitions().toTypescriptInterface(\"TabSet\", Model._attributeDefinitions));\n        console.log(TabNode.getAttributeDefinitions().toTypescriptInterface(\"Tab\", Model._attributeDefinitions));\n        console.log(BorderNode.getAttributeDefinitions().toTypescriptInterface(\"Border\", Model._attributeDefinitions));\n    }\n\n    toString() {\n        return JSON.stringify(this.toJson());\n    }\n}\n\n","import { IBorderLocation } from \".\";\n\nexport default {\n  global: {\n    // https://github.com/caplin/FlexLayout#global-config-attributes\n    enableEdgeDock: false,\n\n    splitterSize: 5,\n\n    tabEnableClose: false,\n    tabEnableRename: false,\n    tabEnableFloat: false,\n    tabEnableRenderOnDemand: true,\n    tabEnableDrag: false,\n\n    tabSetEnableClose: false,\n    tabSetEnableMaximize: false,\n    tabSetEnableDrop: false,\n  },\n  borders: [\n    {\n      type: \"border\",\n      location: \"right\" as IBorderLocation,\n      size: 320,\n      barSize: -1, // Hide border tabset header\n      // selected: 0, // Open\n      children: [\n        {\n            type: \"tab\",\n            id: 'library',\n            name: \"Library\",\n            component: '',\n        },\n        {\n          type: \"tab\",\n          id: 'support',\n          name: \"Support\",\n          component: '',\n        },\n      ]\n    },\n  ],\n  layout: {\n    type: 'row',\n    weight: 100,\n    children: [\n      // {\n      //   type: 'row',\n      //   weight: 25,\n      //   children: [\n      //     {\n      //       type: 'tabset',\n      //       weight: 80,\n      //       children: [\n      //         {\n      //             type: \"tab\",\n      //             name: \"Overview\",\n      //             component: \"grid\",\n      //         },\n      //       ]\n      //     }\n      //   ]\n      // },\n      {\n        type: 'tabset',\n        weight: 80,\n        children: [\n          {\n            type: 'tab',\n            name: 'Template',\n            component: 'editor',\n          },\n          {\n            type: 'tab',\n            name: 'Style',\n            component: 'editor',\n          },\n          {\n            type: 'tab',\n            name: 'Script',\n            component: 'editor',\n          },\n        ]\n      },\n\n      {\n        type: 'row',\n        weight: 50,\n        children: [\n          {\n            type: 'tabset',\n            weight: 100,\n            children: [\n              {\n                type: 'tab',\n                name: 'Preview',\n                component: 'preview',\n                enableClose: false,\n                enableRename: false,\n                enableFloat: false\n              },\n              {\n                type: 'tab',\n                name: 'Controls',\n                component: 'editor',\n              },\n              {\n                type: 'tab',\n                name: 'Assets',\n                component: 'assets',\n              },\n              {\n                type: 'tab',\n                name: 'Location',\n                component: 'location',\n              },\n            ]\n          },\n          // {\n          //   type: 'tabset',\n          //   weight: 100,\n          //   children: [\n          //   ]\n          // },    \n        ]\n      }\n    ]\n  }\n}\n","import * as React from 'react'\nimport { memo, useEffect, useRef } from 'react'\n\nexport const typeToLang = {\n  template: 'html',\n  style: 'sass',\n  script: 'javascript',\n  control: 'html',\n}\n\nexport const editorByType = {}\n\nexport const Editor = memo(({ type, node, content, focusOnMount = false }) => {\n\n  const ref = useRef()\n\n  useEffect(() => {\n\n    ;(async () => {\n\n      const { CodeEditor } = window?.Tangible?.TemplateSystem\n\n      // console.log('Mount editor', type, ref)\n      const el = ref.current\n      // Set container to flex so the editor can fill height 100%\n      el.style = 'display: flex; flex-direction: column; height: 100%;'\n  \n      const editor = await CodeEditor.create({\n        el,\n        lang: typeToLang[ type ] || 'html',\n        content\n      })\n  \n      editorByType[type] = editor\n  \n      // Used to focus editor on tab select\n      editor.node = node\n  \n      if (focusOnMount) editor.view.focus()\n        \n    })().catch(console.error)\n\n  }, [ref])\n\n  return <div ref={ref}></div>\n})\n\n","import * as React from 'react'\nimport { memo, useEffect, useRef } from 'react'\n// import { startPlaygroundWeb } from '@wp-playground/client'\n\nexport const Preview = memo(({ type, node, onPreviewerReady }) => {\n\n  const ref = useRef()\n\n  useEffect(() => {\n\n    const el = ref.current\n\n    console.log('Previewer mount', el)\n\n    return\n\n    const iframe = document.createElement('iframe')\n\n    iframe.width = '100%'\n    iframe.height = iframe.height || '480px'\n    iframe.style = 'border: none'\n    el.append(iframe)  \n\n    const server = \n      'https://playground.wordpress.net'\n      // 'http://localhost:3000'\n\n    console.log('iframe', iframe)\n    console.log('server', server)\n  \n    const blueprint = {\n      steps: [\n        { step: 'login', username: 'admin', password: 'password' },\n      ]\n    }\n\n    start({\n      iframe,\n      // server,\n      remoteUrl: `${server}/remote.html`,\n  \n      // blueprint: {\n      //   landingPage: '/',\n      //   preferredVersions: {\n      //     php: '8.0',\n      //     wp: '6.2'\n      //   },\n      //   // disableProgressBar: true,\n      //   ...blueprint\n      // }\n    })\n      .then(function() {\n        console.log('playground ready')\n      })\n      .catch(console.error)\n    \n  }, [])\n\n  return <div className='ide-component' ref={ref}></div>\n})\n\nasync function start(options) {\n  console.log('start', options)\n  const playground = await startPlaygroundWeb(options)\n\n  console.log('playground', playground)\n\n  await playground.isReady()\n  \n  return playground\n}\n\n","import * as React from 'react'\nimport { memo } from 'react'\n\nexport const Assets = memo(({ type, node }) => {\n  return <div className='ide-component'>\n    \n  </div>\n})\n","import * as React from 'react'\nimport { memo } from 'react'\n\nexport const Location = memo(({ type, node }) => {\n  return <div className='ide-component'>\n    \n  </div>\n})\n","import * as React from 'react'\nimport { memo } from 'react'\n\nexport const Library = memo(({ type, node }) => {\n  return <div className='ide-component'>\n\n    <h2>Local</h2>\n\n    <p>List of templates</p>\n\n    <h2>Cloud</h2>\n\n    <p>Catalog</p>\n\n  </div>\n})\n","import * as React from 'react'\nimport { memo } from 'react'\n\nexport const Support = memo(({ type, node }) => {\n  return <div className='ide-component'>\n\n  <h2>Keyboard Shortcuts</h2>\n\n  <p>Ctrl or CMD + SPACE - Autocomplete</p>\n\n  <h2>Language Reference</h2>\n\n  </div>\n})\n","import * as  React from 'react'\n\n// https://icon-sets.iconify.design/dashicons\n// https://github.com/WordPress/gutenberg/tree/trunk/packages/icons/src/library\n\nexport const IconFullScreenOpen = () => <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path fill=\"currentColor\" d=\"M7 2H2v5l1.8-1.8L6.5 8L8 6.5L5.2 3.8L7 2zm6 0l1.8 1.8L12 6.5L13.5 8l2.7-2.7L18 7V2h-5zm.5 10L12 13.5l2.7 2.7L13 18h5v-5l-1.8 1.8l-2.7-2.8zm-7 0l-2.7 2.7L2 13v5h5l-1.8-1.8L8 13.5L6.5 12z\"/></svg>\n\nexport const IconFullScreenClose = () => <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path fill=\"currentColor\" d=\"M3.4 2L2 3.4l2.8 2.8L3 8h5V3L6.2 4.8L3.4 2zm11.8 4.2L18 3.4L16.6 2l-2.8 2.8L12 3v5h5l-1.8-1.8zM4.8 13.8L2 16.6L3.4 18l2.8-2.8L8 17v-5H3l1.8 1.8zM17 12h-5v5l1.8-1.8l2.8 2.8l1.4-1.4l-2.8-2.8L17 12z\"/></svg>\n","import * as React from 'react'\nimport { useState, useMemo } from 'react'\nimport * as Layout from '../Layout'\nimport { IconFullScreenOpen, IconFullScreenClose } from '../icons'\n\nenum ScreenSize {\n  Default,\n  Full,\n  FullScreen\n}\n\n// See ./index.scss\nconst fullScreenClassName = 'tangible-template-system-ide-expanded'\n\nfunction updateFullScreenClass(isFullScreen: boolean) {\n  const $html = document.documentElement\n  if (isFullScreen) {\n    $html.classList.add(fullScreenClassName)\n  } else {\n    $html.classList.remove(fullScreenClassName)\n  }\n}\n\nexport function Header({\n  layoutModel,\n  ideElement\n}) {\n\n  const [screenSize, _setScreenSize] = useState(ScreenSize.Default)\n  const setScreenSize = useMemo(() => function(size) {\n\n    function update() {\n      updateFullScreenClass(\n        size===ScreenSize.Full || size===ScreenSize.FullScreen\n      )\n      _setScreenSize(size)\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullscreen\n    if (size===ScreenSize.FullScreen) {\n      if (!document.fullscreenElement) {\n        ideElement.requestFullscreen()\n          .then(update)\n          .catch(e => {\n            // Refused\n          })\n          return\n      }\n    } else if (document.fullscreenElement) {\n      document.exitFullscreen()\n    }\n\n    update()\n\n  }, [_setScreenSize])\n\n  return <div className='ide-header'>\n    <div className=\"ide-header--title\">\n      <input type=\"text\" value=\"Template name\" />\n    </div>\n    <div className=\"ide-header--actions\">\n\n      <button className='ide-header--action'>Save</button>\n      <button className='ide-header--action'\n      >Format</button>\n      <button className='ide-header--action'\n      >Export</button>\n      {/* <button className='ide-header--action'\n      >Import</button> */}\n\n      <div className='ide-header--action-separator'></div>\n\n      <button className='ide-header--action'\n        onClick={() => {\n          layoutModel.doAction(Layout.Actions.selectTab('library'))\n        }}\n      >Library</button>\n      <button className='ide-header--action'\n        onClick={() => {\n          layoutModel.doAction(Layout.Actions.selectTab('support'))\n        }}\n      >Support</button>\n\n      { screenSize===ScreenSize.FullScreen\n        ? <button className='ide-header--action ide-header--action-with-icon'\n          onClick={() => setScreenSize(ScreenSize.Default) }\n        ><IconFullScreenClose /></button>\n        : <>\n          { screenSize===ScreenSize.Full &&\n            <button className='ide-header--action ide-header--action-with-icon'\n            onClick={() => setScreenSize( ScreenSize.FullScreen ) }\n            alt='Full Screen'\n            ><IconFullScreenOpen /></button>\n          }\n          { screenSize===ScreenSize.Default &&\n            <button className='ide-header--action ide-header--action-with-icon'\n              onClick={() => setScreenSize( ScreenSize.Full ) }\n              alt='Expand'\n            ><IconFullScreenOpen /></button>\n        }\n        { screenSize===ScreenSize.Full &&\n          <button className='ide-header--action ide-header--action-with-icon'\n            onClick={() => setScreenSize( ScreenSize.Default )}\n            alt='Shrink'\n          ><IconFullScreenClose /></button>\n        }\n        </>\n      }\n\n    </div>\n  </div>\n}\n","import * as React from 'react'\nimport { createRoot, memo, useRef, useEffect } from 'react'\nimport * as Layout from './Layout'\nimport layoutModelData from './Layout/model'\n\nimport { Editor, editorByType, typeToLang } from './Editor'\nimport { Preview } from './Preview'\n\nimport { Assets } from './Assets'\nimport { Location } from './Location'\n\nimport { Library } from './Library'\nimport { Support } from './Support'\n\nimport { Header } from './Header'\n\n\nconst { jQuery } = window\n\njQuery(document).ready(function ($) {\n\n  const { CodeEditor } = window?.Tangible?.TemplateSystem\n\n  let ideElement = document.getElementById('tangible-template-system-ide')\n  \n  if (!ideElement) {\n    ideElement = document.createElement('div')\n    ideElement.id = 'tangible-template-system-ide'\n    document.body.prepend(ideElement) // Prepend for absolute screen position    \n  }\n\n\n  const root = createRoot(ideElement)\n\n  const templatePost = {\n    // content, style, script, controls, ..\n  }\n\n  const layoutModel = Layout.Model.fromJson(layoutModelData)\n\n  let selectedTabNodeId = ''\n\n  const layoutComponents = {\n    Library,\n    Support,\n\n    Editor,\n    Preview,\n    Assets,\n    Location,\n  }\n\n\n  const componentByNodeId = {\n    // [nodeId]: { name, node }\n  }\n\n\n  const getNodeId = node => node._getAttr('id') // TODO: Make this public\n\n  const componentFactory = (node: Layout.TabNode) => {\n\n    const component = node.getComponent()\n    // const config = node.getConfig()\n\n    const nodeId = getNodeId(node)\n    const title = node.getName()\n    const slug = title.toLowerCase()\n\n    componentByNodeId[ nodeId ] = {\n      name: component,\n      node\n    }\n\n    // console.log('component', name, node)\n\n    if (component === 'editor') {\n      return <Editor\n        type={slug}\n        node={node}\n        content={\n          templatePost[ slug ] || ''\n        }\n        focusOnMount={ nodeId===selectedTabNodeId }\n      />\n    }\n\n    if (layoutComponents[title]) {\n      const LayoutComponent = layoutComponents[title]\n      return <LayoutComponent node={node} />\n    }\n  }\n\n  const onAction = (action: Layout.Action) => {\n\n    // console.log('onAction', action)\n\n    const { type, data } = action\n    \n    if (type==='FlexLayout_SelectTab' && data.tabNode) {\n\n      const nodeId = data.tabNode\n\n      selectedTabNodeId = nodeId\n\n      // Find component by node ID\n      // const component = componentByNodeId[ nodeId ]\n\n      // Find editor by node ID\n\n      for (const [type, editor] of Object.entries(editorByType)) {\n\n        if (getNodeId(editor.node) === nodeId) {\n\n          // Focus editor on next render, after tab is selected and focused\n\n          setTimeout(() => {\n            editor.view.focus()\n          })\n          break\n        }\n      }\n    }\n\n    return action\n  }\n\n  const onModelChange = (model: Layout.Model) => {\n    // console.log('onModelChange', model)\n  }\n\n  const tabsWithFormat = ['Template', 'Style', 'Script']\n\n  const tabsetMap = {\n\n  }\n  const tabMap = {\n    // name: { id }\n  }\n\n  const onRenderTabSet = (node, renderState) => {\n\n    const tabset = node._attributes || {}\n    // console.log('onRenderTabSet', tabset, node.getConfig())\n\n    // Show actions for current visible tab\n\n    for (const childNode of node.getChildren()) {\n\n      // On initial render of tabset, editors are not ready yet\n\n      const { id, name } = childNode._attributes || {}\n      const type = name.toLowerCase()\n      const lang = typeToLang[ type ]\n\n      tabMap[type] = { id, lang }\n\n      return\n\n      if (lang && childNode._visible) {\n\n        const { buttons } = renderState\n\n        buttons.push(<button\n          className='tab-action'\n          onClick={() => {\n            const editor = editorByType[ type ]\n            if (!editor) return\n            formatCode({\n              lang,\n              editor\n            })\n          }}\n        >Format</button>)\n      }\n\n      break\n    }\n  } \n\n  async function formatCode({\n    lang,\n    editor\n  }) {\n\n    // Note: Use editor.view.state, since editor.state.doc is empty or stale\n    const content = editor.view.state.doc.toString()\n\n    try {\n\n      const formattedCode = await CodeEditor.format({\n        lang,\n        content\n      })\n\n      const cursorPosition = !formattedCode\n        ? 0\n        : Math.min(\n          editor.view.state.selection.ranges[0].from,\n          formattedCode.length - 1\n        )\n\n      /**\n       * Replace content\n       */\n      editor.view.dispatch({\n        changes: {\n          from: 0,\n          to: content.length,\n          insert: formattedCode\n        },\n      })\n\n      editor.view.focus()\n\n      // Restore cursor\n      editor.view.dispatch({\n        selection: {\n          anchor: cursorPosition,\n          head: cursorPosition\n        },\n      })\n\n    } catch (error) {\n      // TODO: Map error to lint gutter\n      console.error(error)\n    }\n  }\n\n  root.render(<>\n    <Header layoutModel={layoutModel} ideElement={ideElement} />\n    <div className='ide-main'>\n      <Layout.Layout\n        model={layoutModel}\n        factory={componentFactory}\n        onAction={onAction}\n        onModelChange={onModelChange}\n        onRenderTabSet={onRenderTabSet}\n        // https://github.com/caplin/FlexLayout#optional-props\n        realtimeResize={true}\n        supportsPopout={false}\n      />\n    </div>\n  </>)\n\n})\n"],"names":["_Orientation","__name","from","name","Orientation","Rect","x","y","width","height","element","rect","position","style","insets","outerRect","orientation","prefSize","_DockLocation","bl","br","indexPlus","r","size","r1","r2","DockLocation","canUseDOM","_DragDrop","fCancel","_a","cursor","event","fDragStart","fDragMove","fDragEnd","fDragCancel","fClick","fDblClick","currentDocument","rootElement","posEvent","isDoubleClick","clickTime","DragDrop","Action","type","data","_Actions","json","toNodeId","location","index","select","fromNodeId","tabNodeId","tabsetNodeId","text","splitSpec","node1","node2","nodeId","pos","attributes","Actions","Attribute","modelName","defaultValue","alwaysWriteJson","value","AttributeDefinitions","attr","conversion","jsonObj","obj","fromValue","parentAttributes","lines","sorted","a","b","i","c","inherited","defValue","required","comment","DropInfo","node","className","CLASSES","Node","model","id","callback","params","val","fn","level","visible","parent","weight","metrics","dragNode","rtn","child","dropInfo","childNode","_SplitterNode","SplitterNode","_TabNode","addToModel","attributeDefinitions","altName","float","window","TabNode","_RowNode","newLayoutNode","jsonChild","TabSetNode","pixelSize","totalWeight","fixedPixels","prefPixels","totalPrefWeight","drawChildren","resizePreferred","availablePixels","totalSizeGiven","variableSize","minSize","changed","p","splitterNode","useMinSize","pBounds","minSize1","minSize2","splitter","splitterPos","weightedLength","pixelWidth1","pixelWidth2","weight1","weight2","newSplitter","first","childChildren","subchild","subChildrenTotal","subChildChildren","ssc","j","subsubChild","attrs","__spreadProps","__spreadValues","yy","xx","w","h","margin","half","dockLocation","outlineRect","BorderNode","tabSet","sum","horz","vrow","hrow","RowNode","_TabSetNode","selected","headerBarHeight","tabBarHeight","childCenter","showHeader","removedIndex","adjustSelectedIndex","dragParent","fromIndex","insertPos","parentRow","newRow","adjustSelectedIndexAfterFloat","found","newSelected","children","adjustSelectedIndexAfterDock","selectedIndex","randomUUID","_BorderNode","border","whenOpen","barSize","defaultSize","tabNode","tabBorderSize","outer","split1","inner","split2","childRect","childY","childHeight","childX","childWidth","innerRect","rootRow","I18nLabel","ICloseType","getRenderStateEx","layout","iconFactory","titleFactory","leadingContent","titleContent","isTitleObject","titleObj","renderState","hideElement","useVisibility","isAuxMouseEvent","auxEvent","React","t","o","E","n","e","l","k","_","F","m","s","D","f","S","B","N","U","T","H","g","A","L","v","O","u","d","showPopup","triggerElement","items","onSelect","layoutDiv","classNameMapper","triggerRect","layoutRect","elm","onHide","onElementMouseDown","onDocMouseDown","PopupMenu","props","onItemClick","item","itemElements","TabButtonStamp","z","useTabOverflow","Splitter","R","M","ErrorBoundary","Fragment","W","FloatingWindow","createPortal","TabFloating","path","showPopout","dockPopout","onMouseDown","onClickFocus","onClickDock","cm","parentNode","message","showMessage","dockMessage","customRenderCallback","CloseIcon","MaximizeIcon","OverflowIcon","PopoutIcon","RestoreIcon","G","Q","control","BorderSet","borderSet","borderJson","borderNode","outerInnerRects","sumHeight","sumWidth","adjustableHeight","adjustableWidth","showingBorders","adjusted","_Model","listener","tabsetNode","pointerFine","action","returnVal","newNode","toNode","fromNode","pixels","global","splitterSize","onAllowDrop","onCreateTabSet","Model","P","memo","useRef","useEffect","typeToLang","editorByType","IconFullScreenOpen","IconFullScreenClose","Header","useState","useMemo","r.Actions","createRoot","ideElement"],"mappings":"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"}