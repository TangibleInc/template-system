(function () {
    'use strict';

    (function() {
        const env = {"NODE_ENV":"development"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    var __defProp$B = Object.defineProperty;
    var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$B(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$B = (target, value) => __defProp$B(target, "name", { value, configurable: true });
    var __publicField$h = (obj, key, value) => {
      __defNormalProp$h(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _Orientation = class _Orientation {
      /** @internal */
      constructor(name) {
        /** @internal */
        __publicField$h(this, "_name");
        this._name = name;
      }
      static flip(from) {
        if (from === _Orientation.HORZ) {
          return _Orientation.VERT;
        } else {
          return _Orientation.HORZ;
        }
      }
      getName() {
        return this._name;
      }
      toString() {
        return this._name;
      }
    };
    __name$B(_Orientation, "Orientation");
    __publicField$h(_Orientation, "HORZ", new _Orientation("horz"));
    __publicField$h(_Orientation, "VERT", new _Orientation("vert"));
    let Orientation = _Orientation;

    var __defProp$A = Object.defineProperty;
    var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$A(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$A = (target, value) => __defProp$A(target, "name", { value, configurable: true });
    var __publicField$g = (obj, key, value) => {
      __defNormalProp$g(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _Rect = class _Rect {
      constructor(x, y, width, height) {
        __publicField$g(this, "x");
        __publicField$g(this, "y");
        __publicField$g(this, "width");
        __publicField$g(this, "height");
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      static empty() {
        return new _Rect(0, 0, 0, 0);
      }
      static fromElement(element) {
        let { x, y, width, height } = element.getBoundingClientRect();
        return new _Rect(x, y, width, height);
      }
      clone() {
        return new _Rect(this.x, this.y, this.width, this.height);
      }
      equals(rect) {
        if (this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height) {
          return true;
        } else {
          return false;
        }
      }
      getBottom() {
        return this.y + this.height;
      }
      getRight() {
        return this.x + this.width;
      }
      getCenter() {
        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
      }
      positionElement(element, position) {
        this.styleWithPosition(element.style, position);
      }
      styleWithPosition(style, position = "absolute") {
        style.left = this.x + "px";
        style.top = this.y + "px";
        style.width = Math.max(0, this.width) + "px";
        style.height = Math.max(0, this.height) + "px";
        style.position = position;
        return style;
      }
      contains(x, y) {
        if (this.x <= x && x <= this.getRight() && this.y <= y && y <= this.getBottom()) {
          return true;
        } else {
          return false;
        }
      }
      removeInsets(insets) {
        return new _Rect(this.x + insets.left, this.y + insets.top, Math.max(0, this.width - insets.left - insets.right), Math.max(0, this.height - insets.top - insets.bottom));
      }
      centerInRect(outerRect) {
        this.x = (outerRect.width - this.width) / 2;
        this.y = (outerRect.height - this.height) / 2;
      }
      /** @internal */
      _getSize(orientation) {
        let prefSize = this.width;
        if (orientation === Orientation.VERT) {
          prefSize = this.height;
        }
        return prefSize;
      }
      toString() {
        return "(Rect: x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
      }
    };
    __name$A(_Rect, "Rect");
    let Rect = _Rect;

    var __defProp$z = Object.defineProperty;
    var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$z = (target, value) => __defProp$z(target, "name", { value, configurable: true });
    var __publicField$f = (obj, key, value) => {
      __defNormalProp$f(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _DockLocation = class _DockLocation {
      /** @internal */
      constructor(name, orientation, indexPlus) {
        /** @internal */
        __publicField$f(this, "_name");
        /** @internal */
        __publicField$f(this, "_orientation");
        /** @internal */
        __publicField$f(this, "_indexPlus");
        this._name = name;
        this._orientation = orientation;
        this._indexPlus = indexPlus;
        _DockLocation.values[this._name] = this;
      }
      /** @internal */
      static getByName(name) {
        return _DockLocation.values[name];
      }
      /** @internal */
      static getLocation(rect, x, y) {
        x = (x - rect.x) / rect.width;
        y = (y - rect.y) / rect.height;
        if (x >= 0.25 && x < 0.75 && y >= 0.25 && y < 0.75) {
          return _DockLocation.CENTER;
        }
        const bl = y >= x;
        const br = y >= 1 - x;
        if (bl) {
          return br ? _DockLocation.BOTTOM : _DockLocation.LEFT;
        } else {
          return br ? _DockLocation.RIGHT : _DockLocation.TOP;
        }
      }
      getName() {
        return this._name;
      }
      getOrientation() {
        return this._orientation;
      }
      /** @internal */
      getDockRect(r) {
        if (this === _DockLocation.TOP) {
          return new Rect(r.x, r.y, r.width, r.height / 2);
        } else if (this === _DockLocation.BOTTOM) {
          return new Rect(r.x, r.getBottom() - r.height / 2, r.width, r.height / 2);
        }
        if (this === _DockLocation.LEFT) {
          return new Rect(r.x, r.y, r.width / 2, r.height);
        } else if (this === _DockLocation.RIGHT) {
          return new Rect(r.getRight() - r.width / 2, r.y, r.width / 2, r.height);
        } else {
          return r.clone();
        }
      }
      /** @internal */
      split(rect, size) {
        if (this === _DockLocation.TOP) {
          const r1 = new Rect(rect.x, rect.y, rect.width, size);
          const r2 = new Rect(rect.x, rect.y + size, rect.width, rect.height - size);
          return { start: r1, end: r2 };
        } else if (this === _DockLocation.LEFT) {
          const r1 = new Rect(rect.x, rect.y, size, rect.height);
          const r2 = new Rect(rect.x + size, rect.y, rect.width - size, rect.height);
          return { start: r1, end: r2 };
        }
        if (this === _DockLocation.RIGHT) {
          const r1 = new Rect(rect.getRight() - size, rect.y, size, rect.height);
          const r2 = new Rect(rect.x, rect.y, rect.width - size, rect.height);
          return { start: r1, end: r2 };
        } else {
          const r1 = new Rect(rect.x, rect.getBottom() - size, rect.width, size);
          const r2 = new Rect(rect.x, rect.y, rect.width, rect.height - size);
          return { start: r1, end: r2 };
        }
      }
      /** @internal */
      reflect() {
        if (this === _DockLocation.TOP) {
          return _DockLocation.BOTTOM;
        } else if (this === _DockLocation.LEFT) {
          return _DockLocation.RIGHT;
        }
        if (this === _DockLocation.RIGHT) {
          return _DockLocation.LEFT;
        } else {
          return _DockLocation.TOP;
        }
      }
      toString() {
        return "(DockLocation: name=" + this._name + ", orientation=" + this._orientation + ")";
      }
    };
    __name$z(_DockLocation, "DockLocation");
    __publicField$f(_DockLocation, "values", {});
    __publicField$f(_DockLocation, "TOP", new _DockLocation("top", Orientation.VERT, 0));
    __publicField$f(_DockLocation, "BOTTOM", new _DockLocation("bottom", Orientation.VERT, 1));
    __publicField$f(_DockLocation, "LEFT", new _DockLocation("left", Orientation.HORZ, 0));
    __publicField$f(_DockLocation, "RIGHT", new _DockLocation("right", Orientation.HORZ, 1));
    __publicField$f(_DockLocation, "CENTER", new _DockLocation("center", Orientation.VERT, 0));
    let DockLocation = _DockLocation;

    var __defProp$y = Object.defineProperty;
    var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$y = (target, value) => __defProp$y(target, "name", { value, configurable: true });
    var __publicField$e = (obj, key, value) => {
      __defNormalProp$e(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
    const _DragDrop = class _DragDrop {
      /** @internal */
      constructor() {
        /** @internal */
        __publicField$e(this, "_fDblClick");
        /** @internal */
        __publicField$e(this, "_fClick");
        /** @internal */
        __publicField$e(this, "_fDragEnd");
        /** @internal */
        __publicField$e(this, "_fDragMove");
        /** @internal */
        __publicField$e(this, "_fDragStart");
        /** @internal */
        __publicField$e(this, "_fDragCancel");
        /** @internal */
        __publicField$e(this, "_glass");
        /** @internal */
        __publicField$e(this, "_defaultGlassCursor");
        /** @internal */
        __publicField$e(this, "_glassCursorOverride");
        /** @internal */
        __publicField$e(this, "_manualGlassManagement", false);
        /** @internal */
        __publicField$e(this, "_lastClick");
        /** @internal */
        __publicField$e(this, "_clickX");
        /** @internal */
        __publicField$e(this, "_clickY");
        /** @internal */
        __publicField$e(this, "_startX", 0);
        /** @internal */
        __publicField$e(this, "_startY", 0);
        /** @internal */
        __publicField$e(this, "_dragDepth", 0);
        /** @internal */
        __publicField$e(this, "_glassShowing", false);
        /** @internal */
        __publicField$e(this, "_dragging", false);
        /** @internal */
        __publicField$e(this, "_active", false);
        // drag and drop is in progress, can be used on ios to prevent body scrolling (see demo)
        /** @internal */
        __publicField$e(this, "_document");
        /** @internal */
        __publicField$e(this, "_rootElement");
        /** @internal */
        __publicField$e(this, "_lastEvent");
        if (canUseDOM) {
          this._glass = document.createElement("div");
          this._glass.style.zIndex = "998";
          this._glass.style.backgroundColor = "transparent";
          this._glass.style.outline = "none";
        }
        this._defaultGlassCursor = "default";
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._onKeyPress = this._onKeyPress.bind(this);
        this._onDragCancel = this._onDragCancel.bind(this);
        this._onDragEnter = this._onDragEnter.bind(this);
        this._onDragLeave = this._onDragLeave.bind(this);
        this.resizeGlass = this.resizeGlass.bind(this);
        this._lastClick = 0;
        this._clickX = 0;
        this._clickY = 0;
      }
      // if you add the glass pane then you should remove it
      addGlass(fCancel) {
        if (!this._glassShowing) {
          if (!this._document) {
            this._document = window.document;
          }
          if (!this._rootElement) {
            this._rootElement = this._document.body;
          }
          this.resizeGlass();
          this._document.defaultView?.addEventListener("resize", this.resizeGlass);
          this._document.body.appendChild(this._glass);
          this._glass.tabIndex = -1;
          this._glass.focus();
          this._glass.addEventListener("keydown", this._onKeyPress);
          this._glass.addEventListener("dragenter", this._onDragEnter, { passive: false });
          this._glass.addEventListener("dragover", this._onMouseMove, { passive: false });
          this._glass.addEventListener("dragleave", this._onDragLeave, { passive: false });
          this._glassShowing = true;
          this._fDragCancel = fCancel;
          this._manualGlassManagement = false;
        } else {
          this._manualGlassManagement = true;
        }
      }
      resizeGlass() {
        const glassRect = Rect.fromElement(this._rootElement);
        glassRect.positionElement(this._glass, "fixed");
      }
      hideGlass() {
        if (this._glassShowing) {
          this._document.body.removeChild(this._glass);
          this._document.defaultView?.removeEventListener("resize", this.resizeGlass);
          this._glassShowing = false;
          this._document = void 0;
          this._rootElement = void 0;
          this.setGlassCursorOverride(void 0);
        }
      }
      /** @internal */
      _updateGlassCursor() {
        this._glass.style.cursor = this._glassCursorOverride ?? this._defaultGlassCursor;
      }
      /** @internal */
      _setDefaultGlassCursor(cursor) {
        this._defaultGlassCursor = cursor;
        this._updateGlassCursor();
      }
      setGlassCursorOverride(cursor) {
        this._glassCursorOverride = cursor;
        this._updateGlassCursor();
      }
      startDrag(event, fDragStart, fDragMove, fDragEnd, fDragCancel, fClick, fDblClick, currentDocument, rootElement) {
        if (event && this._lastEvent && this._lastEvent.type.startsWith("touch") && event.type.startsWith("mouse") && event.timeStamp - this._lastEvent.timeStamp < 500) {
          return;
        }
        this._lastEvent = event;
        if (currentDocument) {
          this._document = currentDocument;
        } else {
          this._document = window.document;
        }
        if (rootElement) {
          this._rootElement = rootElement;
        } else {
          this._rootElement = this._document.body;
        }
        const posEvent = this._getLocationEvent(event);
        this.addGlass(fDragCancel);
        if (this._dragging) {
          console.warn("this._dragging true on startDrag should never happen");
        }
        if (event) {
          this._startX = posEvent.clientX;
          this._startY = posEvent.clientY;
          if (!window.matchMedia || window.matchMedia("(pointer: fine)").matches) {
            this._setDefaultGlassCursor(getComputedStyle(event.target).cursor);
          }
          this._stopPropagation(event);
          this._preventDefault(event);
        } else {
          this._startX = 0;
          this._startY = 0;
          this._setDefaultGlassCursor("default");
        }
        this._dragging = false;
        this._fDragStart = fDragStart;
        this._fDragMove = fDragMove;
        this._fDragEnd = fDragEnd;
        this._fDragCancel = fDragCancel;
        this._fClick = fClick;
        this._fDblClick = fDblClick;
        this._active = true;
        if (event?.type === "dragenter") {
          this._dragDepth = 1;
          this._rootElement.addEventListener("dragenter", this._onDragEnter, { passive: false });
          this._rootElement.addEventListener("dragover", this._onMouseMove, { passive: false });
          this._rootElement.addEventListener("dragleave", this._onDragLeave, { passive: false });
          this._document.addEventListener("dragend", this._onDragCancel, { passive: false });
          this._document.addEventListener("drop", this._onMouseUp, { passive: false });
        } else {
          this._document.addEventListener("mouseup", this._onMouseUp, { passive: false });
          this._document.addEventListener("mousemove", this._onMouseMove, { passive: false });
          this._document.addEventListener("touchend", this._onMouseUp, { passive: false });
          this._document.addEventListener("touchmove", this._onMouseMove, { passive: false });
        }
      }
      isDragging() {
        return this._dragging;
      }
      isActive() {
        return this._active;
      }
      toString() {
        const rtn = "(DragDrop: startX=" + this._startX + ", startY=" + this._startY + ", dragging=" + this._dragging + ")";
        return rtn;
      }
      /** @internal */
      _onKeyPress(event) {
        if (event.keyCode === 27) {
          this._onDragCancel();
        }
      }
      /** @internal */
      _onDragCancel() {
        this._rootElement.removeEventListener("dragenter", this._onDragEnter);
        this._rootElement.removeEventListener("dragover", this._onMouseMove);
        this._rootElement.removeEventListener("dragleave", this._onDragLeave);
        this._document.removeEventListener("dragend", this._onDragCancel);
        this._document.removeEventListener("drop", this._onMouseUp);
        this._document.removeEventListener("mousemove", this._onMouseMove);
        this._document.removeEventListener("mouseup", this._onMouseUp);
        this._document.removeEventListener("touchend", this._onMouseUp);
        this._document.removeEventListener("touchmove", this._onMouseMove);
        this.hideGlass();
        if (this._fDragCancel !== void 0) {
          this._fDragCancel(this._dragging);
        }
        this._dragging = false;
        this._active = false;
      }
      /** @internal */
      _getLocationEvent(event) {
        let posEvent = event;
        if (event && event.touches) {
          posEvent = event.touches[0];
        }
        return posEvent;
      }
      /** @internal */
      _getLocationEventEnd(event) {
        let posEvent = event;
        if (event.changedTouches) {
          posEvent = event.changedTouches[0];
        }
        return posEvent;
      }
      /** @internal */
      _stopPropagation(event) {
        if (event.stopPropagation) {
          event.stopPropagation();
        }
      }
      /** @internal */
      _preventDefault(event) {
        if (event.preventDefault && event.cancelable) {
          event.preventDefault();
        }
        return event;
      }
      /** @internal */
      _onMouseMove(event) {
        this._lastEvent = event;
        const posEvent = this._getLocationEvent(event);
        this._stopPropagation(event);
        this._preventDefault(event);
        if (!this._dragging && (Math.abs(this._startX - posEvent.clientX) > 5 || Math.abs(this._startY - posEvent.clientY) > 5)) {
          this._dragging = true;
          if (this._fDragStart) {
            this._setDefaultGlassCursor("move");
            this._dragging = this._fDragStart({ clientX: this._startX, clientY: this._startY });
          }
        }
        if (this._dragging) {
          if (this._fDragMove) {
            this._fDragMove(posEvent);
          }
        }
        return false;
      }
      /** @internal */
      _onMouseUp(event) {
        this._lastEvent = event;
        const posEvent = this._getLocationEventEnd(event);
        this._stopPropagation(event);
        this._preventDefault(event);
        this._active = false;
        this._rootElement.removeEventListener("dragenter", this._onDragEnter);
        this._rootElement.removeEventListener("dragover", this._onMouseMove);
        this._rootElement.removeEventListener("dragleave", this._onDragLeave);
        this._document.removeEventListener("dragend", this._onDragCancel);
        this._document.removeEventListener("drop", this._onMouseUp);
        this._document.removeEventListener("mousemove", this._onMouseMove);
        this._document.removeEventListener("mouseup", this._onMouseUp);
        this._document.removeEventListener("touchend", this._onMouseUp);
        this._document.removeEventListener("touchmove", this._onMouseMove);
        if (!this._manualGlassManagement) {
          this.hideGlass();
        }
        if (this._dragging) {
          this._dragging = false;
          if (this._fDragEnd) {
            this._fDragEnd(event);
          }
        } else {
          if (this._fDragCancel) {
            this._fDragCancel(this._dragging);
          }
          if (Math.abs(this._startX - posEvent.clientX) <= 5 && Math.abs(this._startY - posEvent.clientY) <= 5) {
            let isDoubleClick = false;
            const clickTime = (/* @__PURE__ */ new Date()).getTime();
            if (Math.abs(this._clickX - posEvent.clientX) <= 5 && Math.abs(this._clickY - posEvent.clientY) <= 5) {
              if (clickTime - this._lastClick < 500) {
                if (this._fDblClick) {
                  this._fDblClick(event);
                  isDoubleClick = true;
                }
              }
            }
            if (!isDoubleClick && this._fClick) {
              this._fClick(event);
            }
            this._lastClick = clickTime;
            this._clickX = posEvent.clientX;
            this._clickY = posEvent.clientY;
          }
        }
        return false;
      }
      /** @internal */
      _onDragEnter(event) {
        this._preventDefault(event);
        this._stopPropagation(event);
        this._dragDepth++;
        return false;
      }
      /** @internal */
      _onDragLeave(event) {
        this._preventDefault(event);
        this._stopPropagation(event);
        this._dragDepth--;
        if (this._dragDepth <= 0) {
          this._onDragCancel();
        }
        return false;
      }
    };
    __name$y(_DragDrop, "DragDrop");
    __publicField$e(_DragDrop, "instance", new _DragDrop());
    let DragDrop = _DragDrop;

    var __defProp$x = Object.defineProperty;
    var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$x(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$x = (target, value) => __defProp$x(target, "name", { value, configurable: true });
    var __publicField$d = (obj, key, value) => {
      __defNormalProp$d(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _Action = class _Action {
      constructor(type, data) {
        __publicField$d(this, "type");
        __publicField$d(this, "data");
        this.type = type;
        this.data = data;
      }
    };
    __name$x(_Action, "Action");
    let Action = _Action;

    var __defProp$w = Object.defineProperty;
    var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$w(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$w = (target, value) => __defProp$w(target, "name", { value, configurable: true });
    var __publicField$c = (obj, key, value) => {
      __defNormalProp$c(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _Actions = class _Actions {
      /**
       * Adds a tab node to the given tabset node
       * @param json the json for the new tab node e.g {type:"tab", component:"table"}
       * @param toNodeId the new tab node will be added to the tabset with this node id
       * @param location the location where the new tab will be added, one of the DockLocation enum values.
       * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.
       * @param select (optional) whether to select the new tab, overriding autoSelectTab
       * @returns {Action} the action
       */
      static addNode(json, toNodeId, location, index, select) {
        return new Action(_Actions.ADD_NODE, {
          json,
          toNode: toNodeId,
          location: location.getName(),
          index,
          select
        });
      }
      /**
       * Moves a node (tab or tabset) from one location to another
       * @param fromNodeId the id of the node to move
       * @param toNodeId the id of the node to receive the moved node
       * @param location the location where the moved node will be added, one of the DockLocation enum values.
       * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.
       * @param select (optional) whether to select the moved tab(s) in new tabset, overriding autoSelectTab
       * @returns {Action} the action
       */
      static moveNode(fromNodeId, toNodeId, location, index, select) {
        return new Action(_Actions.MOVE_NODE, {
          fromNode: fromNodeId,
          toNode: toNodeId,
          location: location.getName(),
          index,
          select
        });
      }
      /**
       * Deletes a tab node from the layout
       * @param tabsetNodeId the id of the tab node to delete
       * @returns {Action} the action
       */
      static deleteTab(tabNodeId) {
        return new Action(_Actions.DELETE_TAB, { node: tabNodeId });
      }
      /**
       * Deletes a tabset node and all it's child tab nodes from the layout
       * @param tabsetNodeId the id of the tabset node to delete
       * @returns {Action} the action
       */
      static deleteTabset(tabsetNodeId) {
        return new Action(_Actions.DELETE_TABSET, { node: tabsetNodeId });
      }
      /**
       * Change the given nodes tab text
       * @param tabNodeId the id of the node to rename
       * @param text the test of the tab
       * @returns {Action} the action
       */
      static renameTab(tabNodeId, text) {
        return new Action(_Actions.RENAME_TAB, { node: tabNodeId, text });
      }
      /**
       * Selects the given tab in its parent tabset
       * @param tabNodeId the id of the node to set selected
       * @returns {Action} the action
       */
      static selectTab(tabNodeId) {
        return new Action(_Actions.SELECT_TAB, { tabNode: tabNodeId });
      }
      /**
       * Set the given tabset node as the active tabset
       * @param tabsetNodeId the id of the tabset node to set as active
       * @returns {Action} the action
       */
      static setActiveTabset(tabsetNodeId) {
        return new Action(_Actions.SET_ACTIVE_TABSET, { tabsetNode: tabsetNodeId });
      }
      /**
       * Adjust the splitter between two tabsets
       * @example
       *  Actions.adjustSplit({node1: "1", weight1:30, pixelWidth1:300, node2: "2", weight2:70, pixelWidth2:700});
       *
       * @param splitSpec an object the defines the new split between two tabsets, see example below.
       * @returns {Action} the action
       */
      static adjustSplit(splitSpec) {
        const node1 = splitSpec.node1Id;
        const node2 = splitSpec.node2Id;
        return new Action(_Actions.ADJUST_SPLIT, {
          node1,
          weight1: splitSpec.weight1,
          pixelWidth1: splitSpec.pixelWidth1,
          node2,
          weight2: splitSpec.weight2,
          pixelWidth2: splitSpec.pixelWidth2
        });
      }
      static adjustBorderSplit(nodeId, pos) {
        return new Action(_Actions.ADJUST_BORDER_SPLIT, { node: nodeId, pos });
      }
      /**
       * Maximizes the given tabset
       * @param tabsetNodeId the id of the tabset to maximize
       * @returns {Action} the action
       */
      static maximizeToggle(tabsetNodeId) {
        return new Action(_Actions.MAXIMIZE_TOGGLE, { node: tabsetNodeId });
      }
      /**
       * Updates the global model jsone attributes
       * @param attributes the json for the model attributes to update (merge into the existing attributes)
       * @returns {Action} the action
       */
      static updateModelAttributes(attributes) {
        return new Action(_Actions.UPDATE_MODEL_ATTRIBUTES, { json: attributes });
      }
      /**
       * Updates the given nodes json attributes
       * @param nodeId the id of the node to update
       * @param attributes the json attributes to update (merge with the existing attributes)
       * @returns {Action} the action
       */
      static updateNodeAttributes(nodeId, attributes) {
        return new Action(_Actions.UPDATE_NODE_ATTRIBUTES, { node: nodeId, json: attributes });
      }
      static floatTab(nodeId) {
        return new Action(_Actions.FLOAT_TAB, { node: nodeId });
      }
      static unFloatTab(nodeId) {
        return new Action(_Actions.UNFLOAT_TAB, { node: nodeId });
      }
    };
    __name$w(_Actions, "Actions");
    __publicField$c(_Actions, "ADD_NODE", "FlexLayout_AddNode");
    __publicField$c(_Actions, "MOVE_NODE", "FlexLayout_MoveNode");
    __publicField$c(_Actions, "DELETE_TAB", "FlexLayout_DeleteTab");
    __publicField$c(_Actions, "DELETE_TABSET", "FlexLayout_DeleteTabset");
    __publicField$c(_Actions, "RENAME_TAB", "FlexLayout_RenameTab");
    __publicField$c(_Actions, "SELECT_TAB", "FlexLayout_SelectTab");
    __publicField$c(_Actions, "SET_ACTIVE_TABSET", "FlexLayout_SetActiveTabset");
    __publicField$c(_Actions, "ADJUST_SPLIT", "FlexLayout_AdjustSplit");
    __publicField$c(_Actions, "ADJUST_BORDER_SPLIT", "FlexLayout_AdjustBorderSplit");
    __publicField$c(_Actions, "MAXIMIZE_TOGGLE", "FlexLayout_MaximizeToggle");
    __publicField$c(_Actions, "UPDATE_MODEL_ATTRIBUTES", "FlexLayout_UpdateModelAttributes");
    __publicField$c(_Actions, "UPDATE_NODE_ATTRIBUTES", "FlexLayout_UpdateNodeAttributes");
    __publicField$c(_Actions, "FLOAT_TAB", "FlexLayout_FloatTab");
    __publicField$c(_Actions, "UNFLOAT_TAB", "FlexLayout_UnFloatTab");
    let Actions = _Actions;

    var __defProp$v = Object.defineProperty;
    var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$v(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$v = (target, value) => __defProp$v(target, "name", { value, configurable: true });
    var __publicField$b = (obj, key, value) => {
      __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _Attribute = class _Attribute {
      constructor(name, modelName, defaultValue, alwaysWriteJson) {
        __publicField$b(this, "name");
        __publicField$b(this, "modelName");
        __publicField$b(this, "defaultValue");
        __publicField$b(this, "alwaysWriteJson");
        __publicField$b(this, "type");
        __publicField$b(this, "required");
        __publicField$b(this, "fixed");
        this.name = name;
        this.modelName = modelName;
        this.defaultValue = defaultValue;
        this.alwaysWriteJson = alwaysWriteJson;
        this.required = false;
        this.fixed = false;
        this.type = "any";
      }
      setType(value) {
        this.type = value;
        return this;
      }
      setRequired() {
        this.required = true;
        return this;
      }
      setFixed() {
        this.fixed = true;
        return this;
      }
    };
    __name$v(_Attribute, "Attribute");
    __publicField$b(_Attribute, "NUMBER", "number");
    __publicField$b(_Attribute, "STRING", "string");
    __publicField$b(_Attribute, "BOOLEAN", "boolean");
    let Attribute = _Attribute;

    var __defProp$u = Object.defineProperty;
    var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$u = (target, value) => __defProp$u(target, "name", { value, configurable: true });
    var __publicField$a = (obj, key, value) => {
      __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _AttributeDefinitions = class _AttributeDefinitions {
      constructor() {
        __publicField$a(this, "attributes");
        __publicField$a(this, "nameToAttribute");
        this.attributes = [];
        this.nameToAttribute = {};
      }
      addWithAll(name, modelName, defaultValue, alwaysWriteJson) {
        const attr = new Attribute(name, modelName, defaultValue, alwaysWriteJson);
        this.attributes.push(attr);
        this.nameToAttribute[name] = attr;
        return attr;
      }
      addInherited(name, modelName) {
        return this.addWithAll(name, modelName, void 0, false);
      }
      add(name, defaultValue, alwaysWriteJson) {
        return this.addWithAll(name, void 0, defaultValue, alwaysWriteJson);
      }
      getAttributes() {
        return this.attributes;
      }
      getModelName(name) {
        const conversion = this.nameToAttribute[name];
        if (conversion !== void 0) {
          return conversion.modelName;
        }
        return void 0;
      }
      toJson(jsonObj, obj) {
        for (const attr of this.attributes) {
          const fromValue = obj[attr.name];
          if (attr.alwaysWriteJson || fromValue !== attr.defaultValue) {
            jsonObj[attr.name] = fromValue;
          }
        }
      }
      fromJson(jsonObj, obj) {
        for (const attr of this.attributes) {
          const fromValue = jsonObj[attr.name];
          if (fromValue === void 0) {
            obj[attr.name] = attr.defaultValue;
          } else {
            obj[attr.name] = fromValue;
          }
        }
      }
      update(jsonObj, obj) {
        for (const attr of this.attributes) {
          if (jsonObj.hasOwnProperty(attr.name)) {
            const fromValue = jsonObj[attr.name];
            if (fromValue === void 0) {
              delete obj[attr.name];
            } else {
              obj[attr.name] = fromValue;
            }
          }
        }
      }
      setDefaults(obj) {
        for (const attr of this.attributes) {
          obj[attr.name] = attr.defaultValue;
        }
      }
      toTypescriptInterface(name, parentAttributes) {
        const lines = [];
        const sorted = this.attributes.sort((a, b) => a.name.localeCompare(b.name));
        lines.push("export interface I" + name + "Attributes {");
        for (let i = 0; i < sorted.length; i++) {
          const c = sorted[i];
          let type = c.type;
          let defaultValue = void 0;
          let attr = c;
          let inherited = void 0;
          if (attr.defaultValue !== void 0) {
            defaultValue = attr.defaultValue;
          } else if (attr.modelName !== void 0 && parentAttributes !== void 0 && parentAttributes.nameToAttribute[attr.modelName] !== void 0) {
            inherited = attr.modelName;
            attr = parentAttributes.nameToAttribute[attr.modelName];
            defaultValue = attr.defaultValue;
            type = attr.type;
          }
          let defValue = JSON.stringify(defaultValue);
          const required = attr.required || attr.fixed ? "" : "?";
          if (c.fixed) {
            lines.push("	" + c.name + ": " + defValue + ";");
          } else {
            const comment = (defaultValue !== void 0 ? "default: " + defValue : "") + (inherited !== void 0 ? " - inherited from global " + inherited : "");
            lines.push(
              "	" + c.name + required + ": " + type + ";" + (comment.length > 0 ? " // " + comment : "")
            );
          }
        }
        lines.push("}");
        return lines.join("\n");
      }
    };
    __name$u(_AttributeDefinitions, "AttributeDefinitions");
    let AttributeDefinitions = _AttributeDefinitions;

    var __defProp$t = Object.defineProperty;
    var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$t = (target, value) => __defProp$t(target, "name", { value, configurable: true });
    var __publicField$9 = (obj, key, value) => {
      __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _DropInfo = class _DropInfo {
      constructor(node, rect, location, index, className) {
        __publicField$9(this, "node");
        __publicField$9(this, "rect");
        __publicField$9(this, "location");
        __publicField$9(this, "index");
        __publicField$9(this, "className");
        this.node = node;
        this.rect = rect;
        this.location = location;
        this.index = index;
        this.className = className;
      }
    };
    __name$t(_DropInfo, "DropInfo");
    let DropInfo = _DropInfo;

    var CLASSES = /* @__PURE__ */ ((CLASSES2) => {
      CLASSES2["FLEXLAYOUT__BORDER"] = "flexlayout__border";
      CLASSES2["FLEXLAYOUT__BORDER_"] = "flexlayout__border_";
      CLASSES2["FLEXLAYOUT__BORDER_BUTTON"] = "flexlayout__border_button";
      CLASSES2["FLEXLAYOUT__BORDER_BUTTON_"] = "flexlayout__border_button_";
      CLASSES2["FLEXLAYOUT__BORDER_BUTTON_CONTENT"] = "flexlayout__border_button_content";
      CLASSES2["FLEXLAYOUT__BORDER_BUTTON_LEADING"] = "flexlayout__border_button_leading";
      CLASSES2["FLEXLAYOUT__BORDER_BUTTON_TRAILING"] = "flexlayout__border_button_trailing";
      CLASSES2["FLEXLAYOUT__BORDER_BUTTON__SELECTED"] = "flexlayout__border_button--selected";
      CLASSES2["FLEXLAYOUT__BORDER_BUTTON__UNSELECTED"] = "flexlayout__border_button--unselected";
      CLASSES2["FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW"] = "flexlayout__border_toolbar_button_overflow";
      CLASSES2["FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_"] = "flexlayout__border_toolbar_button_overflow_";
      CLASSES2["FLEXLAYOUT__BORDER_INNER"] = "flexlayout__border_inner";
      CLASSES2["FLEXLAYOUT__BORDER_INNER_"] = "flexlayout__border_inner_";
      CLASSES2["FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER"] = "flexlayout__border_inner_tab_container";
      CLASSES2["FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_"] = "flexlayout__border_inner_tab_container_";
      CLASSES2["FLEXLAYOUT__BORDER_TAB_DIVIDER"] = "flexlayout__border_tab_divider";
      CLASSES2["FLEXLAYOUT__BORDER_SIZER"] = "flexlayout__border_sizer";
      CLASSES2["FLEXLAYOUT__BORDER_TOOLBAR"] = "flexlayout__border_toolbar";
      CLASSES2["FLEXLAYOUT__BORDER_TOOLBAR_"] = "flexlayout__border_toolbar_";
      CLASSES2["FLEXLAYOUT__BORDER_TOOLBAR_BUTTON"] = "flexlayout__border_toolbar_button";
      CLASSES2["FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT"] = "flexlayout__border_toolbar_button-float";
      CLASSES2["FLEXLAYOUT__DRAG_RECT"] = "flexlayout__drag_rect";
      CLASSES2["FLEXLAYOUT__EDGE_RECT"] = "flexlayout__edge_rect";
      CLASSES2["FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER"] = "flexlayout__error_boundary_container";
      CLASSES2["FLEXLAYOUT__ERROR_BOUNDARY_CONTENT"] = "flexlayout__error_boundary_content";
      CLASSES2["FLEXLAYOUT__FLOATING_WINDOW_CONTENT"] = "flexlayout__floating_window_content";
      CLASSES2["FLEXLAYOUT__FLOATING_WINDOW_TAB"] = "flexlayout__floating_window_tab";
      CLASSES2["FLEXLAYOUT__LAYOUT"] = "flexlayout__layout";
      CLASSES2["FLEXLAYOUT__OUTLINE_RECT"] = "flexlayout__outline_rect";
      CLASSES2["FLEXLAYOUT__OUTLINE_RECT_EDGE"] = "flexlayout__outline_rect_edge";
      CLASSES2["FLEXLAYOUT__SPLITTER"] = "flexlayout__splitter";
      CLASSES2["FLEXLAYOUT__SPLITTER_EXTRA"] = "flexlayout__splitter_extra";
      CLASSES2["FLEXLAYOUT__SPLITTER_"] = "flexlayout__splitter_";
      CLASSES2["FLEXLAYOUT__SPLITTER_BORDER"] = "flexlayout__splitter_border";
      CLASSES2["FLEXLAYOUT__SPLITTER_DRAG"] = "flexlayout__splitter_drag";
      CLASSES2["FLEXLAYOUT__TAB"] = "flexlayout__tab";
      CLASSES2["FLEXLAYOUT__TABSET"] = "flexlayout__tabset";
      CLASSES2["FLEXLAYOUT__TABSET_HEADER"] = "flexlayout__tabset_header";
      CLASSES2["FLEXLAYOUT__TABSET_HEADER_SIZER"] = "flexlayout__tabset_header_sizer";
      CLASSES2["FLEXLAYOUT__TABSET_HEADER_CONTENT"] = "flexlayout__tabset_header_content";
      CLASSES2["FLEXLAYOUT__TABSET_MAXIMIZED"] = "flexlayout__tabset-maximized";
      CLASSES2["FLEXLAYOUT__TABSET_SELECTED"] = "flexlayout__tabset-selected";
      CLASSES2["FLEXLAYOUT__TABSET_SIZER"] = "flexlayout__tabset_sizer";
      CLASSES2["FLEXLAYOUT__TABSET_TAB_DIVIDER"] = "flexlayout__tabset_tab_divider";
      CLASSES2["FLEXLAYOUT__TABSET_CONTENT"] = "flexlayout__tabset_content";
      CLASSES2["FLEXLAYOUT__TABSET_TABBAR_INNER"] = "flexlayout__tabset_tabbar_inner";
      CLASSES2["FLEXLAYOUT__TABSET_TABBAR_INNER_"] = "flexlayout__tabset_tabbar_inner_";
      CLASSES2["FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER"] = "flexlayout__tabset_tabbar_inner_tab_container";
      CLASSES2["FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_"] = "flexlayout__tabset_tabbar_inner_tab_container_";
      CLASSES2["FLEXLAYOUT__TABSET_TABBAR_OUTER"] = "flexlayout__tabset_tabbar_outer";
      CLASSES2["FLEXLAYOUT__TABSET_TABBAR_OUTER_"] = "flexlayout__tabset_tabbar_outer_";
      CLASSES2["FLEXLAYOUT__TAB_BORDER"] = "flexlayout__tab_border";
      CLASSES2["FLEXLAYOUT__TAB_BORDER_"] = "flexlayout__tab_border_";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON"] = "flexlayout__tab_button";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON_CONTENT"] = "flexlayout__tab_button_content";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON_LEADING"] = "flexlayout__tab_button_leading";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON_OVERFLOW"] = "flexlayout__tab_button_overflow";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT"] = "flexlayout__tab_button_overflow_count";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON_TEXTBOX"] = "flexlayout__tab_button_textbox";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON_TRAILING"] = "flexlayout__tab_button_trailing";
      CLASSES2["FLEXLAYOUT__TAB_BUTTON_STAMP"] = "flexlayout__tab_button_stamp";
      CLASSES2["FLEXLAYOUT__TAB_FLOATING"] = "flexlayout__tab_floating";
      CLASSES2["FLEXLAYOUT__TAB_FLOATING_INNER"] = "flexlayout__tab_floating_inner";
      CLASSES2["FLEXLAYOUT__TAB_TOOLBAR"] = "flexlayout__tab_toolbar";
      CLASSES2["FLEXLAYOUT__TAB_TOOLBAR_BUTTON"] = "flexlayout__tab_toolbar_button";
      CLASSES2["FLEXLAYOUT__TAB_TOOLBAR_BUTTON_"] = "flexlayout__tab_toolbar_button-";
      CLASSES2["FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT"] = "flexlayout__tab_toolbar_button-float";
      CLASSES2["FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER"] = "flexlayout__tab_toolbar_sticky_buttons_container";
      CLASSES2["FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE"] = "flexlayout__tab_toolbar_button-close";
      CLASSES2["FLEXLAYOUT__POPUP_MENU_CONTAINER"] = "flexlayout__popup_menu_container";
      CLASSES2["FLEXLAYOUT__POPUP_MENU_ITEM"] = "flexlayout__popup_menu_item";
      CLASSES2["FLEXLAYOUT__POPUP_MENU"] = "flexlayout__popup_menu";
      return CLASSES2;
    })(CLASSES || {});

    var __defProp$s = Object.defineProperty;
    var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$s = (target, value) => __defProp$s(target, "name", { value, configurable: true });
    var __publicField$8 = (obj, key, value) => {
      __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _Node = class _Node {
      /** @internal */
      constructor(model) {
        /** @internal */
        __publicField$8(this, "_model");
        /** @internal */
        __publicField$8(this, "_attributes");
        /** @internal */
        __publicField$8(this, "_parent");
        /** @internal */
        __publicField$8(this, "_children");
        /** @internal */
        __publicField$8(this, "_fixed");
        /** @internal */
        __publicField$8(this, "_rect");
        /** @internal */
        __publicField$8(this, "_visible");
        /** @internal */
        __publicField$8(this, "_listeners");
        /** @internal */
        __publicField$8(this, "_dirty", false);
        /** @internal */
        __publicField$8(this, "_tempSize", 0);
        this._model = model;
        this._attributes = {};
        this._children = [];
        this._fixed = false;
        this._rect = Rect.empty();
        this._visible = false;
        this._listeners = {};
      }
      getId() {
        let id = this._attributes.id;
        if (id !== void 0) {
          return id;
        }
        id = this._model._nextUniqueId();
        this._setId(id);
        return id;
      }
      getModel() {
        return this._model;
      }
      getType() {
        return this._attributes.type;
      }
      getParent() {
        return this._parent;
      }
      getChildren() {
        return this._children;
      }
      getRect() {
        return this._rect;
      }
      isVisible() {
        return this._visible;
      }
      getOrientation() {
        if (this._parent === void 0) {
          return this._model.isRootOrientationVertical() ? Orientation.VERT : Orientation.HORZ;
        } else {
          return Orientation.flip(this._parent.getOrientation());
        }
      }
      // event can be: resize, visibility, maximize (on tabset), close
      setEventListener(event, callback) {
        this._listeners[event] = callback;
      }
      removeEventListener(event) {
        delete this._listeners[event];
      }
      /** @internal */
      _setId(id) {
        this._attributes.id = id;
      }
      /** @internal */
      _fireEvent(event, params) {
        if (this._listeners[event] !== void 0) {
          this._listeners[event](params);
        }
      }
      /** @internal */
      _getAttr(name) {
        let val = this._attributes[name];
        if (val === void 0) {
          const modelName = this._getAttributeDefinitions().getModelName(name);
          if (modelName !== void 0) {
            val = this._model._getAttribute(modelName);
          }
        }
        return val;
      }
      /** @internal */
      _forEachNode(fn, level) {
        fn(this, level);
        level++;
        for (const node of this._children) {
          node._forEachNode(fn, level);
        }
      }
      /** @internal */
      _setVisible(visible) {
        if (visible !== this._visible) {
          this._fireEvent("visibility", { visible });
          this._visible = visible;
        }
      }
      /** @internal */
      _getDrawChildren() {
        return this._children;
      }
      /** @internal */
      _setParent(parent) {
        this._parent = parent;
      }
      /** @internal */
      _setRect(rect) {
        this._rect = rect;
      }
      /** @internal */
      _setWeight(weight) {
        this._attributes.weight = weight;
      }
      /** @internal */
      _setSelected(index) {
        this._attributes.selected = index;
      }
      /** @internal */
      _isFixed() {
        return this._fixed;
      }
      /** @internal */
      _layout(rect, metrics) {
        this._rect = rect;
      }
      /** @internal */
      _findDropTargetNode(dragNode, x, y) {
        let rtn;
        if (this._rect.contains(x, y)) {
          if (this._model.getMaximizedTabset() !== void 0) {
            rtn = this._model.getMaximizedTabset().canDrop(dragNode, x, y);
          } else {
            rtn = this.canDrop(dragNode, x, y);
            if (rtn === void 0) {
              if (this._children.length !== 0) {
                for (const child of this._children) {
                  rtn = child._findDropTargetNode(dragNode, x, y);
                  if (rtn !== void 0) {
                    break;
                  }
                }
              }
            }
          }
        }
        return rtn;
      }
      /** @internal */
      canDrop(dragNode, x, y) {
        return void 0;
      }
      /** @internal */
      _canDockInto(dragNode, dropInfo) {
        if (dropInfo != null) {
          if (dropInfo.location === DockLocation.CENTER && dropInfo.node.isEnableDrop() === false) {
            return false;
          }
          if (dropInfo.location === DockLocation.CENTER && dragNode.getType() === "tabset" && dragNode.getName() !== void 0) {
            return false;
          }
          if (dropInfo.location !== DockLocation.CENTER && dropInfo.node.isEnableDivide() === false) {
            return false;
          }
          if (this._model._getOnAllowDrop()) {
            return this._model._getOnAllowDrop()(dragNode, dropInfo);
          }
        }
        return true;
      }
      /** @internal */
      _removeChild(childNode) {
        const pos = this._children.indexOf(childNode);
        if (pos !== -1) {
          this._children.splice(pos, 1);
        }
        this._dirty = true;
        return pos;
      }
      /** @internal */
      _addChild(childNode, pos) {
        if (pos != null) {
          this._children.splice(pos, 0, childNode);
        } else {
          this._children.push(childNode);
          pos = this._children.length - 1;
        }
        childNode._parent = this;
        this._dirty = true;
        return pos;
      }
      /** @internal */
      _removeAll() {
        this._children = [];
        this._dirty = true;
      }
      /** @internal */
      _styleWithPosition(style) {
        if (style == null) {
          style = {};
        }
        return this._rect.styleWithPosition(style);
      }
      /** @internal */
      _getTempSize() {
        return this._tempSize;
      }
      /** @internal */
      _setTempSize(value) {
        this._tempSize = value;
      }
      /** @internal */
      isEnableDivide() {
        return true;
      }
      /** @internal */
      _toAttributeString() {
        return JSON.stringify(this._attributes, void 0, "	");
      }
    };
    __name$s(_Node, "Node");
    let Node = _Node;

    var __defProp$r = Object.defineProperty;
    var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$r = (target, value) => __defProp$r(target, "name", { value, configurable: true });
    var __publicField$7 = (obj, key, value) => {
      __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _SplitterNode = class _SplitterNode extends Node {
      /** @internal */
      constructor(model) {
        super(model);
        this._fixed = true;
        this._attributes.type = _SplitterNode.TYPE;
        model._addNode(this);
      }
      /** @internal */
      getWidth() {
        return this._model.getSplitterSize();
      }
      /** @internal */
      getMinWidth() {
        if (this.getOrientation() === Orientation.VERT) {
          return this._model.getSplitterSize();
        } else {
          return 0;
        }
      }
      /** @internal */
      getHeight() {
        return this._model.getSplitterSize();
      }
      /** @internal */
      getMinHeight() {
        if (this.getOrientation() === Orientation.HORZ) {
          return this._model.getSplitterSize();
        } else {
          return 0;
        }
      }
      /** @internal */
      getMinSize(orientation) {
        if (orientation === Orientation.HORZ) {
          return this.getMinWidth();
        } else {
          return this.getMinHeight();
        }
      }
      /** @internal */
      getWeight() {
        return 0;
      }
      /** @internal */
      _setWeight(value) {
      }
      /** @internal */
      _getPrefSize(orientation) {
        return this._model.getSplitterSize();
      }
      /** @internal */
      _updateAttrs(json) {
      }
      /** @internal */
      _getAttributeDefinitions() {
        return new AttributeDefinitions();
      }
      toJson() {
        return void 0;
      }
    };
    __name$r(_SplitterNode, "SplitterNode");
    __publicField$7(_SplitterNode, "TYPE", "splitter");
    let SplitterNode = _SplitterNode;

    var __defProp$q = Object.defineProperty;
    var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$q = (target, value) => __defProp$q(target, "name", { value, configurable: true });
    var __publicField$6 = (obj, key, value) => {
      __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _TabNode = class _TabNode extends Node {
      /** @internal */
      constructor(model, json, addToModel = true) {
        super(model);
        /** @internal */
        __publicField$6(this, "_tabRect");
        /** @internal */
        __publicField$6(this, "_renderedName");
        /** @internal */
        __publicField$6(this, "_extra");
        /** @internal */
        __publicField$6(this, "_window");
        this._extra = {};
        _TabNode._attributeDefinitions.fromJson(json, this._attributes);
        if (addToModel === true) {
          model._addNode(this);
        }
      }
      /** @internal */
      static _fromJson(json, model, addToModel = true) {
        const newLayoutNode = new _TabNode(model, json, addToModel);
        return newLayoutNode;
      }
      /** @internal */
      static _createAttributeDefinitions() {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", _TabNode.TYPE, true).setType(Attribute.STRING);
        attributeDefinitions.add("id", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("name", "[Unnamed Tab]").setType(Attribute.STRING);
        attributeDefinitions.add("altName", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("helpText", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("component", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("config", void 0).setType("any");
        attributeDefinitions.add("floating", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("enableClose", "tabEnableClose").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("closeType", "tabCloseType").setType("ICloseType");
        attributeDefinitions.addInherited("enableDrag", "tabEnableDrag").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("enableRename", "tabEnableRename").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("className", "tabClassName").setType(Attribute.STRING);
        attributeDefinitions.addInherited("icon", "tabIcon").setType(Attribute.STRING);
        attributeDefinitions.addInherited("enableRenderOnDemand", "tabEnableRenderOnDemand").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("enableFloat", "tabEnableFloat").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("borderWidth", "tabBorderWidth").setType(Attribute.NUMBER);
        attributeDefinitions.addInherited("borderHeight", "tabBorderHeight").setType(Attribute.NUMBER);
        return attributeDefinitions;
      }
      getWindow() {
        return this._window;
      }
      getTabRect() {
        return this._tabRect;
      }
      /** @internal */
      _setTabRect(rect) {
        this._tabRect = rect;
      }
      /** @internal */
      _setRenderedName(name) {
        this._renderedName = name;
      }
      /** @internal */
      _getNameForOverflowMenu() {
        const altName = this._getAttr("altName");
        if (altName !== void 0) {
          return altName;
        }
        return this._renderedName;
      }
      getName() {
        return this._getAttr("name");
      }
      getHelpText() {
        return this._getAttr("helpText");
      }
      getComponent() {
        return this._getAttr("component");
      }
      /**
       * Returns the config attribute that can be used to store node specific data that
       * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather
       * than directly, for example:
       * this.state.model.doAction(
       *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));
       */
      getConfig() {
        return this._attributes.config;
      }
      /**
       * Returns an object that can be used to store transient node specific data that will
       * NOT be saved in the json.
       */
      getExtraData() {
        return this._extra;
      }
      isFloating() {
        return this._getAttr("floating");
      }
      getIcon() {
        return this._getAttr("icon");
      }
      isEnableClose() {
        return this._getAttr("enableClose");
      }
      getCloseType() {
        return this._getAttr("closeType");
      }
      isEnableFloat() {
        return this._getAttr("enableFloat");
      }
      isEnableDrag() {
        return this._getAttr("enableDrag");
      }
      isEnableRename() {
        return this._getAttr("enableRename");
      }
      getClassName() {
        return this._getAttr("className");
      }
      isEnableRenderOnDemand() {
        return this._getAttr("enableRenderOnDemand");
      }
      /** @internal */
      _setName(name) {
        this._attributes.name = name;
        if (this._window && this._window.document) {
          this._window.document.title = name;
        }
      }
      /** @internal */
      _setFloating(float) {
        this._attributes.floating = float;
      }
      /** @internal */
      _layout(rect, metrics) {
        if (!rect.equals(this._rect)) {
          this._fireEvent("resize", { rect });
        }
        this._rect = rect;
      }
      /** @internal */
      _delete() {
        this._parent._remove(this);
        this._fireEvent("close", {});
      }
      toJson() {
        const json = {};
        _TabNode._attributeDefinitions.toJson(json, this._attributes);
        return json;
      }
      /** @internal */
      _updateAttrs(json) {
        _TabNode._attributeDefinitions.update(json, this._attributes);
      }
      /** @internal */
      _getAttributeDefinitions() {
        return _TabNode._attributeDefinitions;
      }
      /** @internal */
      _setWindow(window) {
        this._window = window;
      }
      /** @internal */
      _setBorderWidth(width) {
        this._attributes.borderWidth = width;
      }
      /** @internal */
      _setBorderHeight(height) {
        this._attributes.borderHeight = height;
      }
      /** @internal */
      static getAttributeDefinitions() {
        return _TabNode._attributeDefinitions;
      }
    };
    __name$q(_TabNode, "TabNode");
    __publicField$6(_TabNode, "TYPE", "tab");
    /** @internal */
    __publicField$6(_TabNode, "_attributeDefinitions", _TabNode._createAttributeDefinitions());
    let TabNode = _TabNode;

    var __defProp$p = Object.defineProperty;
    var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$p = (target, value) => __defProp$p(target, "name", { value, configurable: true });
    var __publicField$5 = (obj, key, value) => {
      __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _RowNode = class _RowNode extends Node {
      /** @internal */
      constructor(model, json) {
        super(model);
        /** @internal */
        __publicField$5(this, "_drawChildren");
        /** @internal */
        __publicField$5(this, "_minHeight");
        /** @internal */
        __publicField$5(this, "_minWidth");
        this._dirty = true;
        this._drawChildren = [];
        this._minHeight = 0;
        this._minWidth = 0;
        _RowNode._attributeDefinitions.fromJson(json, this._attributes);
        model._addNode(this);
      }
      /** @internal */
      static _fromJson(json, model) {
        const newLayoutNode = new _RowNode(model, json);
        if (json.children != null) {
          for (const jsonChild of json.children) {
            if (jsonChild.type === TabSetNode.TYPE) {
              const child = TabSetNode._fromJson(jsonChild, model);
              newLayoutNode._addChild(child);
            } else {
              const child = _RowNode._fromJson(jsonChild, model);
              newLayoutNode._addChild(child);
            }
          }
        }
        return newLayoutNode;
      }
      /** @internal */
      static _createAttributeDefinitions() {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", _RowNode.TYPE, true).setType(Attribute.STRING).setFixed();
        attributeDefinitions.add("id", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("weight", 100).setType(Attribute.NUMBER);
        attributeDefinitions.add("width", void 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("height", void 0).setType(Attribute.NUMBER);
        return attributeDefinitions;
      }
      getWeight() {
        return this._attributes.weight;
      }
      getWidth() {
        return this._getAttr("width");
      }
      getHeight() {
        return this._getAttr("height");
      }
      /** @internal */
      _setWeight(weight) {
        this._attributes.weight = weight;
      }
      /** @internal */
      _layout(rect, metrics) {
        super._layout(rect, metrics);
        const pixelSize = this._rect._getSize(this.getOrientation());
        let totalWeight = 0;
        let fixedPixels = 0;
        let prefPixels = 0;
        let totalPrefWeight = 0;
        const drawChildren = this._getDrawChildren();
        for (const child of drawChildren) {
          const prefSize = child._getPrefSize(this.getOrientation());
          if (child._isFixed()) {
            if (prefSize !== void 0) {
              fixedPixels += prefSize;
            }
          } else {
            if (prefSize === void 0) {
              totalWeight += child.getWeight();
            } else {
              prefPixels += prefSize;
              totalPrefWeight += child.getWeight();
            }
          }
        }
        let resizePreferred = false;
        let availablePixels = pixelSize - fixedPixels - prefPixels;
        if (availablePixels < 0) {
          availablePixels = pixelSize - fixedPixels;
          resizePreferred = true;
          totalWeight += totalPrefWeight;
        }
        let totalSizeGiven = 0;
        let variableSize = 0;
        for (const child of drawChildren) {
          const prefSize = child._getPrefSize(this.getOrientation());
          if (child._isFixed()) {
            if (prefSize !== void 0) {
              child._setTempSize(prefSize);
            }
          } else {
            if (prefSize == null || resizePreferred) {
              if (totalWeight === 0) {
                child._setTempSize(0);
              } else {
                const minSize = child.getMinSize(this.getOrientation());
                const size = Math.floor(availablePixels * (child.getWeight() / totalWeight));
                child._setTempSize(Math.max(minSize, size));
              }
              variableSize += child._getTempSize();
            } else {
              child._setTempSize(prefSize);
            }
          }
          totalSizeGiven += child._getTempSize();
        }
        if (variableSize > 0) {
          while (totalSizeGiven < pixelSize) {
            for (const child of drawChildren) {
              if (!(child instanceof SplitterNode)) {
                const prefSize = child._getPrefSize(this.getOrientation());
                if (!child._isFixed() && (prefSize === void 0 || resizePreferred) && totalSizeGiven < pixelSize) {
                  child._setTempSize(child._getTempSize() + 1);
                  totalSizeGiven++;
                }
              }
            }
          }
          while (totalSizeGiven > pixelSize) {
            let changed = false;
            for (const child of drawChildren) {
              if (!(child instanceof SplitterNode)) {
                const minSize = child.getMinSize(this.getOrientation());
                const size = child._getTempSize();
                if (size > minSize && totalSizeGiven > pixelSize) {
                  child._setTempSize(child._getTempSize() - 1);
                  totalSizeGiven--;
                  changed = true;
                }
              }
            }
            if (!changed) {
              break;
            }
          }
          while (totalSizeGiven > pixelSize) {
            let changed = false;
            for (const child of drawChildren) {
              if (!(child instanceof SplitterNode)) {
                const size = child._getTempSize();
                if (size > 0 && totalSizeGiven > pixelSize) {
                  child._setTempSize(child._getTempSize() - 1);
                  totalSizeGiven--;
                  changed = true;
                }
              }
            }
            if (!changed) {
              break;
            }
          }
        }
        let p = 0;
        for (const child of drawChildren) {
          if (this.getOrientation() === Orientation.HORZ) {
            child._layout(new Rect(this._rect.x + p, this._rect.y, child._getTempSize(), this._rect.height), metrics);
          } else {
            child._layout(new Rect(this._rect.x, this._rect.y + p, this._rect.width, child._getTempSize()), metrics);
          }
          p += child._getTempSize();
        }
        return true;
      }
      /** @internal */
      _getSplitterBounds(splitterNode, useMinSize = false) {
        const pBounds = [0, 0];
        const drawChildren = this._getDrawChildren();
        const p = drawChildren.indexOf(splitterNode);
        const node1 = drawChildren[p - 1];
        const node2 = drawChildren[p + 1];
        if (this.getOrientation() === Orientation.HORZ) {
          const minSize1 = useMinSize ? node1.getMinWidth() : 0;
          const minSize2 = useMinSize ? node2.getMinWidth() : 0;
          pBounds[0] = node1.getRect().x + minSize1;
          pBounds[1] = node2.getRect().getRight() - splitterNode.getWidth() - minSize2;
        } else {
          const minSize1 = useMinSize ? node1.getMinHeight() : 0;
          const minSize2 = useMinSize ? node2.getMinHeight() : 0;
          pBounds[0] = node1.getRect().y + minSize1;
          pBounds[1] = node2.getRect().getBottom() - splitterNode.getHeight() - minSize2;
        }
        return pBounds;
      }
      /** @internal */
      _calculateSplit(splitter, splitterPos) {
        let rtn;
        const drawChildren = this._getDrawChildren();
        const p = drawChildren.indexOf(splitter);
        const pBounds = this._getSplitterBounds(splitter);
        const weightedLength = drawChildren[p - 1].getWeight() + drawChildren[p + 1].getWeight();
        const pixelWidth1 = Math.max(0, splitterPos - pBounds[0]);
        const pixelWidth2 = Math.max(0, pBounds[1] - splitterPos);
        if (pixelWidth1 + pixelWidth2 > 0) {
          const weight1 = pixelWidth1 * weightedLength / (pixelWidth1 + pixelWidth2);
          const weight2 = pixelWidth2 * weightedLength / (pixelWidth1 + pixelWidth2);
          rtn = {
            node1Id: drawChildren[p - 1].getId(),
            weight1,
            pixelWidth1,
            node2Id: drawChildren[p + 1].getId(),
            weight2,
            pixelWidth2
          };
        }
        return rtn;
      }
      /** @internal */
      _getDrawChildren() {
        if (this._dirty) {
          this._drawChildren = [];
          for (let i = 0; i < this._children.length; i++) {
            const child = this._children[i];
            if (i !== 0) {
              const newSplitter = new SplitterNode(this._model);
              newSplitter._setParent(this);
              this._drawChildren.push(newSplitter);
            }
            this._drawChildren.push(child);
          }
          this._dirty = false;
        }
        return this._drawChildren;
      }
      /** @internal */
      getMinSize(orientation) {
        if (orientation === Orientation.HORZ) {
          return this.getMinWidth();
        } else {
          return this.getMinHeight();
        }
      }
      /** @internal */
      getMinWidth() {
        return this._minWidth;
      }
      /** @internal */
      getMinHeight() {
        return this._minHeight;
      }
      /** @internal */
      calcMinSize() {
        this._minHeight = 0;
        this._minWidth = 0;
        let first = true;
        for (const child of this._children) {
          const c = child;
          if (c instanceof _RowNode) {
            c.calcMinSize();
          }
          if (this.getOrientation() === Orientation.VERT) {
            this._minHeight += c.getMinHeight();
            if (!first) {
              this._minHeight += this._model.getSplitterSize();
            }
            this._minWidth = Math.max(this._minWidth, c.getMinWidth());
          } else {
            this._minWidth += c.getMinWidth();
            if (!first) {
              this._minWidth += this._model.getSplitterSize();
            }
            this._minHeight = Math.max(this._minHeight, c.getMinHeight());
          }
          first = false;
        }
      }
      /** @internal */
      _tidy() {
        let i = 0;
        while (i < this._children.length) {
          const child = this._children[i];
          if (child instanceof _RowNode) {
            child._tidy();
            const childChildren = child.getChildren();
            if (childChildren.length === 0) {
              this._removeChild(child);
            } else if (childChildren.length === 1) {
              const subchild = childChildren[0];
              this._removeChild(child);
              if (subchild instanceof _RowNode) {
                let subChildrenTotal = 0;
                const subChildChildren = subchild.getChildren();
                for (const ssc of subChildChildren) {
                  const subsubChild = ssc;
                  subChildrenTotal += subsubChild.getWeight();
                }
                for (let j = 0; j < subChildChildren.length; j++) {
                  const subsubChild = subChildChildren[j];
                  subsubChild._setWeight(child.getWeight() * subsubChild.getWeight() / subChildrenTotal);
                  this._addChild(subsubChild, i + j);
                }
              } else {
                subchild._setWeight(child.getWeight());
                this._addChild(subchild, i);
              }
            } else {
              i++;
            }
          } else if (child instanceof TabSetNode && child.getChildren().length === 0) {
            if (child.isEnableDeleteWhenEmpty()) {
              this._removeChild(child);
              if (child === this._model.getMaximizedTabset()) {
                this._model._setMaximizedTabset(void 0);
              }
            } else {
              i++;
            }
          } else {
            i++;
          }
        }
        if (this === this._model.getRoot() && this._children.length === 0) {
          const callback = this._model._getOnCreateTabSet();
          let attrs = callback ? callback() : {};
          attrs = { ...attrs, selected: -1 };
          const child = new TabSetNode(this._model, attrs);
          this._model._setActiveTabset(child);
          this._addChild(child);
        }
      }
      /** @internal */
      canDrop(dragNode, x, y) {
        const yy = y - this._rect.y;
        const xx = x - this._rect.x;
        const w = this._rect.width;
        const h = this._rect.height;
        const margin = 10;
        const half = 50;
        let dropInfo;
        if (this._model.isEnableEdgeDock() && this._parent === void 0) {
          if (x < this._rect.x + margin && yy > h / 2 - half && yy < h / 2 + half) {
            const dockLocation = DockLocation.LEFT;
            const outlineRect = dockLocation.getDockRect(this._rect);
            outlineRect.width = outlineRect.width / 2;
            dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
          } else if (x > this._rect.getRight() - margin && yy > h / 2 - half && yy < h / 2 + half) {
            const dockLocation = DockLocation.RIGHT;
            const outlineRect = dockLocation.getDockRect(this._rect);
            outlineRect.width = outlineRect.width / 2;
            outlineRect.x += outlineRect.width;
            dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
          } else if (y < this._rect.y + margin && xx > w / 2 - half && xx < w / 2 + half) {
            const dockLocation = DockLocation.TOP;
            const outlineRect = dockLocation.getDockRect(this._rect);
            outlineRect.height = outlineRect.height / 2;
            dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
          } else if (y > this._rect.getBottom() - margin && xx > w / 2 - half && xx < w / 2 + half) {
            const dockLocation = DockLocation.BOTTOM;
            const outlineRect = dockLocation.getDockRect(this._rect);
            outlineRect.height = outlineRect.height / 2;
            outlineRect.y += outlineRect.height;
            dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
          }
          if (dropInfo !== void 0) {
            if (!dragNode._canDockInto(dragNode, dropInfo)) {
              return void 0;
            }
          }
        }
        return dropInfo;
      }
      /** @internal */
      drop(dragNode, location, index) {
        const dockLocation = location;
        const parent = dragNode.getParent();
        if (parent) {
          parent._removeChild(dragNode);
        }
        if (parent !== void 0 && parent.getType() === TabSetNode.TYPE) {
          parent._setSelected(0);
        }
        if (parent !== void 0 && parent.getType() === BorderNode.TYPE) {
          parent._setSelected(-1);
        }
        let tabSet;
        if (dragNode instanceof TabSetNode) {
          tabSet = dragNode;
        } else {
          const callback = this._model._getOnCreateTabSet();
          tabSet = new TabSetNode(this._model, callback ? callback(dragNode) : {});
          tabSet._addChild(dragNode);
        }
        let size = this._children.reduce((sum, child) => {
          return sum + child.getWeight();
        }, 0);
        if (size === 0) {
          size = 100;
        }
        tabSet._setWeight(size / 3);
        const horz = !this._model.isRootOrientationVertical();
        if (horz && dockLocation === DockLocation.LEFT || !horz && dockLocation === DockLocation.TOP) {
          this._addChild(tabSet, 0);
        } else if (horz && dockLocation === DockLocation.RIGHT || !horz && dockLocation === DockLocation.BOTTOM) {
          this._addChild(tabSet);
        } else if (horz && dockLocation === DockLocation.TOP || !horz && dockLocation === DockLocation.LEFT) {
          const vrow = new _RowNode(this._model, {});
          const hrow = new _RowNode(this._model, {});
          hrow._setWeight(75);
          tabSet._setWeight(25);
          for (const child of this._children) {
            hrow._addChild(child);
          }
          this._removeAll();
          vrow._addChild(tabSet);
          vrow._addChild(hrow);
          this._addChild(vrow);
        } else if (horz && dockLocation === DockLocation.BOTTOM || !horz && dockLocation === DockLocation.RIGHT) {
          const vrow = new _RowNode(this._model, {});
          const hrow = new _RowNode(this._model, {});
          hrow._setWeight(75);
          tabSet._setWeight(25);
          for (const child of this._children) {
            hrow._addChild(child);
          }
          this._removeAll();
          vrow._addChild(hrow);
          vrow._addChild(tabSet);
          this._addChild(vrow);
        }
        this._model._setActiveTabset(tabSet);
        this._model._tidy();
      }
      toJson() {
        const json = {};
        _RowNode._attributeDefinitions.toJson(json, this._attributes);
        json.children = [];
        for (const child of this._children) {
          json.children.push(child.toJson());
        }
        return json;
      }
      isEnableDrop() {
        return true;
      }
      /** @internal */
      _getPrefSize(orientation) {
        let prefSize = this.getWidth();
        if (orientation === Orientation.VERT) {
          prefSize = this.getHeight();
        }
        return prefSize;
      }
      /** @internal */
      _getAttributeDefinitions() {
        return _RowNode._attributeDefinitions;
      }
      /** @internal */
      _updateAttrs(json) {
        _RowNode._attributeDefinitions.update(json, this._attributes);
      }
      /** @internal */
      static getAttributeDefinitions() {
        return _RowNode._attributeDefinitions;
      }
    };
    __name$p(_RowNode, "RowNode");
    __publicField$5(_RowNode, "TYPE", "row");
    /** @internal */
    __publicField$5(_RowNode, "_attributeDefinitions", _RowNode._createAttributeDefinitions());
    let RowNode = _RowNode;

    var __defProp$o = Object.defineProperty;
    var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$o = (target, value) => __defProp$o(target, "name", { value, configurable: true });
    var __publicField$4 = (obj, key, value) => {
      __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _TabSetNode = class _TabSetNode extends Node {
      /** @internal */
      constructor(model, json) {
        super(model);
        /** @internal */
        __publicField$4(this, "_contentRect");
        /** @internal */
        __publicField$4(this, "_tabHeaderRect");
        /** @internal */
        __publicField$4(this, "_calculatedTabBarHeight");
        /** @internal */
        __publicField$4(this, "_calculatedHeaderBarHeight");
        _TabSetNode._attributeDefinitions.fromJson(json, this._attributes);
        model._addNode(this);
        this._calculatedTabBarHeight = 0;
        this._calculatedHeaderBarHeight = 0;
      }
      /** @internal */
      static _fromJson(json, model) {
        const newLayoutNode = new _TabSetNode(model, json);
        if (json.children != null) {
          for (const jsonChild of json.children) {
            const child = TabNode._fromJson(jsonChild, model);
            newLayoutNode._addChild(child);
          }
        }
        if (newLayoutNode._children.length === 0) {
          newLayoutNode._setSelected(-1);
        }
        if (json.maximized && json.maximized === true) {
          model._setMaximizedTabset(newLayoutNode);
        }
        if (json.active && json.active === true) {
          model._setActiveTabset(newLayoutNode);
        }
        return newLayoutNode;
      }
      /** @internal */
      static _createAttributeDefinitions() {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", _TabSetNode.TYPE, true).setType(Attribute.STRING).setFixed();
        attributeDefinitions.add("id", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("weight", 100).setType(Attribute.NUMBER);
        attributeDefinitions.add("width", void 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("height", void 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("selected", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("name", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("config", void 0).setType("any");
        attributeDefinitions.addInherited("enableDeleteWhenEmpty", "tabSetEnableDeleteWhenEmpty");
        attributeDefinitions.addInherited("enableDrop", "tabSetEnableDrop");
        attributeDefinitions.addInherited("enableDrag", "tabSetEnableDrag");
        attributeDefinitions.addInherited("enableDivide", "tabSetEnableDivide");
        attributeDefinitions.addInherited("enableMaximize", "tabSetEnableMaximize");
        attributeDefinitions.addInherited("enableClose", "tabSetEnableClose");
        attributeDefinitions.addInherited("classNameTabStrip", "tabSetClassNameTabStrip");
        attributeDefinitions.addInherited("classNameHeader", "tabSetClassNameHeader");
        attributeDefinitions.addInherited("enableTabStrip", "tabSetEnableTabStrip");
        attributeDefinitions.addInherited("borderInsets", "tabSetBorderInsets");
        attributeDefinitions.addInherited("marginInsets", "tabSetMarginInsets");
        attributeDefinitions.addInherited("minWidth", "tabSetMinWidth");
        attributeDefinitions.addInherited("minHeight", "tabSetMinHeight");
        attributeDefinitions.addInherited("headerHeight", "tabSetHeaderHeight");
        attributeDefinitions.addInherited("tabStripHeight", "tabSetTabStripHeight");
        attributeDefinitions.addInherited("tabLocation", "tabSetTabLocation");
        attributeDefinitions.addInherited("autoSelectTab", "tabSetAutoSelectTab").setType(Attribute.BOOLEAN);
        return attributeDefinitions;
      }
      getName() {
        return this._getAttr("name");
      }
      getSelected() {
        const selected = this._attributes.selected;
        if (selected !== void 0) {
          return selected;
        }
        return -1;
      }
      getSelectedNode() {
        const selected = this.getSelected();
        if (selected !== -1) {
          return this._children[selected];
        }
        return void 0;
      }
      getWeight() {
        return this._getAttr("weight");
      }
      getWidth() {
        return this._getAttr("width");
      }
      getMinWidth() {
        return this._getAttr("minWidth");
      }
      getHeight() {
        return this._getAttr("height");
      }
      getMinHeight() {
        return this._getAttr("minHeight");
      }
      /** @internal */
      getMinSize(orientation) {
        if (orientation === Orientation.HORZ) {
          return this.getMinWidth();
        } else {
          return this.getMinHeight();
        }
      }
      /**
       * Returns the config attribute that can be used to store node specific data that
       * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather
       * than directly, for example:
       * this.state.model.doAction(
       *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));
       */
      getConfig() {
        return this._attributes.config;
      }
      isMaximized() {
        return this._model.getMaximizedTabset() === this;
      }
      isActive() {
        return this._model.getActiveTabset() === this;
      }
      isEnableDeleteWhenEmpty() {
        return this._getAttr("enableDeleteWhenEmpty");
      }
      isEnableDrop() {
        return this._getAttr("enableDrop");
      }
      isEnableDrag() {
        return this._getAttr("enableDrag");
      }
      isEnableDivide() {
        return this._getAttr("enableDivide");
      }
      isEnableMaximize() {
        return this._getAttr("enableMaximize");
      }
      isEnableClose() {
        return this._getAttr("enableClose");
      }
      canMaximize() {
        if (this.isEnableMaximize()) {
          if (this.getModel().getMaximizedTabset() === this) {
            return true;
          }
          if (this.getParent() === this.getModel().getRoot() && this.getModel().getRoot().getChildren().length === 1) {
            return false;
          }
          return true;
        }
        return false;
      }
      isEnableTabStrip() {
        return this._getAttr("enableTabStrip");
      }
      isAutoSelectTab() {
        return this._getAttr("autoSelectTab");
      }
      getClassNameTabStrip() {
        return this._getAttr("classNameTabStrip");
      }
      getClassNameHeader() {
        return this._getAttr("classNameHeader");
      }
      /** @internal */
      calculateHeaderBarHeight(metrics) {
        const headerBarHeight = this._getAttr("headerHeight");
        if (headerBarHeight !== 0) {
          this._calculatedHeaderBarHeight = headerBarHeight;
        } else {
          this._calculatedHeaderBarHeight = metrics.headerBarSize;
        }
      }
      /** @internal */
      calculateTabBarHeight(metrics) {
        const tabBarHeight = this._getAttr("tabStripHeight");
        if (tabBarHeight !== 0) {
          this._calculatedTabBarHeight = tabBarHeight;
        } else {
          this._calculatedTabBarHeight = metrics.tabBarSize;
        }
      }
      getHeaderHeight() {
        return this._calculatedHeaderBarHeight;
      }
      getTabStripHeight() {
        return this._calculatedTabBarHeight;
      }
      getTabLocation() {
        return this._getAttr("tabLocation");
      }
      /** @internal */
      _setWeight(weight) {
        this._attributes.weight = weight;
      }
      /** @internal */
      _setSelected(index) {
        this._attributes.selected = index;
      }
      /** @internal */
      canDrop(dragNode, x, y) {
        let dropInfo;
        if (dragNode === this) {
          const dockLocation = DockLocation.CENTER;
          const outlineRect = this._tabHeaderRect;
          dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
        } else if (this._contentRect.contains(x, y)) {
          let dockLocation = DockLocation.CENTER;
          if (this._model.getMaximizedTabset() === void 0) {
            dockLocation = DockLocation.getLocation(this._contentRect, x, y);
          }
          const outlineRect = dockLocation.getDockRect(this._rect);
          dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
        } else if (this._tabHeaderRect != null && this._tabHeaderRect.contains(x, y)) {
          let r;
          let yy;
          let h;
          if (this._children.length === 0) {
            r = this._tabHeaderRect.clone();
            yy = r.y + 3;
            h = r.height - 4;
            r.width = 2;
          } else {
            let child = this._children[0];
            r = child.getTabRect();
            yy = r.y;
            h = r.height;
            let p = this._tabHeaderRect.x;
            let childCenter = 0;
            for (let i = 0; i < this._children.length; i++) {
              child = this._children[i];
              r = child.getTabRect();
              childCenter = r.x + r.width / 2;
              if (x >= p && x < childCenter) {
                const dockLocation = DockLocation.CENTER;
                const outlineRect = new Rect(r.x - 2, yy, 3, h);
                dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                break;
              }
              p = childCenter;
            }
          }
          if (dropInfo == null) {
            const dockLocation = DockLocation.CENTER;
            const outlineRect = new Rect(r.getRight() - 2, yy, 3, h);
            dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
          }
        }
        if (!dragNode._canDockInto(dragNode, dropInfo)) {
          return void 0;
        }
        return dropInfo;
      }
      /** @internal */
      _layout(rect, metrics) {
        this.calculateHeaderBarHeight(metrics);
        this.calculateTabBarHeight(metrics);
        if (this.isMaximized()) {
          rect = this._model.getRoot().getRect();
        }
        rect = rect.removeInsets(this._getAttr("marginInsets"));
        this._rect = rect;
        rect = rect.removeInsets(this._getAttr("borderInsets"));
        const showHeader = this.getName() !== void 0;
        let y = 0;
        let h = 0;
        if (showHeader) {
          y += this._calculatedHeaderBarHeight;
          h += this._calculatedHeaderBarHeight;
        }
        if (this.isEnableTabStrip()) {
          if (this.getTabLocation() === "top") {
            this._tabHeaderRect = new Rect(rect.x, rect.y + y, rect.width, this._calculatedTabBarHeight);
          } else {
            this._tabHeaderRect = new Rect(rect.x, rect.y + rect.height - this._calculatedTabBarHeight, rect.width, this._calculatedTabBarHeight);
          }
          h += this._calculatedTabBarHeight;
          if (this.getTabLocation() === "top") {
            y += this._calculatedTabBarHeight;
          }
        }
        this._contentRect = new Rect(rect.x, rect.y + y, rect.width, rect.height - h);
        for (let i = 0; i < this._children.length; i++) {
          const child = this._children[i];
          child._layout(this._contentRect, metrics);
          child._setVisible(i === this.getSelected());
        }
      }
      /** @internal */
      _delete() {
        this._parent._removeChild(this);
      }
      /** @internal */
      _remove(node) {
        const removedIndex = this._removeChild(node);
        this._model._tidy();
        adjustSelectedIndex(this, removedIndex);
      }
      /** @internal */
      drop(dragNode, location, index, select) {
        const dockLocation = location;
        if (this === dragNode) {
          return;
        }
        let dragParent = dragNode.getParent();
        let fromIndex = 0;
        if (dragParent !== void 0) {
          fromIndex = dragParent._removeChild(dragNode);
          if (dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {
            dragParent._setSelected(-1);
          } else {
            adjustSelectedIndex(dragParent, fromIndex);
          }
        }
        if (dragNode.getType() === TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {
          index--;
        }
        if (dockLocation === DockLocation.CENTER) {
          let insertPos = index;
          if (insertPos === -1) {
            insertPos = this._children.length;
          }
          if (dragNode.getType() === TabNode.TYPE) {
            this._addChild(dragNode, insertPos);
            if (select || select !== false && this.isAutoSelectTab()) {
              this._setSelected(insertPos);
            }
          } else {
            for (let i = 0; i < dragNode.getChildren().length; i++) {
              const child = dragNode.getChildren()[i];
              this._addChild(child, insertPos);
              insertPos++;
            }
            if (this.getSelected() === -1 && this._children.length > 0) {
              this._setSelected(0);
            }
          }
          this._model._setActiveTabset(this);
        } else {
          let tabSet;
          if (dragNode instanceof TabNode) {
            const callback = this._model._getOnCreateTabSet();
            tabSet = new _TabSetNode(this._model, callback ? callback(dragNode) : {});
            tabSet._addChild(dragNode);
            dragParent = tabSet;
          } else {
            tabSet = dragNode;
          }
          const parentRow = this._parent;
          const pos = parentRow.getChildren().indexOf(this);
          if (parentRow.getOrientation() === dockLocation._orientation) {
            tabSet._setWeight(this.getWeight() / 2);
            this._setWeight(this.getWeight() / 2);
            parentRow._addChild(tabSet, pos + dockLocation._indexPlus);
          } else {
            const newRow = new RowNode(this._model, {});
            newRow._setWeight(this.getWeight());
            newRow._addChild(this);
            this._setWeight(50);
            tabSet._setWeight(50);
            newRow._addChild(tabSet, dockLocation._indexPlus);
            parentRow._removeChild(this);
            parentRow._addChild(newRow, pos);
          }
          this._model._setActiveTabset(tabSet);
        }
        this._model._tidy();
      }
      toJson() {
        const json = {};
        _TabSetNode._attributeDefinitions.toJson(json, this._attributes);
        json.children = this._children.map((child) => child.toJson());
        if (this.isActive()) {
          json.active = true;
        }
        if (this.isMaximized()) {
          json.maximized = true;
        }
        return json;
      }
      /** @internal */
      _updateAttrs(json) {
        _TabSetNode._attributeDefinitions.update(json, this._attributes);
      }
      /** @internal */
      _getAttributeDefinitions() {
        return _TabSetNode._attributeDefinitions;
      }
      /** @internal */
      _getPrefSize(orientation) {
        let prefSize = this.getWidth();
        if (orientation === Orientation.VERT) {
          prefSize = this.getHeight();
        }
        return prefSize;
      }
      /** @internal */
      static getAttributeDefinitions() {
        return _TabSetNode._attributeDefinitions;
      }
    };
    __name$o(_TabSetNode, "TabSetNode");
    __publicField$4(_TabSetNode, "TYPE", "tabset");
    /** @internal */
    __publicField$4(_TabSetNode, "_attributeDefinitions", _TabSetNode._createAttributeDefinitions());
    let TabSetNode = _TabSetNode;

    var __defProp$n = Object.defineProperty;
    var __name$n = (target, value) => __defProp$n(target, "name", { value, configurable: true });
    function adjustSelectedIndexAfterFloat(node) {
      const parent = node.getParent();
      if (parent !== null) {
        if (parent instanceof TabSetNode) {
          let found = false;
          let newSelected = 0;
          const children = parent.getChildren();
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child === node) {
              found = true;
            } else {
              if (!child.isFloating()) {
                newSelected = i;
                if (found)
                  break;
              }
            }
          }
          parent._setSelected(newSelected);
        } else if (parent instanceof BorderNode) {
          parent._setSelected(-1);
        }
      }
    }
    __name$n(adjustSelectedIndexAfterFloat, "adjustSelectedIndexAfterFloat");
    function adjustSelectedIndexAfterDock(node) {
      const parent = node.getParent();
      if (parent !== null && (parent instanceof TabSetNode || parent instanceof BorderNode)) {
        const children = parent.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child === node) {
            parent._setSelected(i);
            return;
          }
        }
      }
    }
    __name$n(adjustSelectedIndexAfterDock, "adjustSelectedIndexAfterDock");
    function adjustSelectedIndex(parent, removedIndex) {
      if (parent !== void 0 && (parent.getType() === TabSetNode.TYPE || parent.getType() === BorderNode.TYPE)) {
        const selectedIndex = parent.getSelected();
        if (selectedIndex !== -1) {
          if (removedIndex === selectedIndex && parent.getChildren().length > 0) {
            if (removedIndex >= parent.getChildren().length) {
              parent._setSelected(parent.getChildren().length - 1);
            }
          } else if (removedIndex < selectedIndex) {
            parent._setSelected(selectedIndex - 1);
          } else if (removedIndex > selectedIndex) ; else {
            parent._setSelected(-1);
          }
        }
      }
    }
    __name$n(adjustSelectedIndex, "adjustSelectedIndex");
    function randomUUID() {
      return ("10000000-1000-4000-8000" + -1e11).replace(
        /[018]/g,
        (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    __name$n(randomUUID, "randomUUID");

    var __defProp$m = Object.defineProperty;
    var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$m = (target, value) => __defProp$m(target, "name", { value, configurable: true });
    var __publicField$3 = (obj, key, value) => {
      __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _BorderNode = class _BorderNode extends Node {
      /** @internal */
      constructor(location, json, model) {
        super(model);
        /** @internal */
        __publicField$3(this, "_contentRect");
        /** @internal */
        __publicField$3(this, "_tabHeaderRect");
        /** @internal */
        __publicField$3(this, "_location");
        /** @internal */
        __publicField$3(this, "_drawChildren");
        /** @internal */
        __publicField$3(this, "_adjustedSize", 0);
        /** @internal */
        __publicField$3(this, "_calculatedBorderBarSize", 0);
        this._location = location;
        this._drawChildren = [];
        this._attributes.id = `border_${location.getName()}`;
        _BorderNode._attributeDefinitions.fromJson(json, this._attributes);
        model._addNode(this);
      }
      /** @internal */
      static _fromJson(json, model) {
        const location = DockLocation.getByName(json.location);
        const border = new _BorderNode(location, json, model);
        if (json.children) {
          border._children = json.children.map((jsonChild) => {
            const child = TabNode._fromJson(jsonChild, model);
            child._setParent(border);
            return child;
          });
        }
        return border;
      }
      /** @internal */
      static _createAttributeDefinitions() {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", _BorderNode.TYPE, true).setType(Attribute.STRING).setFixed();
        attributeDefinitions.add("selected", -1).setType(Attribute.NUMBER);
        attributeDefinitions.add("show", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("config", void 0).setType("any");
        attributeDefinitions.addInherited("barSize", "borderBarSize").setType(Attribute.NUMBER);
        attributeDefinitions.addInherited("enableDrop", "borderEnableDrop").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("className", "borderClassName").setType(Attribute.STRING);
        attributeDefinitions.addInherited("autoSelectTabWhenOpen", "borderAutoSelectTabWhenOpen").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("autoSelectTabWhenClosed", "borderAutoSelectTabWhenClosed").setType(Attribute.BOOLEAN);
        attributeDefinitions.addInherited("size", "borderSize").setType(Attribute.NUMBER);
        attributeDefinitions.addInherited("minSize", "borderMinSize").setType(Attribute.NUMBER);
        attributeDefinitions.addInherited("enableAutoHide", "borderEnableAutoHide").setType(Attribute.BOOLEAN);
        return attributeDefinitions;
      }
      getLocation() {
        return this._location;
      }
      getTabHeaderRect() {
        return this._tabHeaderRect;
      }
      getRect() {
        return this._tabHeaderRect;
      }
      getContentRect() {
        return this._contentRect;
      }
      isEnableDrop() {
        return this._getAttr("enableDrop");
      }
      isAutoSelectTab(whenOpen) {
        if (whenOpen == null) {
          whenOpen = this.getSelected() !== -1;
        }
        if (whenOpen) {
          return this._getAttr("autoSelectTabWhenOpen");
        } else {
          return this._getAttr("autoSelectTabWhenClosed");
        }
      }
      getClassName() {
        return this._getAttr("className");
      }
      /** @internal */
      calcBorderBarSize(metrics) {
        const barSize = this._getAttr("barSize");
        if (barSize !== 0) {
          this._calculatedBorderBarSize = barSize;
        } else {
          this._calculatedBorderBarSize = metrics.borderBarSize;
        }
      }
      getBorderBarSize() {
        return this._calculatedBorderBarSize;
      }
      getSize() {
        const defaultSize = this._getAttr("size");
        const selected = this.getSelected();
        if (selected === -1) {
          return defaultSize;
        } else {
          const tabNode = this._children[selected];
          const tabBorderSize = this._location._orientation === Orientation.HORZ ? tabNode._getAttr("borderWidth") : tabNode._getAttr("borderHeight");
          if (tabBorderSize === -1) {
            return defaultSize;
          } else {
            return tabBorderSize;
          }
        }
      }
      getMinSize() {
        return this._getAttr("minSize");
      }
      getSelected() {
        return this._attributes.selected;
      }
      getSelectedNode() {
        if (this.getSelected() !== -1) {
          return this._children[this.getSelected()];
        }
        return void 0;
      }
      getOrientation() {
        return this._location.getOrientation();
      }
      /**
       * Returns the config attribute that can be used to store node specific data that
       * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather
       * than directly, for example:
       * this.state.model.doAction(
       *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));
       */
      getConfig() {
        return this._attributes.config;
      }
      isMaximized() {
        return false;
      }
      isShowing() {
        const show = this._attributes.show;
        if (show) {
          if (this._model._getShowHiddenBorder() !== this._location && this.isAutoHide() && this._children.length === 0) {
            return false;
          }
          return true;
        } else {
          return false;
        }
      }
      isAutoHide() {
        return this._getAttr("enableAutoHide");
      }
      /** @internal */
      _setSelected(index) {
        this._attributes.selected = index;
      }
      /** @internal */
      _setSize(pos) {
        const selected = this.getSelected();
        if (selected === -1) {
          this._attributes.size = pos;
        } else {
          const tabNode = this._children[selected];
          const tabBorderSize = this._location._orientation === Orientation.HORZ ? tabNode._getAttr("borderWidth") : tabNode._getAttr("borderHeight");
          if (tabBorderSize === -1) {
            this._attributes.size = pos;
          } else {
            if (this._location._orientation === Orientation.HORZ) {
              tabNode._setBorderWidth(pos);
            } else {
              tabNode._setBorderHeight(pos);
            }
          }
        }
      }
      /** @internal */
      _updateAttrs(json) {
        _BorderNode._attributeDefinitions.update(json, this._attributes);
      }
      /** @internal */
      _getDrawChildren() {
        return this._drawChildren;
      }
      /** @internal */
      _setAdjustedSize(size) {
        this._adjustedSize = size;
      }
      /** @internal */
      _getAdjustedSize() {
        return this._adjustedSize;
      }
      /** @internal */
      _layoutBorderOuter(outer, metrics) {
        this.calcBorderBarSize(metrics);
        const split1 = this._location.split(outer, this.getBorderBarSize());
        this._tabHeaderRect = split1.start;
        return split1.end;
      }
      /** @internal */
      _layoutBorderInner(inner, metrics) {
        this._drawChildren = [];
        const location = this._location;
        const split1 = location.split(inner, this._adjustedSize + this._model.getSplitterSize());
        const split2 = location.reflect().split(split1.start, this._model.getSplitterSize());
        this._contentRect = split2.end;
        for (let i = 0; i < this._children.length; i++) {
          const child = this._children[i];
          child._layout(this._contentRect, metrics);
          child._setVisible(i === this.getSelected());
          this._drawChildren.push(child);
        }
        if (this.getSelected() === -1) {
          return inner;
        } else {
          const newSplitter = new SplitterNode(this._model);
          newSplitter._setParent(this);
          newSplitter._setRect(split2.start);
          this._drawChildren.push(newSplitter);
          return split1.end;
        }
      }
      /** @internal */
      _remove(node) {
        const removedIndex = this._removeChild(node);
        if (this.getSelected() !== -1) {
          adjustSelectedIndex(this, removedIndex);
        }
      }
      /** @internal */
      canDrop(dragNode, x, y) {
        if (dragNode.getType() !== TabNode.TYPE) {
          return void 0;
        }
        let dropInfo;
        const dockLocation = DockLocation.CENTER;
        if (this._tabHeaderRect.contains(x, y)) {
          if (this._location._orientation === Orientation.VERT) {
            if (this._children.length > 0) {
              let child = this._children[0];
              let childRect = child.getTabRect();
              const childY = childRect.y;
              const childHeight = childRect.height;
              let pos = this._tabHeaderRect.x;
              let childCenter = 0;
              for (let i = 0; i < this._children.length; i++) {
                child = this._children[i];
                childRect = child.getTabRect();
                childCenter = childRect.x + childRect.width / 2;
                if (x >= pos && x < childCenter) {
                  const outlineRect = new Rect(childRect.x - 2, childY, 3, childHeight);
                  dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                  break;
                }
                pos = childCenter;
              }
              if (dropInfo == null) {
                const outlineRect = new Rect(childRect.getRight() - 2, childY, 3, childHeight);
                dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
              }
            } else {
              const outlineRect = new Rect(this._tabHeaderRect.x + 1, this._tabHeaderRect.y + 2, 3, 18);
              dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
            }
          } else {
            if (this._children.length > 0) {
              let child = this._children[0];
              let childRect = child.getTabRect();
              const childX = childRect.x;
              const childWidth = childRect.width;
              let pos = this._tabHeaderRect.y;
              let childCenter = 0;
              for (let i = 0; i < this._children.length; i++) {
                child = this._children[i];
                childRect = child.getTabRect();
                childCenter = childRect.y + childRect.height / 2;
                if (y >= pos && y < childCenter) {
                  const outlineRect = new Rect(childX, childRect.y - 2, childWidth, 3);
                  dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                  break;
                }
                pos = childCenter;
              }
              if (dropInfo == null) {
                const outlineRect = new Rect(childX, childRect.getBottom() - 2, childWidth, 3);
                dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
              }
            } else {
              const outlineRect = new Rect(this._tabHeaderRect.x + 2, this._tabHeaderRect.y + 1, 18, 3);
              dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
            }
          }
          if (!dragNode._canDockInto(dragNode, dropInfo)) {
            return void 0;
          }
        } else if (this.getSelected() !== -1 && this._contentRect.contains(x, y)) {
          const outlineRect = this._contentRect;
          dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
          if (!dragNode._canDockInto(dragNode, dropInfo)) {
            return void 0;
          }
        }
        return dropInfo;
      }
      /** @internal */
      drop(dragNode, location, index, select) {
        let fromIndex = 0;
        const dragParent = dragNode.getParent();
        if (dragParent !== void 0) {
          fromIndex = dragParent._removeChild(dragNode);
          if (dragParent !== this && dragParent instanceof _BorderNode && dragParent.getSelected() === fromIndex) {
            dragParent._setSelected(-1);
          } else {
            adjustSelectedIndex(dragParent, fromIndex);
          }
        }
        if (dragNode.getType() === TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {
          index--;
        }
        let insertPos = index;
        if (insertPos === -1) {
          insertPos = this._children.length;
        }
        if (dragNode.getType() === TabNode.TYPE) {
          this._addChild(dragNode, insertPos);
        }
        if (select || select !== false && this.isAutoSelectTab()) {
          this._setSelected(insertPos);
        }
        this._model._tidy();
      }
      toJson() {
        const json = {};
        _BorderNode._attributeDefinitions.toJson(json, this._attributes);
        json.location = this._location.getName();
        json.children = this._children.map((child) => child.toJson());
        return json;
      }
      /** @internal */
      _getSplitterBounds(splitter, useMinSize = false) {
        const pBounds = [0, 0];
        const minSize = useMinSize ? this.getMinSize() : 0;
        const outerRect = this._model._getOuterInnerRects().outer;
        const innerRect = this._model._getOuterInnerRects().inner;
        const rootRow = this._model.getRoot();
        if (this._location === DockLocation.TOP) {
          pBounds[0] = outerRect.y + minSize;
          pBounds[1] = Math.max(pBounds[0], innerRect.getBottom() - splitter.getHeight() - rootRow.getMinHeight());
        } else if (this._location === DockLocation.LEFT) {
          pBounds[0] = outerRect.x + minSize;
          pBounds[1] = Math.max(pBounds[0], innerRect.getRight() - splitter.getWidth() - rootRow.getMinWidth());
        } else if (this._location === DockLocation.BOTTOM) {
          pBounds[1] = outerRect.getBottom() - splitter.getHeight() - minSize;
          pBounds[0] = Math.min(pBounds[1], innerRect.y + rootRow.getMinHeight());
        } else if (this._location === DockLocation.RIGHT) {
          pBounds[1] = outerRect.getRight() - splitter.getWidth() - minSize;
          pBounds[0] = Math.min(pBounds[1], innerRect.x + rootRow.getMinWidth());
        }
        return pBounds;
      }
      /** @internal */
      _calculateSplit(splitter, splitterPos) {
        const pBounds = this._getSplitterBounds(splitter);
        if (this._location === DockLocation.BOTTOM || this._location === DockLocation.RIGHT) {
          return Math.max(0, pBounds[1] - splitterPos);
        } else {
          return Math.max(0, splitterPos - pBounds[0]);
        }
      }
      /** @internal */
      _getAttributeDefinitions() {
        return _BorderNode._attributeDefinitions;
      }
      /** @internal */
      static getAttributeDefinitions() {
        return _BorderNode._attributeDefinitions;
      }
    };
    __name$m(_BorderNode, "BorderNode");
    __publicField$3(_BorderNode, "TYPE", "border");
    /** @internal */
    __publicField$3(_BorderNode, "_attributeDefinitions", _BorderNode._createAttributeDefinitions());
    let BorderNode = _BorderNode;

    var I18nLabel = /* @__PURE__ */ ((I18nLabel2) => {
      I18nLabel2["Close_Tab"] = "Close";
      I18nLabel2["Close_Tabset"] = "Close tabset";
      I18nLabel2["Move_Tab"] = "Move: ";
      I18nLabel2["Move_Tabset"] = "Move tabset";
      I18nLabel2["Maximize"] = "Maximize tabset";
      I18nLabel2["Restore"] = "Restore tabset";
      I18nLabel2["Float_Tab"] = "Show selected tab in floating window";
      I18nLabel2["Overflow_Menu_Tooltip"] = "Hidden tabs";
      I18nLabel2["Floating_Window_Message"] = "This panel is shown in a floating window";
      I18nLabel2["Floating_Window_Show_Window"] = "Show window";
      I18nLabel2["Floating_Window_Dock_Window"] = "Dock window";
      I18nLabel2["Error_rendering_component"] = "Error rendering component";
      return I18nLabel2;
    })(I18nLabel || {});

    var ICloseType = /* @__PURE__ */ ((ICloseType2) => {
      ICloseType2[ICloseType2["Visible"] = 1] = "Visible";
      ICloseType2[ICloseType2["Always"] = 2] = "Always";
      ICloseType2[ICloseType2["Selected"] = 3] = "Selected";
      return ICloseType2;
    })(ICloseType || {});

    var __defProp$l = Object.defineProperty;
    var __name$l = (target, value) => __defProp$l(target, "name", { value, configurable: true });
    function getRenderStateEx(layout, node, iconFactory, titleFactory) {
      let leadingContent = iconFactory ? iconFactory(node) : void 0;
      let titleContent = node.getName();
      let name = node.getName();
      function isTitleObject(obj) {
        return obj.titleContent !== void 0;
      }
      __name$l(isTitleObject, "isTitleObject");
      if (titleFactory !== void 0) {
        const titleObj = titleFactory(node);
        if (titleObj !== void 0) {
          if (typeof titleObj === "string") {
            titleContent = titleObj;
            name = titleObj;
          } else if (isTitleObject(titleObj)) {
            titleContent = titleObj.titleContent;
            name = titleObj.name;
          } else {
            titleContent = titleObj;
          }
        }
      }
      if (leadingContent === void 0 && node.getIcon() !== void 0) {
        leadingContent = /* @__PURE__ */ wp.element.createElement("img", { style: { width: "1em", height: "1em" }, src: node.getIcon(), alt: "leadingContent" });
      }
      let buttons = [];
      const renderState = { leading: leadingContent, content: titleContent, name, buttons };
      layout.customizeTab(node, renderState);
      node._setRenderedName(renderState.name);
      return renderState;
    }
    __name$l(getRenderStateEx, "getRenderStateEx");
    function hideElement(style, useVisibility) {
      if (useVisibility) {
        style.visibility = "hidden";
      } else {
        style.display = "none";
      }
    }
    __name$l(hideElement, "hideElement");
    function isAuxMouseEvent(event) {
      let auxEvent = false;
      if (event.nativeEvent instanceof MouseEvent) {
        if (event.nativeEvent.button !== 0 || event.ctrlKey || event.altKey || event.metaKey || event.shiftKey) {
          auxEvent = true;
        }
      }
      return auxEvent;
    }
    __name$l(isAuxMouseEvent, "isAuxMouseEvent");

    var __defProp$k = Object.defineProperty;
    var __name$k = (target, value) => __defProp$k(target, "name", { value, configurable: true });
    const BorderButton = /* @__PURE__ */ __name$k((props) => {
      const { layout, node, selected, border, iconFactory, titleFactory, icons, path } = props;
      const selfRef = wp.element.useRef(null);
      const contentRef = wp.element.useRef(null);
      const onMouseDown = /* @__PURE__ */ __name$k((event) => {
        if (!isAuxMouseEvent(event) && !layout.getEditingTab()) {
          layout.dragStart(event, void 0, node, node.isEnableDrag(), onClick, onDoubleClick);
        }
      }, "onMouseDown");
      const onAuxMouseClick = /* @__PURE__ */ __name$k((event) => {
        if (isAuxMouseEvent(event)) {
          layout.auxMouseClick(node, event);
        }
      }, "onAuxMouseClick");
      const onContextMenu = /* @__PURE__ */ __name$k((event) => {
        layout.showContextMenu(node, event);
      }, "onContextMenu");
      const onClick = /* @__PURE__ */ __name$k(() => {
        layout.doAction(Actions.selectTab(node.getId()));
      }, "onClick");
      const onDoubleClick = /* @__PURE__ */ __name$k((event) => {
      }, "onDoubleClick");
      const isClosable = /* @__PURE__ */ __name$k(() => {
        const closeType = node.getCloseType();
        if (selected || closeType === ICloseType.Always) {
          return true;
        }
        if (closeType === ICloseType.Visible) {
          if (window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches) {
            return true;
          }
        }
        return false;
      }, "isClosable");
      const onClose = /* @__PURE__ */ __name$k((event) => {
        if (isClosable()) {
          layout.doAction(Actions.deleteTab(node.getId()));
        } else {
          onClick();
        }
      }, "onClose");
      const onCloseMouseDown = /* @__PURE__ */ __name$k((event) => {
        event.stopPropagation();
      }, "onCloseMouseDown");
      wp.element.useLayoutEffect(() => {
        updateRect();
        if (layout.getEditingTab() === node) {
          contentRef.current.select();
        }
      });
      const updateRect = /* @__PURE__ */ __name$k(() => {
        const layoutRect = layout.getDomRect();
        const r = selfRef.current.getBoundingClientRect();
        node._setTabRect(new Rect(r.left - layoutRect.left, r.top - layoutRect.top, r.width, r.height));
      }, "updateRect");
      const onTextBoxMouseDown = /* @__PURE__ */ __name$k((event) => {
        event.stopPropagation();
      }, "onTextBoxMouseDown");
      const onTextBoxKeyPress = /* @__PURE__ */ __name$k((event) => {
        if (event.keyCode === 27) {
          layout.setEditingTab(void 0);
        } else if (event.keyCode === 13) {
          layout.setEditingTab(void 0);
          layout.doAction(Actions.renameTab(node.getId(), event.target.value));
        }
      }, "onTextBoxKeyPress");
      const cm = layout.getClassName;
      let classNames = cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_ + border);
      if (selected) {
        classNames += " " + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON__SELECTED);
      } else {
        classNames += " " + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON__UNSELECTED);
      }
      if (node.getClassName() !== void 0) {
        classNames += " " + node.getClassName();
      }
      const renderState = getRenderStateEx(layout, node, iconFactory, titleFactory);
      let content = renderState.content ? /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_CONTENT) }, renderState.content) : null;
      const leading = renderState.leading ? /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_LEADING) }, renderState.leading) : null;
      if (layout.getEditingTab() === node) {
        content = /* @__PURE__ */ wp.element.createElement(
          "input",
          {
            ref: contentRef,
            className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX),
            "data-layout-path": path + "/textbox",
            type: "text",
            autoFocus: true,
            defaultValue: node.getName(),
            onKeyDown: onTextBoxKeyPress,
            onMouseDown: onTextBoxMouseDown,
            onTouchStart: onTextBoxMouseDown
          }
        );
      }
      if (node.isEnableClose()) {
        const closeTitle = layout.i18nName(I18nLabel.Close_Tab);
        renderState.buttons.push(
          /* @__PURE__ */ wp.element.createElement(
            "div",
            {
              key: "close",
              "data-layout-path": path + "/button/close",
              title: closeTitle,
              className: cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_TRAILING),
              onMouseDown: onCloseMouseDown,
              onClick: onClose,
              onTouchStart: onCloseMouseDown
            },
            typeof icons.close === "function" ? icons.close(node) : icons.close
          )
        );
      }
      return /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          ref: selfRef,
          "data-layout-path": path,
          className: classNames,
          onMouseDown,
          onClick: onAuxMouseClick,
          onAuxClick: onAuxMouseClick,
          onContextMenu,
          onTouchStart: onMouseDown,
          title: node.getHelpText()
        },
        leading,
        content,
        renderState.buttons
      );
    }, "BorderButton");

    var __defProp$j = Object.defineProperty;
    var __name$j = (target, value) => __defProp$j(target, "name", { value, configurable: true });
    const TabButtonStamp = /* @__PURE__ */ __name$j((props) => {
      const { layout, node, iconFactory, titleFactory } = props;
      const selfRef = wp.element.useRef(null);
      const cm = layout.getClassName;
      let classNames = cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_STAMP);
      const renderState = getRenderStateEx(layout, node, iconFactory, titleFactory);
      let content = renderState.content ? /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT) }, renderState.content) : node._getNameForOverflowMenu();
      const leading = renderState.leading ? /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING) }, renderState.leading) : null;
      return /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          ref: selfRef,
          className: classNames,
          title: node.getHelpText()
        },
        leading,
        content
      );
    }, "TabButtonStamp");

    var __defProp$i = Object.defineProperty;
    var __name$i = (target, value) => __defProp$i(target, "name", { value, configurable: true });
    function showPopup(triggerElement, items, onSelect, layout, iconFactory, titleFactory) {
      const layoutDiv = layout.getRootDiv();
      const classNameMapper = layout.getClassName;
      const currentDocument = triggerElement.ownerDocument;
      const triggerRect = triggerElement.getBoundingClientRect();
      const layoutRect = layoutDiv.getBoundingClientRect();
      const elm = currentDocument.createElement("div");
      elm.className = classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU_CONTAINER);
      if (triggerRect.left < layoutRect.left + layoutRect.width / 2) {
        elm.style.left = triggerRect.left - layoutRect.left + "px";
      } else {
        elm.style.right = layoutRect.right - triggerRect.right + "px";
      }
      if (triggerRect.top < layoutRect.top + layoutRect.height / 2) {
        elm.style.top = triggerRect.top - layoutRect.top + "px";
      } else {
        elm.style.bottom = layoutRect.bottom - triggerRect.bottom + "px";
      }
      DragDrop.instance.addGlass(() => onHide());
      DragDrop.instance.setGlassCursorOverride("default");
      layoutDiv.appendChild(elm);
      const onHide = /* @__PURE__ */ __name$i(() => {
        layout.hidePortal();
        DragDrop.instance.hideGlass();
        layoutDiv.removeChild(elm);
        elm.removeEventListener("mousedown", onElementMouseDown);
        currentDocument.removeEventListener("mousedown", onDocMouseDown);
      }, "onHide");
      const onElementMouseDown = /* @__PURE__ */ __name$i((event) => {
        event.stopPropagation();
      }, "onElementMouseDown");
      const onDocMouseDown = /* @__PURE__ */ __name$i((event) => {
        onHide();
      }, "onDocMouseDown");
      elm.addEventListener("mousedown", onElementMouseDown);
      currentDocument.addEventListener("mousedown", onDocMouseDown);
      layout.showPortal(/* @__PURE__ */ wp.element.createElement(
        PopupMenu,
        {
          currentDocument,
          onSelect,
          onHide,
          items,
          classNameMapper,
          layout,
          iconFactory,
          titleFactory
        }
      ), elm);
    }
    __name$i(showPopup, "showPopup");
    const PopupMenu = /* @__PURE__ */ __name$i((props) => {
      const { items, onHide, onSelect, classNameMapper, layout, iconFactory, titleFactory } = props;
      const onItemClick = /* @__PURE__ */ __name$i((item, event) => {
        onSelect(item);
        onHide();
        event.stopPropagation();
      }, "onItemClick");
      const itemElements = items.map((item, i) => /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          key: item.index,
          className: classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU_ITEM),
          "data-layout-path": "/popup-menu/tb" + i,
          onClick: (event) => onItemClick(item, event),
          title: item.node.getHelpText()
        },
        item.node.getModel().isLegacyOverflowMenu() ? item.node._getNameForOverflowMenu() : /* @__PURE__ */ wp.element.createElement(
          TabButtonStamp,
          {
            node: item.node,
            layout,
            iconFactory,
            titleFactory
          }
        )
      ));
      return /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          className: classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU),
          "data-layout-path": "/popup-menu"
        },
        itemElements
      );
    }, "PopupMenu");

    var __defProp$h = Object.defineProperty;
    var __name$h = (target, value) => __defProp$h(target, "name", { value, configurable: true });
    const useTabOverflow = /* @__PURE__ */ __name$h((node, orientation, toolbarRef, stickyButtonsRef) => {
      const firstRender = wp.element.useRef(true);
      const tabsTruncated = wp.element.useRef(false);
      const lastRect = wp.element.useRef(new Rect(0, 0, 0, 0));
      const selfRef = wp.element.useRef(null);
      const [position, setPosition] = wp.element.useState(0);
      const userControlledLeft = wp.element.useRef(false);
      const [hiddenTabs, setHiddenTabs] = wp.element.useState([]);
      const lastHiddenCount = wp.element.useRef(0);
      wp.element.useLayoutEffect(() => {
        userControlledLeft.current = false;
      }, [node.getSelectedNode(), node.getRect().width, node.getRect().height]);
      wp.element.useLayoutEffect(() => {
        updateVisibleTabs();
      });
      wp.element.useEffect(() => {
        const instance = selfRef.current;
        instance.addEventListener("wheel", onWheel, { passive: false });
        return () => {
          instance.removeEventListener("wheel", onWheel);
        };
      }, []);
      const onWheel = /* @__PURE__ */ __name$h((event) => {
        event.preventDefault();
      }, "onWheel");
      const getNear = /* @__PURE__ */ __name$h((rect) => {
        if (orientation === Orientation.HORZ) {
          return rect.x;
        } else {
          return rect.y;
        }
      }, "getNear");
      const getFar = /* @__PURE__ */ __name$h((rect) => {
        if (orientation === Orientation.HORZ) {
          return rect.getRight();
        } else {
          return rect.getBottom();
        }
      }, "getFar");
      const getSize = /* @__PURE__ */ __name$h((rect) => {
        if (orientation === Orientation.HORZ) {
          return rect.width;
        } else {
          return rect.height;
        }
      }, "getSize");
      const updateVisibleTabs = /* @__PURE__ */ __name$h(() => {
        const tabMargin = 2;
        if (firstRender.current === true) {
          tabsTruncated.current = false;
        }
        const nodeRect = node instanceof TabSetNode ? node.getRect() : node.getTabHeaderRect();
        let lastChild = node.getChildren()[node.getChildren().length - 1];
        const stickyButtonsSize = stickyButtonsRef.current === null ? 0 : getSize(stickyButtonsRef.current.getBoundingClientRect());
        if (firstRender.current === true || lastHiddenCount.current === 0 && hiddenTabs.length !== 0 || nodeRect.width !== lastRect.current.width || // incase rect changed between first render and second
        nodeRect.height !== lastRect.current.height) {
          lastHiddenCount.current = hiddenTabs.length;
          lastRect.current = nodeRect;
          const enabled = node instanceof TabSetNode ? node.isEnableTabStrip() === true : true;
          let endPos = getFar(nodeRect) - stickyButtonsSize;
          if (toolbarRef.current !== null) {
            endPos -= getSize(toolbarRef.current.getBoundingClientRect());
          }
          if (enabled && node.getChildren().length > 0) {
            if (hiddenTabs.length === 0 && position === 0 && getFar(lastChild.getTabRect()) + tabMargin < endPos) {
              return;
            }
            let shiftPos = 0;
            const selectedTab = node.getSelectedNode();
            if (selectedTab && !userControlledLeft.current) {
              const selectedRect = selectedTab.getTabRect();
              const selectedStart = getNear(selectedRect) - tabMargin;
              const selectedEnd = getFar(selectedRect) + tabMargin;
              if (getSize(selectedRect) + 2 * tabMargin >= endPos - getNear(nodeRect)) {
                shiftPos = getNear(nodeRect) - selectedStart;
              } else {
                if (selectedEnd > endPos || selectedStart < getNear(nodeRect)) {
                  if (selectedStart < getNear(nodeRect)) {
                    shiftPos = getNear(nodeRect) - selectedStart;
                  }
                  if (selectedEnd + shiftPos > endPos) {
                    shiftPos = endPos - selectedEnd;
                  }
                }
              }
            }
            const extraSpace = Math.max(0, endPos - (getFar(lastChild.getTabRect()) + tabMargin + shiftPos));
            const newPosition = Math.min(0, position + shiftPos + extraSpace);
            const diff = newPosition - position;
            const hidden = [];
            for (let i = 0; i < node.getChildren().length; i++) {
              const child = node.getChildren()[i];
              if (getNear(child.getTabRect()) + diff < getNear(nodeRect) || getFar(child.getTabRect()) + diff > endPos) {
                hidden.push({ node: child, index: i });
              }
            }
            if (hidden.length > 0) {
              tabsTruncated.current = true;
            }
            firstRender.current = false;
            setHiddenTabs(hidden);
            setPosition(newPosition);
          }
        } else {
          firstRender.current = true;
        }
      }, "updateVisibleTabs");
      const onMouseWheel = /* @__PURE__ */ __name$h((event) => {
        let delta = 0;
        if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
          delta = -event.deltaX;
        } else {
          delta = -event.deltaY;
        }
        if (event.deltaMode === 1) {
          delta *= 40;
        }
        setPosition(position + delta);
        userControlledLeft.current = true;
        event.stopPropagation();
      }, "onMouseWheel");
      return { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated: tabsTruncated.current };
    }, "useTabOverflow");

    var __defProp$g = Object.defineProperty;
    var __name$g = (target, value) => __defProp$g(target, "name", { value, configurable: true });
    const BorderTabSet = /* @__PURE__ */ __name$g((props) => {
      const { border, layout, iconFactory, titleFactory, icons, path } = props;
      const toolbarRef = wp.element.useRef(null);
      const overflowbuttonRef = wp.element.useRef(null);
      const stickyButtonsRef = wp.element.useRef(null);
      const { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel } = useTabOverflow(border, Orientation.flip(border.getOrientation()), toolbarRef, stickyButtonsRef);
      const onAuxMouseClick = /* @__PURE__ */ __name$g((event) => {
        if (isAuxMouseEvent(event)) {
          layout.auxMouseClick(border, event);
        }
      }, "onAuxMouseClick");
      const onContextMenu = /* @__PURE__ */ __name$g((event) => {
        layout.showContextMenu(border, event);
      }, "onContextMenu");
      const onInterceptMouseDown = /* @__PURE__ */ __name$g((event) => {
        event.stopPropagation();
      }, "onInterceptMouseDown");
      const onOverflowClick = /* @__PURE__ */ __name$g((event) => {
        const callback = layout.getShowOverflowMenu();
        if (callback !== void 0) {
          callback(border, event, hiddenTabs, onOverflowItemSelect);
        } else {
          const element = overflowbuttonRef.current;
          showPopup(
            element,
            hiddenTabs,
            onOverflowItemSelect,
            layout,
            iconFactory,
            titleFactory
          );
        }
        event.stopPropagation();
      }, "onOverflowClick");
      const onOverflowItemSelect = /* @__PURE__ */ __name$g((item) => {
        layout.doAction(Actions.selectTab(item.node.getId()));
        userControlledLeft.current = false;
      }, "onOverflowItemSelect");
      const onFloatTab = /* @__PURE__ */ __name$g((event) => {
        const selectedTabNode = border.getChildren()[border.getSelected()];
        if (selectedTabNode !== void 0) {
          layout.doAction(Actions.floatTab(selectedTabNode.getId()));
        }
        event.stopPropagation();
      }, "onFloatTab");
      const cm = layout.getClassName;
      let style = border.getTabHeaderRect().styleWithPosition({});
      const tabs = [];
      const layoutTab = /* @__PURE__ */ __name$g((i) => {
        let isSelected = border.getSelected() === i;
        let child = border.getChildren()[i];
        tabs.push(
          /* @__PURE__ */ wp.element.createElement(
            BorderButton,
            {
              layout,
              border: border.getLocation().getName(),
              node: child,
              path: path + "/tb" + i,
              key: child.getId(),
              selected: isSelected,
              iconFactory,
              titleFactory,
              icons
            }
          )
        );
        if (i < border.getChildren().length - 1) {
          tabs.push(
            /* @__PURE__ */ wp.element.createElement("div", { key: "divider" + i, className: cm(CLASSES.FLEXLAYOUT__BORDER_TAB_DIVIDER) })
          );
        }
      }, "layoutTab");
      for (let i = 0; i < border.getChildren().length; i++) {
        layoutTab(i);
      }
      let borderClasses = cm(CLASSES.FLEXLAYOUT__BORDER) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_ + border.getLocation().getName());
      if (border.getClassName() !== void 0) {
        borderClasses += " " + border.getClassName();
      }
      let buttons = [];
      const renderState = { headerContent: void 0, buttons, stickyButtons: [], headerButtons: [] };
      layout.customizeTabSet(border, renderState);
      buttons = renderState.buttons;
      let toolbar;
      if (hiddenTabs.length > 0) {
        const overflowTitle = layout.i18nName(I18nLabel.Overflow_Menu_Tooltip);
        let overflowContent;
        if (typeof icons.more === "function") {
          overflowContent = icons.more(border, hiddenTabs);
        } else {
          overflowContent = /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, icons.more, /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT) }, hiddenTabs.length));
        }
        buttons.push(
          /* @__PURE__ */ wp.element.createElement(
            "button",
            {
              key: "overflowbutton",
              ref: overflowbuttonRef,
              className: cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_ + border.getLocation().getName()),
              title: overflowTitle,
              onClick: onOverflowClick,
              onMouseDown: onInterceptMouseDown,
              onTouchStart: onInterceptMouseDown
            },
            overflowContent
          )
        );
      }
      const selectedIndex = border.getSelected();
      if (selectedIndex !== -1) {
        const selectedTabNode = border.getChildren()[selectedIndex];
        if (selectedTabNode !== void 0 && layout.isSupportsPopout() && selectedTabNode.isEnableFloat() && !selectedTabNode.isFloating()) {
          const floatTitle = layout.i18nName(I18nLabel.Float_Tab);
          buttons.push(
            /* @__PURE__ */ wp.element.createElement(
              "button",
              {
                key: "float",
                title: floatTitle,
                className: cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT),
                onClick: onFloatTab,
                onMouseDown: onInterceptMouseDown,
                onTouchStart: onInterceptMouseDown
              },
              typeof icons.popout === "function" ? icons.popout(selectedTabNode) : icons.popout
            )
          );
        }
      }
      toolbar = /* @__PURE__ */ wp.element.createElement("div", { key: "toolbar", ref: toolbarRef, className: cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_ + border.getLocation().getName()) }, buttons);
      style = layout.styleFont(style);
      let innerStyle = {};
      const borderHeight = border.getBorderBarSize() - 1;
      if (border.getLocation() === DockLocation.LEFT) {
        innerStyle = { right: borderHeight, height: borderHeight, top: position };
      } else if (border.getLocation() === DockLocation.RIGHT) {
        innerStyle = { left: borderHeight, height: borderHeight, top: position };
      } else {
        innerStyle = { height: borderHeight, left: position };
      }
      return /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          ref: selfRef,
          dir: "ltr",
          style,
          className: borderClasses,
          "data-layout-path": path,
          onClick: onAuxMouseClick,
          onAuxClick: onAuxMouseClick,
          onContextMenu,
          onWheel: onMouseWheel
        },
        /* @__PURE__ */ wp.element.createElement("div", { style: { height: borderHeight }, className: cm(CLASSES.FLEXLAYOUT__BORDER_INNER) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_INNER_ + border.getLocation().getName()) }, /* @__PURE__ */ wp.element.createElement("div", { style: innerStyle, className: cm(CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_ + border.getLocation().getName()) }, tabs)),
        toolbar
      );
    }, "BorderTabSet");

    var __defProp$f = Object.defineProperty;
    var __name$f = (target, value) => __defProp$f(target, "name", { value, configurable: true });
    const Splitter = /* @__PURE__ */ __name$f((props) => {
      const { layout, node, path } = props;
      const pBounds = wp.element.useRef([]);
      const outlineDiv = wp.element.useRef(void 0);
      const parentNode = node.getParent();
      const onMouseDown = /* @__PURE__ */ __name$f((event) => {
        DragDrop.instance.setGlassCursorOverride(node.getOrientation() === Orientation.HORZ ? "ns-resize" : "ew-resize");
        DragDrop.instance.startDrag(event, onDragStart, onDragMove, onDragEnd, onDragCancel, void 0, void 0, layout.getCurrentDocument(), layout.getRootDiv());
        pBounds.current = parentNode._getSplitterBounds(node, true);
        const rootdiv = layout.getRootDiv();
        outlineDiv.current = layout.getCurrentDocument().createElement("div");
        outlineDiv.current.style.position = "absolute";
        outlineDiv.current.className = layout.getClassName(CLASSES.FLEXLAYOUT__SPLITTER_DRAG);
        outlineDiv.current.style.cursor = node.getOrientation() === Orientation.HORZ ? "ns-resize" : "ew-resize";
        const r2 = node.getRect();
        if (node.getOrientation() === Orientation.VERT && r2.width < 2) {
          r2.width = 2;
        } else if (node.getOrientation() === Orientation.HORZ && r2.height < 2) {
          r2.height = 2;
        }
        r2.positionElement(outlineDiv.current);
        rootdiv.appendChild(outlineDiv.current);
      }, "onMouseDown");
      const onDragCancel = /* @__PURE__ */ __name$f((wasDragging) => {
        const rootdiv = layout.getRootDiv();
        rootdiv.removeChild(outlineDiv.current);
      }, "onDragCancel");
      const onDragStart = /* @__PURE__ */ __name$f(() => {
        return true;
      }, "onDragStart");
      const onDragMove = /* @__PURE__ */ __name$f((event) => {
        const clientRect = layout.getDomRect();
        const pos = {
          x: event.clientX - clientRect.left,
          y: event.clientY - clientRect.top
        };
        if (outlineDiv) {
          if (node.getOrientation() === Orientation.HORZ) {
            outlineDiv.current.style.top = getBoundPosition(pos.y - 4) + "px";
          } else {
            outlineDiv.current.style.left = getBoundPosition(pos.x - 4) + "px";
          }
        }
        if (layout.isRealtimeResize()) {
          updateLayout();
        }
      }, "onDragMove");
      const updateLayout = /* @__PURE__ */ __name$f(() => {
        let value = 0;
        if (outlineDiv) {
          if (node.getOrientation() === Orientation.HORZ) {
            value = outlineDiv.current.offsetTop;
          } else {
            value = outlineDiv.current.offsetLeft;
          }
        }
        if (parentNode instanceof BorderNode) {
          const pos = parentNode._calculateSplit(node, value);
          layout.doAction(Actions.adjustBorderSplit(node.getParent().getId(), pos));
        } else {
          const splitSpec = parentNode._calculateSplit(node, value);
          if (splitSpec !== void 0) {
            layout.doAction(Actions.adjustSplit(splitSpec));
          }
        }
      }, "updateLayout");
      const onDragEnd = /* @__PURE__ */ __name$f(() => {
        updateLayout();
        const rootdiv = layout.getRootDiv();
        rootdiv.removeChild(outlineDiv.current);
      }, "onDragEnd");
      const getBoundPosition = /* @__PURE__ */ __name$f((p) => {
        const bounds = pBounds.current;
        let rtn = p;
        if (p < bounds[0]) {
          rtn = bounds[0];
        }
        if (p > bounds[1]) {
          rtn = bounds[1];
        }
        return rtn;
      }, "getBoundPosition");
      const cm = layout.getClassName;
      let r = node.getRect();
      const style = r.styleWithPosition({
        cursor: node.getOrientation() === Orientation.HORZ ? "ns-resize" : "ew-resize"
      });
      let className = cm(CLASSES.FLEXLAYOUT__SPLITTER) + " " + cm(CLASSES.FLEXLAYOUT__SPLITTER_ + node.getOrientation().getName());
      if (parentNode instanceof BorderNode) {
        className += " " + cm(CLASSES.FLEXLAYOUT__SPLITTER_BORDER);
      } else {
        if (node.getModel().getMaximizedTabset() !== void 0) {
          style.display = "none";
        }
      }
      const extra = node.getModel().getSplitterExtra();
      if (extra === 0) {
        return /* @__PURE__ */ wp.element.createElement(
          "div",
          {
            style,
            "data-layout-path": path,
            className,
            onTouchStart: onMouseDown,
            onMouseDown
          }
        );
      } else {
        let r2 = r.clone();
        r2.x = 0;
        r2.y = 0;
        if (node.getOrientation() === Orientation.VERT) {
          r2.width += extra;
        } else {
          r2.height += extra;
        }
        const style2 = r2.styleWithPosition({
          cursor: node.getOrientation() === Orientation.HORZ ? "ns-resize" : "ew-resize"
        });
        const className2 = cm(CLASSES.FLEXLAYOUT__SPLITTER_EXTRA);
        return /* @__PURE__ */ wp.element.createElement(
          "div",
          {
            style,
            "data-layout-path": path,
            className
          },
          /* @__PURE__ */ wp.element.createElement(
            "div",
            {
              style: style2,
              className: className2,
              onTouchStart: onMouseDown,
              onMouseDown
            }
          )
        );
      }
    }, "Splitter");

    var __defProp$e = Object.defineProperty;
    var __name$e = (target, value) => __defProp$e(target, "name", { value, configurable: true });
    const _ErrorBoundary = class _ErrorBoundary extends wp.element.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }
      static getDerivedStateFromError(error) {
        return { hasError: true };
      }
      componentDidCatch(error, errorInfo) {
        console.debug(error);
        console.debug(errorInfo);
      }
      render() {
        if (this.state.hasError) {
          return /* @__PURE__ */ wp.element.createElement("div", { className: CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER }, /* @__PURE__ */ wp.element.createElement("div", { className: CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTENT }, this.props.message));
        }
        return this.props.children;
      }
    };
    __name$e(_ErrorBoundary, "ErrorBoundary");
    let ErrorBoundary = _ErrorBoundary;

    var __defProp$d = Object.defineProperty;
    var __name$d = (target, value) => __defProp$d(target, "name", { value, configurable: true });
    const Tab = /* @__PURE__ */ __name$d((props) => {
      const { layout, selected, node, factory, path } = props;
      const [renderComponent, setRenderComponent] = wp.element.useState(!props.node.isEnableRenderOnDemand() || props.selected);
      wp.element.useLayoutEffect(() => {
        if (!renderComponent && selected) {
          setRenderComponent(true);
        }
      });
      const onMouseDown = /* @__PURE__ */ __name$d(() => {
        const parent = node.getParent();
        if (parent.getType() === TabSetNode.TYPE) {
          if (!parent.isActive()) {
            layout.doAction(Actions.setActiveTabset(parent.getId()));
          }
        }
      }, "onMouseDown");
      const cm = layout.getClassName;
      const useVisibility = node.getModel().isUseVisibility();
      const parentNode = node.getParent();
      const style = node._styleWithPosition();
      if (!selected) {
        hideElement(style, useVisibility);
      }
      if (parentNode instanceof TabSetNode) {
        if (node.getModel().getMaximizedTabset() !== void 0 && !parentNode.isMaximized()) {
          hideElement(style, useVisibility);
        }
      }
      let child;
      if (renderComponent) {
        child = factory(node);
      }
      let className = cm(CLASSES.FLEXLAYOUT__TAB);
      if (parentNode instanceof BorderNode) {
        className += " " + cm(CLASSES.FLEXLAYOUT__TAB_BORDER);
        className += " " + cm(CLASSES.FLEXLAYOUT__TAB_BORDER_ + parentNode.getLocation().getName());
      }
      return /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          className,
          "data-layout-path": path,
          onMouseDown,
          onTouchStart: onMouseDown,
          style
        },
        /* @__PURE__ */ wp.element.createElement(ErrorBoundary, { message: props.layout.i18nName(I18nLabel.Error_rendering_component) }, /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, child))
      );
    }, "Tab");

    var __defProp$c = Object.defineProperty;
    var __name$c = (target, value) => __defProp$c(target, "name", { value, configurable: true });
    const TabButton = /* @__PURE__ */ __name$c((props) => {
      const { layout, node, selected, iconFactory, titleFactory, icons, path } = props;
      const selfRef = wp.element.useRef(null);
      const contentRef = wp.element.useRef(null);
      const onMouseDown = /* @__PURE__ */ __name$c((event) => {
        if (!isAuxMouseEvent(event) && !layout.getEditingTab()) {
          layout.dragStart(event, void 0, node, node.isEnableDrag(), onClick, onDoubleClick);
        }
      }, "onMouseDown");
      const onAuxMouseClick = /* @__PURE__ */ __name$c((event) => {
        if (isAuxMouseEvent(event)) {
          layout.auxMouseClick(node, event);
        }
      }, "onAuxMouseClick");
      const onContextMenu = /* @__PURE__ */ __name$c((event) => {
        layout.showContextMenu(node, event);
      }, "onContextMenu");
      const onClick = /* @__PURE__ */ __name$c(() => {
        layout.doAction(Actions.selectTab(node.getId()));
      }, "onClick");
      const onDoubleClick = /* @__PURE__ */ __name$c((event) => {
        if (node.isEnableRename()) {
          onRename();
        }
      }, "onDoubleClick");
      const onRename = /* @__PURE__ */ __name$c(() => {
        layout.setEditingTab(node);
        layout.getCurrentDocument().body.addEventListener("mousedown", onEndEdit);
        layout.getCurrentDocument().body.addEventListener("touchstart", onEndEdit);
      }, "onRename");
      const onEndEdit = /* @__PURE__ */ __name$c((event) => {
        if (event.target !== contentRef.current) {
          layout.getCurrentDocument().body.removeEventListener("mousedown", onEndEdit);
          layout.getCurrentDocument().body.removeEventListener("touchstart", onEndEdit);
          layout.setEditingTab(void 0);
        }
      }, "onEndEdit");
      const isClosable = /* @__PURE__ */ __name$c(() => {
        const closeType = node.getCloseType();
        if (selected || closeType === ICloseType.Always) {
          return true;
        }
        if (closeType === ICloseType.Visible) {
          if (window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches) {
            return true;
          }
        }
        return false;
      }, "isClosable");
      const onClose = /* @__PURE__ */ __name$c((event) => {
        if (isClosable()) {
          layout.doAction(Actions.deleteTab(node.getId()));
        } else {
          onClick();
        }
      }, "onClose");
      const onCloseMouseDown = /* @__PURE__ */ __name$c((event) => {
        event.stopPropagation();
      }, "onCloseMouseDown");
      wp.element.useLayoutEffect(() => {
        updateRect();
        if (layout.getEditingTab() === node) {
          contentRef.current.select();
        }
      });
      const updateRect = /* @__PURE__ */ __name$c(() => {
        const layoutRect = layout.getDomRect();
        const r = selfRef.current.getBoundingClientRect();
        node._setTabRect(new Rect(r.left - layoutRect.left, r.top - layoutRect.top, r.width, r.height));
      }, "updateRect");
      const onTextBoxMouseDown = /* @__PURE__ */ __name$c((event) => {
        event.stopPropagation();
      }, "onTextBoxMouseDown");
      const onTextBoxKeyPress = /* @__PURE__ */ __name$c((event) => {
        if (event.keyCode === 27) {
          layout.setEditingTab(void 0);
        } else if (event.keyCode === 13) {
          layout.setEditingTab(void 0);
          layout.doAction(Actions.renameTab(node.getId(), event.target.value));
        }
      }, "onTextBoxKeyPress");
      const cm = layout.getClassName;
      const parentNode = node.getParent();
      let baseClassName = CLASSES.FLEXLAYOUT__TAB_BUTTON;
      let classNames = cm(baseClassName);
      classNames += " " + cm(baseClassName + "_" + parentNode.getTabLocation());
      if (selected) {
        classNames += " " + cm(baseClassName + "--selected");
      } else {
        classNames += " " + cm(baseClassName + "--unselected");
      }
      if (node.getClassName() !== void 0) {
        classNames += " " + node.getClassName();
      }
      const renderState = getRenderStateEx(layout, node, iconFactory, titleFactory);
      let content = renderState.content ? /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT) }, renderState.content) : null;
      const leading = renderState.leading ? /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING) }, renderState.leading) : null;
      if (layout.getEditingTab() === node) {
        content = /* @__PURE__ */ wp.element.createElement(
          "input",
          {
            ref: contentRef,
            className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX),
            "data-layout-path": path + "/textbox",
            type: "text",
            autoFocus: true,
            defaultValue: node.getName(),
            onKeyDown: onTextBoxKeyPress,
            onMouseDown: onTextBoxMouseDown,
            onTouchStart: onTextBoxMouseDown
          }
        );
      }
      if (node.isEnableClose()) {
        const closeTitle = layout.i18nName(I18nLabel.Close_Tab);
        renderState.buttons.push(
          /* @__PURE__ */ wp.element.createElement(
            "div",
            {
              key: "close",
              "data-layout-path": path + "/button/close",
              title: closeTitle,
              className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TRAILING),
              onMouseDown: onCloseMouseDown,
              onClick: onClose,
              onTouchStart: onCloseMouseDown
            },
            typeof icons.close === "function" ? icons.close(node) : icons.close
          )
        );
      }
      return /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          ref: selfRef,
          "data-layout-path": path,
          className: classNames,
          onMouseDown,
          onClick: onAuxMouseClick,
          onAuxClick: onAuxMouseClick,
          onContextMenu,
          onTouchStart: onMouseDown,
          title: node.getHelpText()
        },
        leading,
        content,
        renderState.buttons
      );
    }, "TabButton");

    var __defProp$b = Object.defineProperty;
    var __name$b = (target, value) => __defProp$b(target, "name", { value, configurable: true });
    const TabSet = /* @__PURE__ */ __name$b((props) => {
      const { node, layout, iconFactory, titleFactory, icons, path } = props;
      const toolbarRef = wp.element.useRef(null);
      const overflowbuttonRef = wp.element.useRef(null);
      const tabbarInnerRef = wp.element.useRef(null);
      const stickyButtonsRef = wp.element.useRef(null);
      const { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated } = useTabOverflow(node, Orientation.HORZ, toolbarRef, stickyButtonsRef);
      const onOverflowClick = /* @__PURE__ */ __name$b((event) => {
        const callback = layout.getShowOverflowMenu();
        if (callback !== void 0) {
          callback(node, event, hiddenTabs, onOverflowItemSelect);
        } else {
          const element = overflowbuttonRef.current;
          showPopup(
            element,
            hiddenTabs,
            onOverflowItemSelect,
            layout,
            iconFactory,
            titleFactory
          );
        }
        event.stopPropagation();
      }, "onOverflowClick");
      const onOverflowItemSelect = /* @__PURE__ */ __name$b((item) => {
        layout.doAction(Actions.selectTab(item.node.getId()));
        userControlledLeft.current = false;
      }, "onOverflowItemSelect");
      const onMouseDown = /* @__PURE__ */ __name$b((event) => {
        if (!isAuxMouseEvent(event)) {
          let name = node.getName();
          if (name === void 0) {
            name = "";
          } else {
            name = ": " + name;
          }
          layout.doAction(Actions.setActiveTabset(node.getId()));
          if (!layout.getEditingTab()) {
            const message = layout.i18nName(I18nLabel.Move_Tabset, name);
            if (node.getModel().getMaximizedTabset() !== void 0) {
              layout.dragStart(event, message, node, false, (event2) => void 0, onDoubleClick);
            } else {
              layout.dragStart(event, message, node, node.isEnableDrag(), (event2) => void 0, onDoubleClick);
            }
          }
        }
      }, "onMouseDown");
      const onAuxMouseClick = /* @__PURE__ */ __name$b((event) => {
        if (isAuxMouseEvent(event)) {
          layout.auxMouseClick(node, event);
        }
      }, "onAuxMouseClick");
      const onContextMenu = /* @__PURE__ */ __name$b((event) => {
        layout.showContextMenu(node, event);
      }, "onContextMenu");
      const onInterceptMouseDown = /* @__PURE__ */ __name$b((event) => {
        event.stopPropagation();
      }, "onInterceptMouseDown");
      const onMaximizeToggle = /* @__PURE__ */ __name$b((event) => {
        if (node.canMaximize()) {
          layout.maximize(node);
        }
        event.stopPropagation();
      }, "onMaximizeToggle");
      const onClose = /* @__PURE__ */ __name$b((event) => {
        layout.doAction(Actions.deleteTabset(node.getId()));
        event.stopPropagation();
      }, "onClose");
      const onFloatTab = /* @__PURE__ */ __name$b((event) => {
        if (selectedTabNode !== void 0) {
          layout.doAction(Actions.floatTab(selectedTabNode.getId()));
        }
        event.stopPropagation();
      }, "onFloatTab");
      const onDoubleClick = /* @__PURE__ */ __name$b((event) => {
        if (node.canMaximize()) {
          layout.maximize(node);
        }
      }, "onDoubleClick");
      const cm = layout.getClassName;
      if (tabbarInnerRef.current !== null && tabbarInnerRef.current.scrollLeft !== 0) {
        tabbarInnerRef.current.scrollLeft = 0;
      }
      const selectedTabNode = node.getSelectedNode();
      let style = node._styleWithPosition();
      if (node.getModel().getMaximizedTabset() !== void 0 && !node.isMaximized()) {
        hideElement(style, node.getModel().isUseVisibility());
      }
      const tabs = [];
      if (node.isEnableTabStrip()) {
        for (let i = 0; i < node.getChildren().length; i++) {
          const child = node.getChildren()[i];
          let isSelected = node.getSelected() === i;
          tabs.push(
            /* @__PURE__ */ wp.element.createElement(
              TabButton,
              {
                layout,
                node: child,
                path: path + "/tb" + i,
                key: child.getId(),
                selected: isSelected,
                iconFactory,
                titleFactory,
                icons
              }
            )
          );
          if (i < node.getChildren().length - 1) {
            tabs.push(
              /* @__PURE__ */ wp.element.createElement("div", { key: "divider" + i, className: cm(CLASSES.FLEXLAYOUT__TABSET_TAB_DIVIDER) })
            );
          }
        }
      }
      const showHeader = node.getName() !== void 0;
      let stickyButtons = [];
      let buttons = [];
      let headerButtons = [];
      const renderState = { headerContent: node.getName(), stickyButtons, buttons, headerButtons };
      layout.customizeTabSet(node, renderState);
      const headerContent = renderState.headerContent;
      stickyButtons = renderState.stickyButtons;
      buttons = renderState.buttons;
      headerButtons = renderState.headerButtons;
      if (stickyButtons.length > 0) {
        if (tabsTruncated) {
          buttons = [...stickyButtons, ...buttons];
        } else {
          tabs.push(/* @__PURE__ */ wp.element.createElement(
            "div",
            {
              ref: stickyButtonsRef,
              key: "sticky_buttons_container",
              onMouseDown: onInterceptMouseDown,
              onTouchStart: onInterceptMouseDown,
              onDragStart: (e) => {
                e.preventDefault();
              },
              className: cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER)
            },
            stickyButtons
          ));
        }
      }
      let toolbar;
      if (hiddenTabs.length > 0) {
        const overflowTitle = layout.i18nName(I18nLabel.Overflow_Menu_Tooltip);
        let overflowContent;
        if (typeof icons.more === "function") {
          overflowContent = icons.more(node, hiddenTabs);
        } else {
          overflowContent = /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, icons.more, /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT) }, hiddenTabs.length));
        }
        buttons.push(
          /* @__PURE__ */ wp.element.createElement(
            "button",
            {
              key: "overflowbutton",
              "data-layout-path": path + "/button/overflow",
              ref: overflowbuttonRef,
              className: cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW),
              title: overflowTitle,
              onClick: onOverflowClick,
              onMouseDown: onInterceptMouseDown,
              onTouchStart: onInterceptMouseDown
            },
            overflowContent
          )
        );
      }
      if (selectedTabNode !== void 0 && layout.isSupportsPopout() && selectedTabNode.isEnableFloat() && !selectedTabNode.isFloating()) {
        const floatTitle = layout.i18nName(I18nLabel.Float_Tab);
        buttons.push(
          /* @__PURE__ */ wp.element.createElement(
            "button",
            {
              key: "float",
              "data-layout-path": path + "/button/float",
              title: floatTitle,
              className: cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT),
              onClick: onFloatTab,
              onMouseDown: onInterceptMouseDown,
              onTouchStart: onInterceptMouseDown
            },
            typeof icons.popout === "function" ? icons.popout(selectedTabNode) : icons.popout
          )
        );
      }
      if (node.canMaximize()) {
        const minTitle = layout.i18nName(I18nLabel.Restore);
        const maxTitle = layout.i18nName(I18nLabel.Maximize);
        const btns = showHeader ? headerButtons : buttons;
        btns.push(
          /* @__PURE__ */ wp.element.createElement(
            "button",
            {
              key: "max",
              "data-layout-path": path + "/button/max",
              title: node.isMaximized() ? minTitle : maxTitle,
              className: cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_ + (node.isMaximized() ? "max" : "min")),
              onClick: onMaximizeToggle,
              onMouseDown: onInterceptMouseDown,
              onTouchStart: onInterceptMouseDown
            },
            node.isMaximized() ? typeof icons.restore === "function" ? icons.restore(node) : icons.restore : typeof icons.maximize === "function" ? icons.maximize(node) : icons.maximize
          )
        );
      }
      if (!node.isMaximized() && node.isEnableClose()) {
        const title = layout.i18nName(I18nLabel.Close_Tabset);
        const btns = showHeader ? headerButtons : buttons;
        btns.push(
          /* @__PURE__ */ wp.element.createElement(
            "button",
            {
              key: "close",
              "data-layout-path": path + "/button/close",
              title,
              className: cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE),
              onClick: onClose,
              onMouseDown: onInterceptMouseDown,
              onTouchStart: onInterceptMouseDown
            },
            typeof icons.closeTabset === "function" ? icons.closeTabset(node) : icons.closeTabset
          )
        );
      }
      toolbar = /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          key: "toolbar",
          ref: toolbarRef,
          className: cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR),
          onMouseDown: onInterceptMouseDown,
          onTouchStart: onInterceptMouseDown,
          onDragStart: (e) => {
            e.preventDefault();
          }
        },
        buttons
      );
      let header;
      let tabStrip;
      let tabStripClasses = cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER);
      if (node.getClassNameTabStrip() !== void 0) {
        tabStripClasses += " " + node.getClassNameTabStrip();
      }
      tabStripClasses += " " + CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER_ + node.getTabLocation();
      if (node.isActive() && !showHeader) {
        tabStripClasses += " " + cm(CLASSES.FLEXLAYOUT__TABSET_SELECTED);
      }
      if (node.isMaximized() && !showHeader) {
        tabStripClasses += " " + cm(CLASSES.FLEXLAYOUT__TABSET_MAXIMIZED);
      }
      if (showHeader) {
        const headerToolbar = /* @__PURE__ */ wp.element.createElement(
          "div",
          {
            key: "toolbar",
            ref: toolbarRef,
            className: cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR),
            onMouseDown: onInterceptMouseDown,
            onTouchStart: onInterceptMouseDown,
            onDragStart: (e) => {
              e.preventDefault();
            }
          },
          headerButtons
        );
        let tabHeaderClasses = cm(CLASSES.FLEXLAYOUT__TABSET_HEADER);
        if (node.isActive()) {
          tabHeaderClasses += " " + cm(CLASSES.FLEXLAYOUT__TABSET_SELECTED);
        }
        if (node.isMaximized()) {
          tabHeaderClasses += " " + cm(CLASSES.FLEXLAYOUT__TABSET_MAXIMIZED);
        }
        if (node.getClassNameHeader() !== void 0) {
          tabHeaderClasses += " " + node.getClassNameHeader();
        }
        header = /* @__PURE__ */ wp.element.createElement(
          "div",
          {
            className: tabHeaderClasses,
            style: { height: node.getHeaderHeight() + "px" },
            "data-layout-path": path + "/header",
            onMouseDown,
            onContextMenu,
            onClick: onAuxMouseClick,
            onAuxClick: onAuxMouseClick,
            onTouchStart: onMouseDown
          },
          /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TABSET_HEADER_CONTENT) }, headerContent),
          headerToolbar
        );
      }
      const tabStripStyle = { height: node.getTabStripHeight() + "px" };
      tabStrip = /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          className: tabStripClasses,
          style: tabStripStyle,
          "data-layout-path": path + "/tabstrip",
          onMouseDown,
          onContextMenu,
          onClick: onAuxMouseClick,
          onAuxClick: onAuxMouseClick,
          onTouchStart: onMouseDown
        },
        /* @__PURE__ */ wp.element.createElement("div", { ref: tabbarInnerRef, className: cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER) + " " + cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_ + node.getTabLocation()) }, /* @__PURE__ */ wp.element.createElement(
          "div",
          {
            style: { left: position },
            className: cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER) + " " + cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_ + node.getTabLocation())
          },
          tabs
        )),
        toolbar
      );
      style = layout.styleFont(style);
      var placeHolder = void 0;
      if (node.getChildren().length === 0) {
        const placeHolderCallback = layout.getTabSetPlaceHolderCallback();
        if (placeHolderCallback) {
          placeHolder = placeHolderCallback(node);
        }
      }
      const center = /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TABSET_CONTENT) }, placeHolder);
      var content;
      if (node.getTabLocation() === "top") {
        content = /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, header, tabStrip, center);
      } else {
        content = /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, header, center, tabStrip);
      }
      return /* @__PURE__ */ wp.element.createElement(
        "div",
        {
          ref: selfRef,
          dir: "ltr",
          "data-layout-path": path,
          style,
          className: cm(CLASSES.FLEXLAYOUT__TABSET),
          onWheel: onMouseWheel
        },
        content
      );
    }, "TabSet");

    var __defProp$a = Object.defineProperty;
    var __name$a = (target, value) => __defProp$a(target, "name", { value, configurable: true });
    const FloatingWindow = /* @__PURE__ */ __name$a((props) => {
      const { title, id, url, rect, onCloseWindow, onSetWindow, children } = props;
      const popoutWindow = wp.element.useRef(null);
      const timerId = wp.element.useRef(null);
      const [content, setContent] = wp.element.useState(void 0);
      wp.element.useLayoutEffect(() => {
        if (timerId.current) {
          clearTimeout(timerId.current);
        }
        const r = rect;
        const styles = Array.from(window.document.styleSheets).reduce((result, styleSheet) => {
          let rules = void 0;
          try {
            rules = styleSheet.cssRules;
          } catch (e) {
          }
          try {
            return [
              ...result,
              {
                href: styleSheet.href,
                type: styleSheet.type,
                rules: rules ? Array.from(rules).map((rule) => rule.cssText) : null
              }
            ];
          } catch (e) {
            return result;
          }
        }, []);
        popoutWindow.current = window.open(url, id, `left=${r.x},top=${r.y},width=${r.width},height=${r.height}`);
        if (popoutWindow.current !== null) {
          onSetWindow(id, popoutWindow.current);
          window.addEventListener("beforeunload", () => {
            if (popoutWindow.current) {
              popoutWindow.current.close();
              popoutWindow.current = null;
            }
          });
          popoutWindow.current.addEventListener("load", () => {
            const popoutDocument = popoutWindow.current.document;
            popoutDocument.title = title;
            const popoutContent = popoutDocument.createElement("div");
            popoutContent.className = CLASSES.FLEXLAYOUT__FLOATING_WINDOW_CONTENT;
            popoutDocument.body.appendChild(popoutContent);
            copyStyles(popoutDocument, styles).then(() => {
              setContent(popoutContent);
            });
            popoutWindow.current.addEventListener("beforeunload", () => {
              onCloseWindow(id);
            });
          });
        } else {
          console.warn(`Unable to open window ${url}`);
          onCloseWindow(id);
        }
        return () => {
          timerId.current = setTimeout(() => {
            if (popoutWindow.current) {
              popoutWindow.current.close();
              popoutWindow.current = null;
            }
          }, 0);
        };
      }, []);
      if (content !== void 0) {
        return wp.element.createPortal(children, content);
      } else {
        return null;
      }
    }, "FloatingWindow");
    function copyStyles(doc, styleSheets) {
      const head = doc.head;
      const promises = [];
      for (const styleSheet of styleSheets) {
        if (styleSheet.href) {
          const styleElement = doc.createElement("link");
          styleElement.type = styleSheet.type;
          styleElement.rel = "stylesheet";
          styleElement.href = styleSheet.href;
          head.appendChild(styleElement);
          promises.push(
            new Promise((resolve, reject) => {
              styleElement.onload = () => resolve(true);
            })
          );
        } else {
          if (styleSheet.rules) {
            const style = doc.createElement("style");
            for (const rule of styleSheet.rules) {
              style.appendChild(doc.createTextNode(rule));
            }
            head.appendChild(style);
          }
        }
      }
      return Promise.all(promises);
    }
    __name$a(copyStyles, "copyStyles");

    var __defProp$9 = Object.defineProperty;
    var __name$9 = (target, value) => __defProp$9(target, "name", { value, configurable: true });
    const FloatingWindowTab = /* @__PURE__ */ __name$9((props) => {
      const { layout, node, factory } = props;
      const cm = layout.getClassName;
      const child = factory(node);
      return /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__FLOATING_WINDOW_TAB) }, /* @__PURE__ */ wp.element.createElement(ErrorBoundary, { message: props.layout.i18nName(I18nLabel.Error_rendering_component) }, /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, child)));
    }, "FloatingWindowTab");

    var __defProp$8 = Object.defineProperty;
    var __name$8 = (target, value) => __defProp$8(target, "name", { value, configurable: true });
    const TabFloating = /* @__PURE__ */ __name$8((props) => {
      const { layout, selected, node, path } = props;
      const showPopout = /* @__PURE__ */ __name$8(() => {
        if (node.getWindow()) {
          node.getWindow().focus();
        }
      }, "showPopout");
      const dockPopout = /* @__PURE__ */ __name$8(() => {
        layout.doAction(Actions.unFloatTab(node.getId()));
      }, "dockPopout");
      const onMouseDown = /* @__PURE__ */ __name$8(() => {
        const parent = node.getParent();
        if (parent.getType() === TabSetNode.TYPE) {
          if (!parent.isActive()) {
            layout.doAction(Actions.setActiveTabset(parent.getId()));
          }
        }
      }, "onMouseDown");
      const onClickFocus = /* @__PURE__ */ __name$8((event) => {
        event.preventDefault();
        showPopout();
      }, "onClickFocus");
      const onClickDock = /* @__PURE__ */ __name$8((event) => {
        event.preventDefault();
        dockPopout();
      }, "onClickDock");
      const cm = layout.getClassName;
      const parentNode = node.getParent();
      const style = node._styleWithPosition();
      if (!selected) {
        hideElement(style, node.getModel().isUseVisibility());
      }
      if (parentNode instanceof TabSetNode) {
        if (node.getModel().getMaximizedTabset() !== void 0 && !parentNode.isMaximized()) {
          hideElement(style, node.getModel().isUseVisibility());
        }
      }
      const message = layout.i18nName(I18nLabel.Floating_Window_Message);
      const showMessage = layout.i18nName(I18nLabel.Floating_Window_Show_Window);
      const dockMessage = layout.i18nName(I18nLabel.Floating_Window_Dock_Window);
      const customRenderCallback = layout.getOnRenderFloatingTabPlaceholder();
      if (customRenderCallback) {
        return /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_FLOATING), onMouseDown, onTouchStart: onMouseDown, style }, customRenderCallback(dockPopout, showPopout));
      } else {
        return /* @__PURE__ */ wp.element.createElement(
          "div",
          {
            className: cm(CLASSES.FLEXLAYOUT__TAB_FLOATING),
            "data-layout-path": path,
            onMouseDown,
            onTouchStart: onMouseDown,
            style
          },
          /* @__PURE__ */ wp.element.createElement("div", { className: cm(CLASSES.FLEXLAYOUT__TAB_FLOATING_INNER) }, /* @__PURE__ */ wp.element.createElement("div", null, message), /* @__PURE__ */ wp.element.createElement("div", null, /* @__PURE__ */ wp.element.createElement("a", { href: "#", onClick: onClickFocus }, showMessage)), /* @__PURE__ */ wp.element.createElement("div", null, /* @__PURE__ */ wp.element.createElement("a", { href: "#", onClick: onClickDock }, dockMessage)))
        );
      }
    }, "TabFloating");

    var __defProp$7 = Object.defineProperty;
    var __name$7 = (target, value) => __defProp$7(target, "name", { value, configurable: true });
    const style = { width: "1em", height: "1em", display: "flex", alignItems: "center" };
    const CloseIcon = /* @__PURE__ */ __name$7(() => {
      return /* @__PURE__ */ wp.element.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", style, viewBox: "0 0 24 24" }, /* @__PURE__ */ wp.element.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }), /* @__PURE__ */ wp.element.createElement("path", { stroke: "var(--color-icon)", fill: "var(--color-icon)", d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }));
    }, "CloseIcon");
    const MaximizeIcon = /* @__PURE__ */ __name$7(() => {
      return /* @__PURE__ */ wp.element.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", style, viewBox: "0 0 24 24", fill: "var(--color-icon)" }, /* @__PURE__ */ wp.element.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }), /* @__PURE__ */ wp.element.createElement("path", { stroke: "var(--color-icon)", d: "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" }));
    }, "MaximizeIcon");
    const OverflowIcon = /* @__PURE__ */ __name$7(() => {
      return /* @__PURE__ */ wp.element.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", style, viewBox: "0 0 24 24", fill: "var(--color-icon)" }, /* @__PURE__ */ wp.element.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }), /* @__PURE__ */ wp.element.createElement("path", { stroke: "var(--color-icon)", d: "M7 10l5 5 5-5z" }));
    }, "OverflowIcon");
    const PopoutIcon = /* @__PURE__ */ __name$7(() => {
      return (
        // <svg xmlns="http://www.w3.org/2000/svg"  style={style}  viewBox="0 0 24 24" fill="var(--color-icon)"><path d="M0 0h24v24H0z" fill="none"/><path stroke="var(--color-icon)" d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5z"/></svg>
        // <svg xmlns="http://www.w3.org/2000/svg" style={style} fill="none" viewBox="0 0 24 24" stroke="var(--color-icon)" stroke-width="2">
        //     <path stroke-linecap="round" stroke-linejoin="round" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
        // </svg>
        /* @__PURE__ */ wp.element.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", style, viewBox: "0 0 20 20", fill: "var(--color-icon)" }, /* @__PURE__ */ wp.element.createElement("path", { d: "M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z" }), /* @__PURE__ */ wp.element.createElement("path", { d: "M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z" }))
      );
    }, "PopoutIcon");
    const RestoreIcon = /* @__PURE__ */ __name$7(() => {
      return /* @__PURE__ */ wp.element.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", style, viewBox: "0 0 24 24", fill: "var(--color-icon)" }, /* @__PURE__ */ wp.element.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }), /* @__PURE__ */ wp.element.createElement("path", { stroke: "var(--color-icon)", d: "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" }));
    }, "RestoreIcon");

    var __defProp$6 = Object.defineProperty;
    var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$6 = (target, value) => __defProp$6(target, "name", { value, configurable: true });
    var __publicField$2 = (obj, key, value) => {
      __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const defaultIcons = {
      close: /* @__PURE__ */ wp.element.createElement(CloseIcon, null),
      closeTabset: /* @__PURE__ */ wp.element.createElement(CloseIcon, null),
      popout: /* @__PURE__ */ wp.element.createElement(PopoutIcon, null),
      maximize: /* @__PURE__ */ wp.element.createElement(MaximizeIcon, null),
      restore: /* @__PURE__ */ wp.element.createElement(RestoreIcon, null),
      more: /* @__PURE__ */ wp.element.createElement(OverflowIcon, null)
    };
    const isIEorEdge = typeof window !== "undefined" && (window.document.documentMode || /Edge\//.test(window.navigator.userAgent));
    const isDesktop = typeof window !== "undefined" && window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches;
    const defaultSupportsPopout = isDesktop && !isIEorEdge;
    const _Layout = class _Layout extends wp.element.Component {
      constructor(props) {
        super(props);
        /** @internal */
        __publicField$2(this, "selfRef");
        /** @internal */
        __publicField$2(this, "findHeaderBarSizeRef");
        /** @internal */
        __publicField$2(this, "findTabBarSizeRef");
        /** @internal */
        __publicField$2(this, "findBorderBarSizeRef");
        /** @internal */
        __publicField$2(this, "previousModel");
        /** @internal */
        __publicField$2(this, "centerRect");
        /** @internal */
        // private start: number = 0;
        /** @internal */
        // private layoutTime: number = 0;
        /** @internal */
        __publicField$2(this, "tabIds");
        /** @internal */
        __publicField$2(this, "newTabJson");
        /** @internal */
        __publicField$2(this, "firstMove", false);
        /** @internal */
        __publicField$2(this, "dragNode");
        /** @internal */
        __publicField$2(this, "dragDiv");
        /** @internal */
        __publicField$2(this, "dragRectRendered", true);
        /** @internal */
        __publicField$2(this, "dragDivText");
        /** @internal */
        __publicField$2(this, "dropInfo");
        /** @internal */
        __publicField$2(this, "customDrop");
        /** @internal */
        __publicField$2(this, "outlineDiv");
        /** @internal */
        __publicField$2(this, "edgeRectLength", 100);
        /** @internal */
        __publicField$2(this, "edgeRectWidth", 10);
        /** @internal */
        __publicField$2(this, "fnNewNodeDropped");
        /** @internal */
        __publicField$2(this, "currentDocument");
        /** @internal */
        __publicField$2(this, "currentWindow");
        /** @internal */
        __publicField$2(this, "supportsPopout");
        /** @internal */
        __publicField$2(this, "popoutURL");
        /** @internal */
        __publicField$2(this, "icons");
        /** @internal */
        __publicField$2(this, "resizeObserver");
        /** @internal */
        __publicField$2(this, "onModelChange", /* @__PURE__ */ __name$6((action) => {
          this.forceUpdate();
          if (this.props.onModelChange) {
            this.props.onModelChange(this.props.model, action);
          }
        }, "onModelChange"));
        /** @internal */
        __publicField$2(this, "updateRect", /* @__PURE__ */ __name$6((domRect = this.getDomRect()) => {
          const rect = new Rect(0, 0, domRect.width, domRect.height);
          if (!rect.equals(this.state.rect) && rect.width !== 0 && rect.height !== 0) {
            this.setState({ rect });
          }
        }, "updateRect"));
        /** @internal */
        __publicField$2(this, "updateLayoutMetrics", /* @__PURE__ */ __name$6(() => {
          if (this.findHeaderBarSizeRef.current) {
            const headerBarSize = this.findHeaderBarSizeRef.current.getBoundingClientRect().height;
            if (headerBarSize !== this.state.calculatedHeaderBarSize) {
              this.setState({ calculatedHeaderBarSize: headerBarSize });
            }
          }
          if (this.findTabBarSizeRef.current) {
            const tabBarSize = this.findTabBarSizeRef.current.getBoundingClientRect().height;
            if (tabBarSize !== this.state.calculatedTabBarSize) {
              this.setState({ calculatedTabBarSize: tabBarSize });
            }
          }
          if (this.findBorderBarSizeRef.current) {
            const borderBarSize = this.findBorderBarSizeRef.current.getBoundingClientRect().height;
            if (borderBarSize !== this.state.calculatedBorderBarSize) {
              this.setState({ calculatedBorderBarSize: borderBarSize });
            }
          }
        }, "updateLayoutMetrics"));
        /** @internal */
        __publicField$2(this, "getClassName", /* @__PURE__ */ __name$6((defaultClassName) => {
          if (this.props.classNameMapper === void 0) {
            return defaultClassName;
          } else {
            return this.props.classNameMapper(defaultClassName);
          }
        }, "getClassName"));
        /** @internal */
        __publicField$2(this, "onCloseWindow", /* @__PURE__ */ __name$6((id) => {
          this.doAction(Actions.unFloatTab(id));
          try {
            this.props.model.getNodeById(id)._setWindow(void 0);
          } catch (e) {
          }
        }, "onCloseWindow"));
        /** @internal */
        __publicField$2(this, "onSetWindow", /* @__PURE__ */ __name$6((id, window2) => {
          this.props.model.getNodeById(id)._setWindow(window2);
        }, "onSetWindow"));
        /** @internal */
        __publicField$2(this, "onCancelAdd", /* @__PURE__ */ __name$6(() => {
          const rootdiv = this.selfRef.current;
          rootdiv.removeChild(this.dragDiv);
          this.dragDiv = void 0;
          this.hidePortal();
          if (this.fnNewNodeDropped != null) {
            this.fnNewNodeDropped();
            this.fnNewNodeDropped = void 0;
          }
          try {
            this.customDrop?.invalidated?.();
          } catch (e) {
            console.error(e);
          }
          DragDrop.instance.hideGlass();
          this.newTabJson = void 0;
          this.customDrop = void 0;
        }, "onCancelAdd"));
        /** @internal */
        __publicField$2(this, "onCancelDrag", /* @__PURE__ */ __name$6((wasDragging) => {
          if (wasDragging) {
            const rootdiv = this.selfRef.current;
            try {
              rootdiv.removeChild(this.outlineDiv);
            } catch (e) {
            }
            try {
              rootdiv.removeChild(this.dragDiv);
            } catch (e) {
            }
            this.dragDiv = void 0;
            this.hidePortal();
            this.setState({ showEdges: false });
            if (this.fnNewNodeDropped != null) {
              this.fnNewNodeDropped();
              this.fnNewNodeDropped = void 0;
            }
            try {
              this.customDrop?.invalidated?.();
            } catch (e) {
              console.error(e);
            }
            DragDrop.instance.hideGlass();
            this.newTabJson = void 0;
            this.customDrop = void 0;
          }
          this.setState({ showHiddenBorder: DockLocation.CENTER });
        }, "onCancelDrag"));
        /** @internal */
        __publicField$2(this, "onDragDivMouseDown", /* @__PURE__ */ __name$6((event) => {
          event.preventDefault();
          this.dragStart(event, this.dragDivText, TabNode._fromJson(this.newTabJson, this.props.model, false), true, void 0, void 0);
        }, "onDragDivMouseDown"));
        /** @internal */
        __publicField$2(this, "dragStart", /* @__PURE__ */ __name$6((event, dragDivText, node, allowDrag, onClick, onDoubleClick) => {
          if (!allowDrag) {
            DragDrop.instance.startDrag(event, void 0, void 0, void 0, void 0, onClick, onDoubleClick, this.currentDocument, this.selfRef.current);
          } else {
            this.dragNode = node;
            this.dragDivText = dragDivText;
            DragDrop.instance.startDrag(event, this.onDragStart, this.onDragMove, this.onDragEnd, this.onCancelDrag, onClick, onDoubleClick, this.currentDocument, this.selfRef.current);
          }
        }, "dragStart"));
        /** @internal */
        __publicField$2(this, "dragRectRender", /* @__PURE__ */ __name$6((text, node, json, onRendered) => {
          let content;
          if (text !== void 0) {
            content = /* @__PURE__ */ wp.element.createElement("div", { style: { whiteSpace: "pre" } }, text.replace("<br>", "\n"));
          } else {
            if (node && node instanceof TabNode) {
              content = /* @__PURE__ */ wp.element.createElement(
                TabButtonStamp,
                {
                  node,
                  layout: this,
                  iconFactory: this.props.iconFactory,
                  titleFactory: this.props.titleFactory
                }
              );
            }
          }
          if (this.props.onRenderDragRect !== void 0) {
            const customContent = this.props.onRenderDragRect(content, node, json);
            if (customContent !== void 0) {
              content = customContent;
            }
          }
          this.dragDiv.style.visibility = "hidden";
          this.dragRectRendered = false;
          this.showPortal(
            /* @__PURE__ */ wp.element.createElement(
              DragRectRenderWrapper,
              {
                onRendered: () => {
                  this.dragRectRendered = true;
                  onRendered?.();
                }
              },
              content
            ),
            this.dragDiv
          );
        }, "dragRectRender"));
        /** @internal */
        __publicField$2(this, "showPortal", /* @__PURE__ */ __name$6((control, element) => {
          const portal = wp.element.createPortal(control, element);
          this.setState({ portal });
        }, "showPortal"));
        /** @internal */
        __publicField$2(this, "hidePortal", /* @__PURE__ */ __name$6(() => {
          this.setState({ portal: void 0 });
        }, "hidePortal"));
        /** @internal */
        __publicField$2(this, "onDragStart", /* @__PURE__ */ __name$6(() => {
          this.dropInfo = void 0;
          this.customDrop = void 0;
          const rootdiv = this.selfRef.current;
          this.outlineDiv = this.currentDocument.createElement("div");
          this.outlineDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__OUTLINE_RECT);
          this.outlineDiv.style.visibility = "hidden";
          rootdiv.appendChild(this.outlineDiv);
          if (this.dragDiv == null) {
            this.dragDiv = this.currentDocument.createElement("div");
            this.dragDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);
            this.dragDiv.setAttribute("data-layout-path", "/drag-rectangle");
            this.dragRectRender(this.dragDivText, this.dragNode, this.newTabJson);
            rootdiv.appendChild(this.dragDiv);
          }
          if (this.props.model.getMaximizedTabset() === void 0) {
            this.setState({ showEdges: true });
          }
          if (this.dragNode !== void 0 && this.dragNode instanceof TabNode && this.dragNode.getTabRect() !== void 0) {
            this.dragNode.getTabRect().positionElement(this.outlineDiv);
          }
          this.firstMove = true;
          return true;
        }, "onDragStart"));
        /** @internal */
        __publicField$2(this, "onDragMove", /* @__PURE__ */ __name$6((event) => {
          if (this.firstMove === false) {
            const speed = this.props.model._getAttribute("tabDragSpeed");
            this.outlineDiv.style.transition = `top ${speed}s, left ${speed}s, width ${speed}s, height ${speed}s`;
          }
          this.firstMove = false;
          const clientRect = this.selfRef.current.getBoundingClientRect();
          const pos = {
            x: event.clientX - clientRect.left,
            y: event.clientY - clientRect.top
          };
          this.checkForBorderToShow(pos.x, pos.y);
          const dragRect = this.dragDiv.getBoundingClientRect();
          let newLeft = pos.x - dragRect.width / 2;
          if (newLeft + dragRect.width > clientRect.width) {
            newLeft = clientRect.width - dragRect.width;
          }
          newLeft = Math.max(0, newLeft);
          this.dragDiv.style.left = newLeft + "px";
          this.dragDiv.style.top = pos.y + 5 + "px";
          if (this.dragRectRendered && this.dragDiv.style.visibility === "hidden") {
            this.dragDiv.style.visibility = "visible";
          }
          let dropInfo = this.props.model._findDropTargetNode(this.dragNode, pos.x, pos.y);
          if (dropInfo) {
            if (this.props.onTabDrag) {
              this.handleCustomTabDrag(dropInfo, pos, event);
            } else {
              this.dropInfo = dropInfo;
              this.outlineDiv.className = this.getClassName(dropInfo.className);
              dropInfo.rect.positionElement(this.outlineDiv);
              this.outlineDiv.style.visibility = "visible";
            }
          }
        }, "onDragMove"));
        /** @internal */
        __publicField$2(this, "onDragEnd", /* @__PURE__ */ __name$6((event) => {
          const rootdiv = this.selfRef.current;
          rootdiv.removeChild(this.outlineDiv);
          rootdiv.removeChild(this.dragDiv);
          this.dragDiv = void 0;
          this.hidePortal();
          this.setState({ showEdges: false });
          DragDrop.instance.hideGlass();
          if (this.dropInfo) {
            if (this.customDrop) {
              this.newTabJson = void 0;
              try {
                const { callback, dragging, over, x, y, location } = this.customDrop;
                callback(dragging, over, x, y, location);
                if (this.fnNewNodeDropped != null) {
                  this.fnNewNodeDropped();
                  this.fnNewNodeDropped = void 0;
                }
              } catch (e) {
                console.error(e);
              }
            } else if (this.newTabJson !== void 0) {
              const newNode = this.doAction(Actions.addNode(this.newTabJson, this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));
              if (this.fnNewNodeDropped != null) {
                this.fnNewNodeDropped(newNode, event);
                this.fnNewNodeDropped = void 0;
              }
              this.newTabJson = void 0;
            } else if (this.dragNode !== void 0) {
              this.doAction(Actions.moveNode(this.dragNode.getId(), this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));
            }
          }
          this.setState({ showHiddenBorder: DockLocation.CENTER });
        }, "onDragEnd"));
        this.props.model._setChangeListener(this.onModelChange);
        this.tabIds = [];
        this.selfRef = wp.element.createRef();
        this.findHeaderBarSizeRef = wp.element.createRef();
        this.findTabBarSizeRef = wp.element.createRef();
        this.findBorderBarSizeRef = wp.element.createRef();
        this.supportsPopout = props.supportsPopout !== void 0 ? props.supportsPopout : defaultSupportsPopout;
        this.popoutURL = props.popoutURL ? props.popoutURL : "popout.html";
        this.icons = { ...defaultIcons, ...props.icons };
        this.state = {
          rect: new Rect(0, 0, 0, 0),
          calculatedHeaderBarSize: 25,
          calculatedTabBarSize: 26,
          calculatedBorderBarSize: 30,
          editingTab: void 0,
          showHiddenBorder: DockLocation.CENTER,
          showEdges: false
        };
        this.onDragEnter = this.onDragEnter.bind(this);
      }
      /** @internal */
      styleFont(style) {
        if (this.props.font) {
          if (this.selfRef.current) {
            if (this.props.font.size) {
              this.selfRef.current.style.setProperty("--font-size", this.props.font.size);
            }
            if (this.props.font.family) {
              this.selfRef.current.style.setProperty("--font-family", this.props.font.family);
            }
          }
          if (this.props.font.style) {
            style.fontStyle = this.props.font.style;
          }
          if (this.props.font.weight) {
            style.fontWeight = this.props.font.weight;
          }
        }
        return style;
      }
      /** @internal */
      doAction(action) {
        if (this.props.onAction !== void 0) {
          const outcome = this.props.onAction(action);
          if (outcome !== void 0) {
            return this.props.model.doAction(outcome);
          }
          return void 0;
        } else {
          return this.props.model.doAction(action);
        }
      }
      /** @internal */
      componentDidMount() {
        this.updateRect();
        this.updateLayoutMetrics();
        this.currentDocument = this.selfRef.current.ownerDocument;
        this.currentWindow = this.currentDocument.defaultView;
        this.resizeObserver = new ResizeObserver((entries) => {
          this.updateRect(entries[0].contentRect);
        });
        this.resizeObserver.observe(this.selfRef.current);
      }
      /** @internal */
      componentDidUpdate() {
        this.updateLayoutMetrics();
        if (this.props.model !== this.previousModel) {
          if (this.previousModel !== void 0) {
            this.previousModel._setChangeListener(void 0);
          }
          this.props.model._setChangeListener(this.onModelChange);
          this.previousModel = this.props.model;
        }
      }
      /** @internal */
      getCurrentDocument() {
        return this.currentDocument;
      }
      /** @internal */
      getDomRect() {
        return this.selfRef.current.getBoundingClientRect();
      }
      /** @internal */
      getRootDiv() {
        return this.selfRef.current;
      }
      /** @internal */
      isSupportsPopout() {
        return this.supportsPopout;
      }
      /** @internal */
      isRealtimeResize() {
        return this.props.realtimeResize ?? false;
      }
      /** @internal */
      onTabDrag(...args) {
        return this.props.onTabDrag?.(...args);
      }
      /** @internal */
      getPopoutURL() {
        return this.popoutURL;
      }
      /** @internal */
      componentWillUnmount() {
        this.resizeObserver?.unobserve(this.selfRef.current);
      }
      /** @internal */
      setEditingTab(tabNode) {
        this.setState({ editingTab: tabNode });
      }
      /** @internal */
      getEditingTab() {
        return this.state.editingTab;
      }
      /** @internal */
      render() {
        if (!this.selfRef.current) {
          return /* @__PURE__ */ wp.element.createElement("div", { ref: this.selfRef, className: this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT) }, this.metricsElements());
        }
        this.props.model._setPointerFine(window && window.matchMedia && window.matchMedia("(pointer: fine)").matches);
        const borderComponents = [];
        const tabSetComponents = [];
        const floatingWindows = [];
        const tabComponents = {};
        const splitterComponents = [];
        const metrics = {
          headerBarSize: this.state.calculatedHeaderBarSize,
          tabBarSize: this.state.calculatedTabBarSize,
          borderBarSize: this.state.calculatedBorderBarSize
        };
        this.props.model._setShowHiddenBorder(this.state.showHiddenBorder);
        this.centerRect = this.props.model._layout(this.state.rect, metrics);
        this.renderBorder(this.props.model.getBorderSet(), borderComponents, tabComponents, floatingWindows, splitterComponents);
        this.renderChildren("", this.props.model.getRoot(), tabSetComponents, tabComponents, floatingWindows, splitterComponents);
        const nextTopIds = [];
        const nextTopIdsMap = {};
        for (const t of this.tabIds) {
          if (tabComponents[t]) {
            nextTopIds.push(t);
            nextTopIdsMap[t] = t;
          }
        }
        this.tabIds = nextTopIds;
        for (const t of Object.keys(tabComponents)) {
          if (!nextTopIdsMap[t]) {
            this.tabIds.push(t);
          }
        }
        const edges = [];
        if (this.state.showEdges) {
          const r = this.centerRect;
          const length = this.edgeRectLength;
          const width = this.edgeRectWidth;
          const offset = this.edgeRectLength / 2;
          const className = this.getClassName(CLASSES.FLEXLAYOUT__EDGE_RECT);
          const radius = 50;
          edges.push(/* @__PURE__ */ wp.element.createElement("div", { key: "North", style: { top: r.y, left: r.x + r.width / 2 - offset, width: length, height: width, borderBottomLeftRadius: radius, borderBottomRightRadius: radius }, className }));
          edges.push(/* @__PURE__ */ wp.element.createElement("div", { key: "West", style: { top: r.y + r.height / 2 - offset, left: r.x, width, height: length, borderTopRightRadius: radius, borderBottomRightRadius: radius }, className }));
          edges.push(/* @__PURE__ */ wp.element.createElement("div", { key: "South", style: { top: r.y + r.height - width, left: r.x + r.width / 2 - offset, width: length, height: width, borderTopLeftRadius: radius, borderTopRightRadius: radius }, className }));
          edges.push(/* @__PURE__ */ wp.element.createElement("div", { key: "East", style: { top: r.y + r.height / 2 - offset, left: r.x + r.width - width, width, height: length, borderTopLeftRadius: radius, borderBottomLeftRadius: radius }, className }));
        }
        return /* @__PURE__ */ wp.element.createElement("div", { ref: this.selfRef, className: this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT), onDragEnter: this.props.onExternalDrag ? this.onDragEnter : void 0 }, tabSetComponents, this.tabIds.map((t) => {
          return tabComponents[t];
        }), borderComponents, splitterComponents, edges, floatingWindows, this.metricsElements(), this.state.portal);
      }
      /** @internal */
      metricsElements() {
        const fontStyle = this.styleFont({ visibility: "hidden" });
        return /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, /* @__PURE__ */ wp.element.createElement("div", { key: "findHeaderBarSize", ref: this.findHeaderBarSizeRef, style: fontStyle, className: this.getClassName(CLASSES.FLEXLAYOUT__TABSET_HEADER_SIZER) }, "FindHeaderBarSize"), /* @__PURE__ */ wp.element.createElement("div", { key: "findTabBarSize", ref: this.findTabBarSizeRef, style: fontStyle, className: this.getClassName(CLASSES.FLEXLAYOUT__TABSET_SIZER) }, "FindTabBarSize"), /* @__PURE__ */ wp.element.createElement("div", { key: "findBorderBarSize", ref: this.findBorderBarSizeRef, style: fontStyle, className: this.getClassName(CLASSES.FLEXLAYOUT__BORDER_SIZER) }, "FindBorderBarSize"));
      }
      /** @internal */
      renderBorder(borderSet, borderComponents, tabComponents, floatingWindows, splitterComponents) {
        for (const border of borderSet.getBorders()) {
          const borderPath = `/border/${border.getLocation().getName()}`;
          if (border.isShowing()) {
            borderComponents.push(
              /* @__PURE__ */ wp.element.createElement(
                BorderTabSet,
                {
                  key: `border_${border.getLocation().getName()}`,
                  path: borderPath,
                  border,
                  layout: this,
                  iconFactory: this.props.iconFactory,
                  titleFactory: this.props.titleFactory,
                  icons: this.icons
                }
              )
            );
            const drawChildren = border._getDrawChildren();
            let i = 0;
            let tabCount = 0;
            for (const child of drawChildren) {
              if (child instanceof SplitterNode) {
                let path = borderPath + "/s";
                splitterComponents.push(/* @__PURE__ */ wp.element.createElement(Splitter, { key: child.getId(), layout: this, node: child, path }));
              } else if (child instanceof TabNode) {
                let path = borderPath + "/t" + tabCount++;
                if (this.supportsPopout && child.isFloating()) {
                  const rect = this._getScreenRect(child);
                  floatingWindows.push(
                    /* @__PURE__ */ wp.element.createElement(
                      FloatingWindow,
                      {
                        key: child.getId(),
                        url: this.popoutURL,
                        rect,
                        title: child.getName(),
                        id: child.getId(),
                        onSetWindow: this.onSetWindow,
                        onCloseWindow: this.onCloseWindow
                      },
                      /* @__PURE__ */ wp.element.createElement(FloatingWindowTab, { layout: this, node: child, factory: this.props.factory })
                    )
                  );
                  tabComponents[child.getId()] = /* @__PURE__ */ wp.element.createElement(
                    TabFloating,
                    {
                      key: child.getId(),
                      layout: this,
                      path,
                      node: child,
                      selected: i === border.getSelected()
                    }
                  );
                } else {
                  tabComponents[child.getId()] = /* @__PURE__ */ wp.element.createElement(
                    Tab,
                    {
                      key: child.getId(),
                      layout: this,
                      path,
                      node: child,
                      selected: i === border.getSelected(),
                      factory: this.props.factory
                    }
                  );
                }
              }
              i++;
            }
          }
        }
      }
      /** @internal */
      renderChildren(path, node, tabSetComponents, tabComponents, floatingWindows, splitterComponents) {
        const drawChildren = node._getDrawChildren();
        let splitterCount = 0;
        let tabCount = 0;
        let rowCount = 0;
        for (const child of drawChildren) {
          if (child instanceof SplitterNode) {
            const newPath = path + "/s" + splitterCount++;
            splitterComponents.push(/* @__PURE__ */ wp.element.createElement(Splitter, { key: child.getId(), layout: this, path: newPath, node: child }));
          } else if (child instanceof TabSetNode) {
            const newPath = path + "/ts" + rowCount++;
            tabSetComponents.push(/* @__PURE__ */ wp.element.createElement(TabSet, { key: child.getId(), layout: this, path: newPath, node: child, iconFactory: this.props.iconFactory, titleFactory: this.props.titleFactory, icons: this.icons }));
            this.renderChildren(newPath, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);
          } else if (child instanceof TabNode) {
            const newPath = path + "/t" + tabCount++;
            const selectedTab = child.getParent().getChildren()[child.getParent().getSelected()];
            if (selectedTab === void 0) {
              console.warn("undefined selectedTab should not happen");
            }
            if (this.supportsPopout && child.isFloating()) {
              const rect = this._getScreenRect(child);
              floatingWindows.push(
                /* @__PURE__ */ wp.element.createElement(
                  FloatingWindow,
                  {
                    key: child.getId(),
                    url: this.popoutURL,
                    rect,
                    title: child.getName(),
                    id: child.getId(),
                    onSetWindow: this.onSetWindow,
                    onCloseWindow: this.onCloseWindow
                  },
                  /* @__PURE__ */ wp.element.createElement(FloatingWindowTab, { layout: this, node: child, factory: this.props.factory })
                )
              );
              tabComponents[child.getId()] = /* @__PURE__ */ wp.element.createElement(TabFloating, { key: child.getId(), layout: this, path: newPath, node: child, selected: child === selectedTab });
            } else {
              tabComponents[child.getId()] = /* @__PURE__ */ wp.element.createElement(Tab, { key: child.getId(), layout: this, path: newPath, node: child, selected: child === selectedTab, factory: this.props.factory });
            }
          } else {
            const newPath = path + (child.getOrientation() === Orientation.HORZ ? "/r" : "/c") + rowCount++;
            this.renderChildren(newPath, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);
          }
        }
      }
      /** @internal */
      _getScreenRect(node) {
        const rect = node.getRect().clone();
        const bodyRect = this.selfRef.current.getBoundingClientRect();
        const navHeight = Math.min(80, this.currentWindow.outerHeight - this.currentWindow.innerHeight);
        const navWidth = Math.min(80, this.currentWindow.outerWidth - this.currentWindow.innerWidth);
        rect.x = rect.x + bodyRect.x + this.currentWindow.screenX + navWidth;
        rect.y = rect.y + bodyRect.y + this.currentWindow.screenY + navHeight;
        return rect;
      }
      /**
       * Adds a new tab to the given tabset
       * @param tabsetId the id of the tabset where the new tab will be added
       * @param json the json for the new tab node
       */
      addTabToTabSet(tabsetId, json) {
        const tabsetNode = this.props.model.getNodeById(tabsetId);
        if (tabsetNode !== void 0) {
          this.doAction(Actions.addNode(json, tabsetId, DockLocation.CENTER, -1));
        }
      }
      /**
       * Adds a new tab to the active tabset (if there is one)
       * @param json the json for the new tab node
       */
      addTabToActiveTabSet(json) {
        const tabsetNode = this.props.model.getActiveTabset();
        if (tabsetNode !== void 0) {
          this.doAction(Actions.addNode(json, tabsetNode.getId(), DockLocation.CENTER, -1));
        }
      }
      /**
       * Adds a new tab by dragging a labeled panel to the drop location, dragging starts immediatelly
       * @param dragText the text to show on the drag panel
       * @param json the json for the new tab node
       * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)
       */
      addTabWithDragAndDrop(dragText, json, onDrop) {
        this.fnNewNodeDropped = onDrop;
        this.newTabJson = json;
        this.dragStart(void 0, dragText, TabNode._fromJson(json, this.props.model, false), true, void 0, void 0);
      }
      /**
       * Move a tab/tabset using drag and drop
       * @param node the tab or tabset to drag
       * @param dragText the text to show on the drag panel
       */
      moveTabWithDragAndDrop(node, dragText) {
        this.dragStart(void 0, dragText, node, true, void 0, void 0);
      }
      /**
       * Adds a new tab by dragging a labeled panel to the drop location, dragging starts when you
       * mouse down on the panel
       *
       * @param dragText the text to show on the drag panel
       * @param json the json for the new tab node
       * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)
       */
      addTabWithDragAndDropIndirect(dragText, json, onDrop) {
        this.fnNewNodeDropped = onDrop;
        this.newTabJson = json;
        DragDrop.instance.addGlass(this.onCancelAdd);
        this.dragDivText = dragText;
        this.dragDiv = this.currentDocument.createElement("div");
        this.dragDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);
        this.dragDiv.addEventListener("mousedown", this.onDragDivMouseDown);
        this.dragDiv.addEventListener("touchstart", this.onDragDivMouseDown, { passive: false });
        this.dragRectRender(this.dragDivText, void 0, this.newTabJson, () => {
          if (this.dragDiv) {
            this.dragDiv.style.visibility = "visible";
            const domRect = this.dragDiv.getBoundingClientRect();
            const r = new Rect(0, 0, domRect?.width, domRect?.height);
            r.centerInRect(this.state.rect);
            this.dragDiv.setAttribute("data-layout-path", "/drag-rectangle");
            this.dragDiv.style.left = r.x + "px";
            this.dragDiv.style.top = r.y + "px";
          }
        });
        const rootdiv = this.selfRef.current;
        rootdiv.appendChild(this.dragDiv);
      }
      /** @internal */
      handleCustomTabDrag(dropInfo, pos, event) {
        let invalidated = this.customDrop?.invalidated;
        const currentCallback = this.customDrop?.callback;
        this.customDrop = void 0;
        const dragging = this.newTabJson || (this.dragNode instanceof TabNode ? this.dragNode : void 0);
        if (dragging && (dropInfo.node instanceof TabSetNode || dropInfo.node instanceof BorderNode) && dropInfo.index === -1) {
          const selected = dropInfo.node.getSelectedNode();
          const tabRect = selected?.getRect();
          if (selected && tabRect?.contains(pos.x, pos.y)) {
            let customDrop = void 0;
            try {
              const dest = this.onTabDrag(dragging, selected, pos.x - tabRect.x, pos.y - tabRect.y, dropInfo.location, () => this.onDragMove(event));
              if (dest) {
                customDrop = {
                  rect: new Rect(dest.x + tabRect.x, dest.y + tabRect.y, dest.width, dest.height),
                  callback: dest.callback,
                  invalidated: dest.invalidated,
                  dragging,
                  over: selected,
                  x: pos.x - tabRect.x,
                  y: pos.y - tabRect.y,
                  location: dropInfo.location,
                  cursor: dest.cursor
                };
              }
            } catch (e) {
              console.error(e);
            }
            if (customDrop?.callback === currentCallback) {
              invalidated = void 0;
            }
            this.customDrop = customDrop;
          }
        }
        this.dropInfo = dropInfo;
        this.outlineDiv.className = this.getClassName(this.customDrop ? CLASSES.FLEXLAYOUT__OUTLINE_RECT : dropInfo.className);
        if (this.customDrop) {
          this.customDrop.rect.positionElement(this.outlineDiv);
        } else {
          dropInfo.rect.positionElement(this.outlineDiv);
        }
        DragDrop.instance.setGlassCursorOverride(this.customDrop?.cursor);
        this.outlineDiv.style.visibility = "visible";
        try {
          invalidated?.();
        } catch (e) {
          console.error(e);
        }
      }
      /** @internal */
      onDragEnter(event) {
        if (DragDrop.instance.isDragging())
          return;
        const drag = this.props.onExternalDrag(event);
        if (drag) {
          this.fnNewNodeDropped = drag.onDrop;
          this.newTabJson = drag.json;
          this.dragStart(event, drag.dragText, TabNode._fromJson(drag.json, this.props.model, false), true, void 0, void 0);
        }
      }
      /** @internal */
      checkForBorderToShow(x, y) {
        const r = this.props.model._getOuterInnerRects().outer;
        const c = r.getCenter();
        const margin = this.edgeRectWidth;
        const offset = this.edgeRectLength / 2;
        let overEdge = false;
        if (this.props.model.isEnableEdgeDock() && this.state.showHiddenBorder === DockLocation.CENTER) {
          if (y > c.y - offset && y < c.y + offset || x > c.x - offset && x < c.x + offset) {
            overEdge = true;
          }
        }
        let location = DockLocation.CENTER;
        if (!overEdge) {
          if (x <= r.x + margin) {
            location = DockLocation.LEFT;
          } else if (x >= r.getRight() - margin) {
            location = DockLocation.RIGHT;
          } else if (y <= r.y + margin) {
            location = DockLocation.TOP;
          } else if (y >= r.getBottom() - margin) {
            location = DockLocation.BOTTOM;
          }
        }
        if (location !== this.state.showHiddenBorder) {
          this.setState({ showHiddenBorder: location });
        }
      }
      /** @internal */
      maximize(tabsetNode) {
        this.doAction(Actions.maximizeToggle(tabsetNode.getId()));
      }
      /** @internal */
      customizeTab(tabNode, renderValues) {
        if (this.props.onRenderTab) {
          this.props.onRenderTab(tabNode, renderValues);
        }
      }
      /** @internal */
      customizeTabSet(tabSetNode, renderValues) {
        if (this.props.onRenderTabSet) {
          this.props.onRenderTabSet(tabSetNode, renderValues);
        }
      }
      /** @internal */
      i18nName(id, param) {
        let message;
        if (this.props.i18nMapper) {
          message = this.props.i18nMapper(id, param);
        }
        if (message === void 0) {
          message = id + (param === void 0 ? "" : param);
        }
        return message;
      }
      /** @internal */
      getOnRenderFloatingTabPlaceholder() {
        return this.props.onRenderFloatingTabPlaceholder;
      }
      /** @internal */
      getShowOverflowMenu() {
        return this.props.onShowOverflowMenu;
      }
      /** @internal */
      getTabSetPlaceHolderCallback() {
        return this.props.onTabSetPlaceHolder;
      }
      /** @internal */
      showContextMenu(node, event) {
        if (this.props.onContextMenu) {
          this.props.onContextMenu(node, event);
        }
      }
      /** @internal */
      auxMouseClick(node, event) {
        if (this.props.onAuxMouseClick) {
          this.props.onAuxMouseClick(node, event);
        }
      }
    };
    __name$6(_Layout, "Layout");
    let Layout = _Layout;
    const DragRectRenderWrapper = /* @__PURE__ */ __name$6((props) => {
      wp.element.useEffect(() => {
        props.onRendered?.();
      }, [props]);
      return /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, props.children);
    }, "DragRectRenderWrapper");

    var __defProp$5 = Object.defineProperty;
    var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$5 = (target, value) => __defProp$5(target, "name", { value, configurable: true });
    var __publicField$1 = (obj, key, value) => {
      __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _BorderSet = class _BorderSet {
      /** @internal */
      constructor(model) {
        /** @internal */
        __publicField$1(this, "_model");
        /** @internal */
        __publicField$1(this, "_borders");
        this._model = model;
        this._borders = [];
      }
      /** @internal */
      static _fromJson(json, model) {
        const borderSet = new _BorderSet(model);
        borderSet._borders = json.map((borderJson) => BorderNode._fromJson(borderJson, model));
        return borderSet;
      }
      getBorders() {
        return this._borders;
      }
      /** @internal */
      _forEachNode(fn) {
        for (const borderNode of this._borders) {
          fn(borderNode, 0);
          for (const node of borderNode.getChildren()) {
            node._forEachNode(fn, 1);
          }
        }
      }
      /** @internal */
      _toJson() {
        return this._borders.map((borderNode) => borderNode.toJson());
      }
      /** @internal */
      _layoutBorder(outerInnerRects, metrics) {
        const rect = outerInnerRects.outer;
        const rootRow = this._model.getRoot();
        let height = Math.max(0, rect.height - rootRow.getMinHeight());
        let width = Math.max(0, rect.width - rootRow.getMinWidth());
        let sumHeight = 0;
        let sumWidth = 0;
        let adjustableHeight = 0;
        let adjustableWidth = 0;
        const showingBorders = this._borders.filter((border) => border.isShowing());
        for (const border of showingBorders) {
          border._setAdjustedSize(border.getSize());
          const visible = border.getSelected() !== -1;
          if (border.getLocation().getOrientation() === Orientation.HORZ) {
            sumWidth += border.getBorderBarSize();
            if (visible) {
              width -= this._model.getSplitterSize();
              sumWidth += border.getSize();
              adjustableWidth += border.getSize();
            }
          } else {
            sumHeight += border.getBorderBarSize();
            if (visible) {
              height -= this._model.getSplitterSize();
              sumHeight += border.getSize();
              adjustableHeight += border.getSize();
            }
          }
        }
        let j = 0;
        let adjusted = false;
        while (sumWidth > width && adjustableWidth > 0 || sumHeight > height && adjustableHeight > 0) {
          const border = showingBorders[j];
          if (border.getSelected() !== -1) {
            const size = border._getAdjustedSize();
            if (sumWidth > width && adjustableWidth > 0 && border.getLocation().getOrientation() === Orientation.HORZ && size > 0 && size > border.getMinSize()) {
              border._setAdjustedSize(size - 1);
              sumWidth--;
              adjustableWidth--;
              adjusted = true;
            } else if (sumHeight > height && adjustableHeight > 0 && border.getLocation().getOrientation() === Orientation.VERT && size > 0 && size > border.getMinSize()) {
              border._setAdjustedSize(size - 1);
              sumHeight--;
              adjustableHeight--;
              adjusted = true;
            }
          }
          j = (j + 1) % showingBorders.length;
          if (j === 0) {
            if (adjusted) {
              adjusted = false;
            } else {
              break;
            }
          }
        }
        for (const border of showingBorders) {
          outerInnerRects.outer = border._layoutBorderOuter(outerInnerRects.outer, metrics);
        }
        outerInnerRects.inner = outerInnerRects.outer;
        for (const border of showingBorders) {
          outerInnerRects.inner = border._layoutBorderInner(outerInnerRects.inner, metrics);
        }
        return outerInnerRects;
      }
      /** @internal */
      _findDropTargetNode(dragNode, x, y) {
        for (const border of this._borders) {
          if (border.isShowing()) {
            const dropInfo = border.canDrop(dragNode, x, y);
            if (dropInfo !== void 0) {
              return dropInfo;
            }
          }
        }
        return void 0;
      }
    };
    __name$5(_BorderSet, "BorderSet");
    let BorderSet = _BorderSet;

    var __defProp$4 = Object.defineProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name$4 = (target, value) => __defProp$4(target, "name", { value, configurable: true });
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    const _Model = class _Model {
      /**
       * 'private' constructor. Use the static method Model.fromJson(json) to create a model
       *  @internal
       */
      constructor() {
        /** @internal */
        __publicField(this, "_attributes");
        /** @internal */
        __publicField(this, "_idMap");
        /** @internal */
        __publicField(this, "_changeListener");
        /** @internal */
        __publicField(this, "_root");
        /** @internal */
        __publicField(this, "_borders");
        /** @internal */
        __publicField(this, "_onAllowDrop");
        /** @internal */
        __publicField(this, "_maximizedTabSet");
        /** @internal */
        __publicField(this, "_activeTabSet");
        /** @internal */
        __publicField(this, "_borderRects", { inner: Rect.empty(), outer: Rect.empty() });
        /** @internal */
        __publicField(this, "_pointerFine");
        /** @internal */
        __publicField(this, "_onCreateTabSet");
        /** @internal */
        __publicField(this, "_showHiddenBorder");
        this._attributes = {};
        this._idMap = {};
        this._borders = new BorderSet(this);
        this._pointerFine = true;
        this._showHiddenBorder = DockLocation.CENTER;
      }
      /**
       * Loads the model from the given json object
       * @param json the json model to load
       * @returns {Model} a new Model object
       */
      static fromJson(json) {
        const model = new _Model();
        _Model._attributeDefinitions.fromJson(json.global, model._attributes);
        if (json.borders) {
          model._borders = BorderSet._fromJson(json.borders, model);
        }
        model._root = RowNode._fromJson(json.layout, model);
        model._tidy();
        return model;
      }
      /** @internal */
      static _createAttributeDefinitions() {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("legacyOverflowMenu", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("splitterSize", -1).setType(Attribute.NUMBER);
        attributeDefinitions.add("splitterExtra", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("enableEdgeDock", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("rootOrientationVertical", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("marginInsets", { top: 0, right: 0, bottom: 0, left: 0 }).setType("IInsets");
        attributeDefinitions.add("enableUseVisibility", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabEnableClose", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabCloseType", 1).setType("ICloseType");
        attributeDefinitions.add("tabEnableFloat", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabEnableDrag", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabEnableRename", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabClassName", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("tabIcon", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("tabEnableRenderOnDemand", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabDragSpeed", 0.3).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabBorderWidth", -1).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabBorderHeight", -1).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetEnableDeleteWhenEmpty", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableDrop", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableDrag", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableDivide", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableMaximize", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableClose", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetAutoSelectTab", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetClassNameTabStrip", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("tabSetClassNameHeader", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("tabSetEnableTabStrip", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetHeaderHeight", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetTabStripHeight", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetMarginInsets", { top: 0, right: 0, bottom: 0, left: 0 }).setType("IInsets");
        attributeDefinitions.add("tabSetBorderInsets", { top: 0, right: 0, bottom: 0, left: 0 }).setType("IInsets");
        attributeDefinitions.add("tabSetTabLocation", "top").setType("ITabLocation");
        attributeDefinitions.add("tabSetMinWidth", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetMinHeight", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("borderSize", 200).setType(Attribute.NUMBER);
        attributeDefinitions.add("borderMinSize", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("borderBarSize", 0).setType(Attribute.NUMBER);
        attributeDefinitions.add("borderEnableDrop", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("borderAutoSelectTabWhenOpen", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("borderAutoSelectTabWhenClosed", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("borderClassName", void 0).setType(Attribute.STRING);
        attributeDefinitions.add("borderEnableAutoHide", false).setType(Attribute.BOOLEAN);
        return attributeDefinitions;
      }
      /** @internal */
      _setChangeListener(listener) {
        this._changeListener = listener;
      }
      /**
       * Get the currently active tabset node
       */
      getActiveTabset() {
        if (this._activeTabSet && this.getNodeById(this._activeTabSet.getId())) {
          return this._activeTabSet;
        } else {
          return void 0;
        }
      }
      /** @internal */
      _getShowHiddenBorder() {
        return this._showHiddenBorder;
      }
      /** @internal */
      _setShowHiddenBorder(location) {
        this._showHiddenBorder = location;
      }
      /** @internal */
      _setActiveTabset(tabsetNode) {
        this._activeTabSet = tabsetNode;
      }
      /**
       * Get the currently maximized tabset node
       */
      getMaximizedTabset() {
        return this._maximizedTabSet;
      }
      /** @internal */
      _setMaximizedTabset(tabsetNode) {
        this._maximizedTabSet = tabsetNode;
      }
      /**
       * Gets the root RowNode of the model
       * @returns {RowNode}
       */
      getRoot() {
        return this._root;
      }
      isRootOrientationVertical() {
        return this._attributes.rootOrientationVertical;
      }
      isUseVisibility() {
        return this._attributes.enableUseVisibility;
      }
      /**
       * Gets the
       * @returns {BorderSet|*}
       */
      getBorderSet() {
        return this._borders;
      }
      /** @internal */
      _getOuterInnerRects() {
        return this._borderRects;
      }
      /** @internal */
      _getPointerFine() {
        return this._pointerFine;
      }
      /** @internal */
      _setPointerFine(pointerFine) {
        this._pointerFine = pointerFine;
      }
      /**
       * Visits all the nodes in the model and calls the given function for each
       * @param fn a function that takes visited node and a integer level as parameters
       */
      visitNodes(fn) {
        this._borders._forEachNode(fn);
        this._root._forEachNode(fn, 0);
      }
      /**
       * Gets a node by its id
       * @param id the id to find
       */
      getNodeById(id) {
        return this._idMap[id];
      }
      /**
       * Update the node tree by performing the given action,
       * Actions should be generated via static methods on the Actions class
       * @param action the action to perform
       * @returns added Node for Actions.addNode; undefined otherwise
       */
      doAction(action) {
        let returnVal = void 0;
        switch (action.type) {
          case Actions.ADD_NODE: {
            const newNode = new TabNode(this, action.data.json, true);
            const toNode = this._idMap[action.data.toNode];
            if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {
              toNode.drop(newNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);
              returnVal = newNode;
            }
            break;
          }
          case Actions.MOVE_NODE: {
            const fromNode = this._idMap[action.data.fromNode];
            if (fromNode instanceof TabNode || fromNode instanceof TabSetNode) {
              const toNode = this._idMap[action.data.toNode];
              if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {
                toNode.drop(fromNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);
              }
            }
            break;
          }
          case Actions.DELETE_TAB: {
            const node = this._idMap[action.data.node];
            if (node instanceof TabNode) {
              node._delete();
            }
            break;
          }
          case Actions.DELETE_TABSET: {
            const node = this._idMap[action.data.node];
            if (node instanceof TabSetNode) {
              const children = [...node.getChildren()];
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.isEnableClose()) {
                  child._delete();
                }
              }
              if (node.getChildren().length === 0) {
                node._delete();
              }
              this._tidy();
            }
            break;
          }
          case Actions.FLOAT_TAB: {
            const node = this._idMap[action.data.node];
            if (node instanceof TabNode) {
              node._setFloating(true);
              adjustSelectedIndexAfterFloat(node);
            }
            break;
          }
          case Actions.UNFLOAT_TAB: {
            const node = this._idMap[action.data.node];
            if (node instanceof TabNode) {
              node._setFloating(false);
              adjustSelectedIndexAfterDock(node);
            }
            break;
          }
          case Actions.RENAME_TAB: {
            const node = this._idMap[action.data.node];
            if (node instanceof TabNode) {
              node._setName(action.data.text);
            }
            break;
          }
          case Actions.SELECT_TAB: {
            const tabNode = this._idMap[action.data.tabNode];
            if (tabNode instanceof TabNode) {
              const parent = tabNode.getParent();
              const pos = parent.getChildren().indexOf(tabNode);
              if (parent instanceof BorderNode) {
                if (parent.getSelected() === pos) {
                  parent._setSelected(-1);
                } else {
                  parent._setSelected(pos);
                }
              } else if (parent instanceof TabSetNode) {
                if (parent.getSelected() !== pos) {
                  parent._setSelected(pos);
                }
                this._activeTabSet = parent;
              }
            }
            break;
          }
          case Actions.SET_ACTIVE_TABSET: {
            const tabsetNode = this._idMap[action.data.tabsetNode];
            if (tabsetNode instanceof TabSetNode) {
              this._activeTabSet = tabsetNode;
            }
            break;
          }
          case Actions.ADJUST_SPLIT: {
            const node1 = this._idMap[action.data.node1];
            const node2 = this._idMap[action.data.node2];
            if ((node1 instanceof TabSetNode || node1 instanceof RowNode) && (node2 instanceof TabSetNode || node2 instanceof RowNode)) {
              this._adjustSplitSide(node1, action.data.weight1, action.data.pixelWidth1);
              this._adjustSplitSide(node2, action.data.weight2, action.data.pixelWidth2);
            }
            break;
          }
          case Actions.ADJUST_BORDER_SPLIT: {
            const node = this._idMap[action.data.node];
            if (node instanceof BorderNode) {
              node._setSize(action.data.pos);
            }
            break;
          }
          case Actions.MAXIMIZE_TOGGLE: {
            const node = this._idMap[action.data.node];
            if (node instanceof TabSetNode) {
              if (node === this._maximizedTabSet) {
                this._maximizedTabSet = void 0;
              } else {
                this._maximizedTabSet = node;
                this._activeTabSet = node;
              }
            }
            break;
          }
          case Actions.UPDATE_MODEL_ATTRIBUTES: {
            this._updateAttrs(action.data.json);
            break;
          }
          case Actions.UPDATE_NODE_ATTRIBUTES: {
            const node = this._idMap[action.data.node];
            node._updateAttrs(action.data.json);
            break;
          }
        }
        this._updateIdMap();
        if (this._changeListener !== void 0) {
          this._changeListener(action);
        }
        return returnVal;
      }
      /** @internal */
      _updateIdMap() {
        this._idMap = {};
        this.visitNodes((node) => this._idMap[node.getId()] = node);
      }
      /** @internal */
      _adjustSplitSide(node, weight, pixels) {
        node._setWeight(weight);
        if (node.getWidth() != null && node.getOrientation() === Orientation.VERT) {
          node._updateAttrs({ width: pixels });
        } else if (node.getHeight() != null && node.getOrientation() === Orientation.HORZ) {
          node._updateAttrs({ height: pixels });
        }
      }
      /**
       * Converts the model to a json object
       * @returns {IJsonModel} json object that represents this model
       */
      toJson() {
        const global = {};
        _Model._attributeDefinitions.toJson(global, this._attributes);
        this.visitNodes((node) => {
          node._fireEvent("save", void 0);
        });
        return { global, borders: this._borders._toJson(), layout: this._root.toJson() };
      }
      getSplitterSize() {
        let splitterSize = this._attributes.splitterSize;
        if (splitterSize === -1) {
          splitterSize = this._pointerFine ? 8 : 12;
        }
        return splitterSize;
      }
      isLegacyOverflowMenu() {
        return this._attributes.legacyOverflowMenu;
      }
      getSplitterExtra() {
        return this._attributes.splitterExtra;
      }
      isEnableEdgeDock() {
        return this._attributes.enableEdgeDock;
      }
      /** @internal */
      _addNode(node) {
        const id = node.getId();
        if (this._idMap[id] !== void 0) {
          throw new Error(`Error: each node must have a unique id, duplicate id:${node.getId()}`);
        }
        if (node.getType() !== "splitter") {
          this._idMap[id] = node;
        }
      }
      /** @internal */
      _layout(rect, metrics) {
        this._borderRects = this._borders._layoutBorder({ outer: rect, inner: rect }, metrics);
        rect = this._borderRects.inner.removeInsets(this._getAttribute("marginInsets"));
        this._root?.calcMinSize();
        this._root._layout(rect, metrics);
        return rect;
      }
      /** @internal */
      _findDropTargetNode(dragNode, x, y) {
        let node = this._root._findDropTargetNode(dragNode, x, y);
        if (node === void 0) {
          node = this._borders._findDropTargetNode(dragNode, x, y);
        }
        return node;
      }
      /** @internal */
      _tidy() {
        this._root._tidy();
      }
      /** @internal */
      _updateAttrs(json) {
        _Model._attributeDefinitions.update(json, this._attributes);
      }
      /** @internal */
      _nextUniqueId() {
        return "#" + randomUUID();
      }
      /** @internal */
      _getAttribute(name) {
        return this._attributes[name];
      }
      /**
       * Sets a function to allow/deny dropping a node
       * @param onAllowDrop function that takes the drag node and DropInfo and returns true if the drop is allowed
       */
      setOnAllowDrop(onAllowDrop) {
        this._onAllowDrop = onAllowDrop;
      }
      /** @internal */
      _getOnAllowDrop() {
        return this._onAllowDrop;
      }
      /**
       * set callback called when a new TabSet is created.
       * The tabNode can be undefined if it's the auto created first tabset in the root row (when the last
       * tab is deleted, the root tabset can be recreated)
       * @param onCreateTabSet 
       */
      setOnCreateTabSet(onCreateTabSet) {
        this._onCreateTabSet = onCreateTabSet;
      }
      /** @internal */
      _getOnCreateTabSet() {
        return this._onCreateTabSet;
      }
      static toTypescriptInterfaces() {
        console.log(_Model._attributeDefinitions.toTypescriptInterface("Global", void 0));
        console.log(RowNode.getAttributeDefinitions().toTypescriptInterface("Row", _Model._attributeDefinitions));
        console.log(TabSetNode.getAttributeDefinitions().toTypescriptInterface("TabSet", _Model._attributeDefinitions));
        console.log(TabNode.getAttributeDefinitions().toTypescriptInterface("Tab", _Model._attributeDefinitions));
        console.log(BorderNode.getAttributeDefinitions().toTypescriptInterface("Border", _Model._attributeDefinitions));
      }
      toString() {
        return JSON.stringify(this.toJson());
      }
    };
    __name$4(_Model, "Model");
    /** @internal */
    __publicField(_Model, "_attributeDefinitions", _Model._createAttributeDefinitions());
    let Model = _Model;

    var layoutModelData = {
      global: {
        // https://github.com/caplin/FlexLayout#global-config-attributes
        enableEdgeDock: false,
        splitterSize: 5,
        tabEnableClose: false,
        tabEnableRename: false,
        tabEnableFloat: false,
        tabEnableRenderOnDemand: true,
        tabEnableDrag: true,
        tabSetEnableClose: false,
        tabSetEnableMaximize: false,
        tabSetEnableDrop: true
      },
      borders: [
        {
          type: "border",
          location: "right",
          size: 320,
          barSize: -1,
          // Hide border tabset header
          // selected: 0, // Open
          children: [
            {
              type: "tab",
              id: "library",
              name: "Library",
              component: ""
            },
            {
              type: "tab",
              id: "support",
              name: "Support",
              component: ""
            }
          ]
        }
      ],
      layout: {
        type: "row",
        weight: 100,
        children: [
          {
            type: "row",
            weight: 50,
            children: [
              {
                type: "tabset",
                weight: 20,
                children: [
                  {
                    type: "tab",
                    name: "Overview",
                    component: "grid"
                  }
                ]
              },
              {
                type: "tabset",
                weight: 80,
                children: [
                  {
                    type: "tab",
                    name: "Template",
                    component: "editor"
                  },
                  {
                    type: "tab",
                    name: "Style",
                    component: "editor"
                  },
                  {
                    type: "tab",
                    name: "Script",
                    component: "editor"
                  },
                  {
                    type: "tab",
                    name: "Controls",
                    component: "editor"
                  },
                  {
                    type: "tab",
                    name: "Assets",
                    component: "assets"
                  },
                  {
                    type: "tab",
                    name: "Location",
                    component: "location"
                  }
                ]
              }
            ]
          },
          {
            type: "row",
            weight: 50,
            children: [
              {
                type: "tabset",
                weight: 100,
                children: [
                  {
                    type: "tab",
                    name: "Preview",
                    component: "preview",
                    enableClose: false,
                    enableRename: false,
                    enableFloat: true
                  }
                ]
              }
              // {
              //   type: 'tabset',
              //   weight: 100,
              //   children: [
              //   ]
              // },    
            ]
          }
        ]
      }
    };

    const typeToLang = {
      template: "html",
      style: "sass",
      script: "javascript",
      control: "html"
    };
    const editorByType = {};
    const Editor = wp.element.memo(({ type, node, content, focusOnMount = false }) => {
      const ref = wp.element.useRef();
      wp.element.useEffect(() => {
        (async () => {
          const { CodeEditor } = window?.Tangible?.TemplateSystem;
          const el = ref.current;
          el.style = "display: flex; flex-direction: column; height: 100%;";
          const editor = await CodeEditor.create({
            el,
            lang: typeToLang[type] || "html",
            content,
            editorActionsPanel: false
          });
          editorByType[type] = editor;
          editor.node = node;
          if (focusOnMount)
            editor.view.focus();
        })().catch(console.error);
      }, [ref]);
      return /* @__PURE__ */ wp.element.createElement("div", { ref });
    });

    var __defProp$3 = Object.defineProperty;
    var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });

    const Preview = wp.element.memo(({ type, node, onPreviewerReady }) => {
      const ref = wp.element.useRef();
      wp.element.useEffect(() => {
        const el = ref.current;
        console.log("Previewer mount", el);
        return;
      }, []);
      return /* @__PURE__ */ wp.element.createElement("div", { className: "ide-component", ref });
    });
    async function start(options) {
      console.log("start", options);
      const playground = await startPlaygroundWeb(options);
      console.log("playground", playground);
      await playground.isReady();
      return playground;
    }
    __name$3(start, "start");

    const Assets = wp.element.memo(({ type, node }) => {
      return /* @__PURE__ */ wp.element.createElement("div", { className: "ide-component" });
    });

    const Location = wp.element.memo(({ type, node }) => {
      return /* @__PURE__ */ wp.element.createElement("div", { className: "ide-component" });
    });

    const Library = wp.element.memo(({ type, node }) => {
      return /* @__PURE__ */ wp.element.createElement("div", { className: "ide-component" }, /* @__PURE__ */ wp.element.createElement("h2", null, "Local"), /* @__PURE__ */ wp.element.createElement("p", null, "List of templates"), /* @__PURE__ */ wp.element.createElement("h2", null, "Cloud"), /* @__PURE__ */ wp.element.createElement("p", null, "Catalog"));
    });

    const Support = wp.element.memo(({ type, node }) => {
      return /* @__PURE__ */ wp.element.createElement("div", { className: "ide-component" }, /* @__PURE__ */ wp.element.createElement("h2", null, "Keyboard Shortcuts"), /* @__PURE__ */ wp.element.createElement("p", null, "Ctrl or CMD + SPACE - Autocomplete"), /* @__PURE__ */ wp.element.createElement("h2", null, "Language Reference"));
    });

    var __defProp$2 = Object.defineProperty;
    var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
    const IconFullScreenOpen = /* @__PURE__ */ __name$2(() => /* @__PURE__ */ wp.element.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 20 20" }, /* @__PURE__ */ wp.element.createElement("path", { fill: "currentColor", d: "M7 2H2v5l1.8-1.8L6.5 8L8 6.5L5.2 3.8L7 2zm6 0l1.8 1.8L12 6.5L13.5 8l2.7-2.7L18 7V2h-5zm.5 10L12 13.5l2.7 2.7L13 18h5v-5l-1.8 1.8l-2.7-2.8zm-7 0l-2.7 2.7L2 13v5h5l-1.8-1.8L8 13.5L6.5 12z" })), "IconFullScreenOpen");
    const IconFullScreenClose = /* @__PURE__ */ __name$2(() => /* @__PURE__ */ wp.element.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 20 20" }, /* @__PURE__ */ wp.element.createElement("path", { fill: "currentColor", d: "M3.4 2L2 3.4l2.8 2.8L3 8h5V3L6.2 4.8L3.4 2zm11.8 4.2L18 3.4L16.6 2l-2.8 2.8L12 3v5h5l-1.8-1.8zM4.8 13.8L2 16.6L3.4 18l2.8-2.8L8 17v-5H3l1.8 1.8zM17 12h-5v5l1.8-1.8l2.8 2.8l1.4-1.4l-2.8-2.8L17 12z" })), "IconFullScreenClose");

    var __defProp$1 = Object.defineProperty;
    var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
    const fullScreenClassName = "tangible-template-system-builder-expanded";
    function updateFullScreenClass(isFullScreen) {
      const $html = document.documentElement;
      if (isFullScreen) {
        $html.classList.add(fullScreenClassName);
      } else {
        $html.classList.remove(fullScreenClassName);
      }
      window.dispatchEvent(new Event("resize"));
    }
    __name$1(updateFullScreenClass, "updateFullScreenClass");
    function Header({
      layoutModel,
      ideElement
    }) {
      const [screenSize, _setScreenSize] = wp.element.useState(0 /* Default */);
      const setScreenSize = wp.element.useMemo(() => function(size) {
        function update() {
          updateFullScreenClass(
            size === 1 /* Full */ || size === 2 /* FullScreen */
          );
          _setScreenSize(size);
        }
        __name$1(update, "update");
        if (size === 2 /* FullScreen */) {
          if (!document.fullscreenElement) {
            ideElement.requestFullscreen().then(update).catch((e) => {
            });
            return;
          }
        } else if (document.fullscreenElement) {
          document.exitFullscreen();
        }
        update();
      }, [_setScreenSize]);
      return /* @__PURE__ */ wp.element.createElement("div", { className: "ide-header" }, /* @__PURE__ */ wp.element.createElement("div", { className: "ide-header--title" }, /* @__PURE__ */ wp.element.createElement("input", { type: "text", value: "Template name" })), /* @__PURE__ */ wp.element.createElement("div", { className: "ide-header--actions" }, /* @__PURE__ */ wp.element.createElement("button", { className: "ide-header--action" }, "Save"), /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action"
        },
        "Format"
      ), /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action"
        },
        "Export"
      ), /* @__PURE__ */ wp.element.createElement("div", { className: "ide-header--action-separator" }), /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action",
          onClick: () => {
            layoutModel.doAction(Actions.selectTab("library"));
          }
        },
        "Library"
      ), /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action",
          onClick: () => {
            layoutModel.doAction(Actions.selectTab("support"));
          }
        },
        "Support"
      ), screenSize === 2 /* FullScreen */ ? /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action ide-header--action-with-icon",
          onClick: () => setScreenSize(0 /* Default */)
        },
        /* @__PURE__ */ wp.element.createElement(IconFullScreenClose, null)
      ) : /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, screenSize === 1 /* Full */ && /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action ide-header--action-with-icon",
          onClick: () => setScreenSize(2 /* FullScreen */),
          alt: "Full Screen"
        },
        /* @__PURE__ */ wp.element.createElement(IconFullScreenOpen, null)
      ), screenSize === 0 /* Default */ && /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action ide-header--action-with-icon",
          onClick: () => setScreenSize(1 /* Full */),
          alt: "Expand"
        },
        /* @__PURE__ */ wp.element.createElement(IconFullScreenOpen, null)
      ), screenSize === 1 /* Full */ && /* @__PURE__ */ wp.element.createElement(
        "button",
        {
          className: "ide-header--action ide-header--action-with-icon",
          onClick: () => setScreenSize(0 /* Default */),
          alt: "Shrink"
        },
        /* @__PURE__ */ wp.element.createElement(IconFullScreenClose, null)
      ))));
    }
    __name$1(Header, "Header");

    var __defProp = Object.defineProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    window?.Tangible?.TemplateSystem;
    let ideElement = document.getElementById("tangible-template-system-builder");
    if (!ideElement) {
      ideElement = document.createElement("div");
      ideElement.id = "tangible-template-system-builder";
      document.body.prepend(ideElement);
    }
    const templatePost = {
      // content, style, script, controls, ..
    };
    const layoutModel = Model.fromJson(layoutModelData);
    let selectedTabNodeId = "";
    const layoutComponents = {
      Library,
      Support,
      Editor,
      Preview,
      Assets,
      Location
    };
    const getNodeId = /* @__PURE__ */ __name((node) => node._getAttr("id"), "getNodeId");
    const componentFactory = /* @__PURE__ */ __name((node) => {
      const component = node.getComponent();
      const nodeId = getNodeId(node);
      const title = node.getName();
      const slug = title.toLowerCase();
      if (component === "editor") {
        return /* @__PURE__ */ wp.element.createElement(
          Editor,
          {
            type: slug,
            node,
            content: templatePost[slug] || "",
            focusOnMount: nodeId === selectedTabNodeId
          }
        );
      }
      if (layoutComponents[title]) {
        const LayoutComponent = layoutComponents[title];
        return /* @__PURE__ */ wp.element.createElement(LayoutComponent, { node });
      }
    }, "componentFactory");
    const onAction = /* @__PURE__ */ __name((action) => {
      const { type, data } = action;
      if (type === "FlexLayout_SelectTab" && data.tabNode) {
        const nodeId = data.tabNode;
        selectedTabNodeId = nodeId;
        for (const [type2, editor] of Object.entries(editorByType)) {
          if (getNodeId(editor.node) === nodeId) {
            setTimeout(() => {
              editor.view.focus();
            }, 0);
            break;
          }
        }
      }
      return action;
    }, "onAction");
    const onModelChange = /* @__PURE__ */ __name((model) => {
    }, "onModelChange");
    const onRenderTabSet = /* @__PURE__ */ __name((node, renderState) => {
      node._attributes || {};
      for (const childNode of node.getChildren()) {
        const { id, name } = childNode._attributes || {};
        name.toLowerCase();
        return;
      }
    }, "onRenderTabSet");
    async function formatCode({ lang, editor }) {
      const content = editor.view.state.doc.toString();
      try {
        const formattedCode = await editor.format({
          lang,
          content
        });
        const cursorPosition = !formattedCode ? 0 : Math.min(
          editor.view.state.selection.ranges[0].from,
          formattedCode.length - 1
        );
        editor.view.dispatch({
          changes: {
            from: 0,
            to: content.length,
            insert: formattedCode
          }
        });
        editor.view.focus();
        editor.view.dispatch({
          selection: {
            anchor: cursorPosition,
            head: cursorPosition
          }
        });
      } catch (error) {
        console.error(error);
      }
    }
    __name(formatCode, "formatCode");
    document.documentElement.classList.add("tangible-template-system-builder-expanded");
    const App = /* @__PURE__ */ __name(() => {
      wp.element.useEffect(() => {
        document.body.classList.add("ide-loaded");
      }, []);
      return /* @__PURE__ */ wp.element.createElement(wp.element.Fragment, null, /* @__PURE__ */ wp.element.createElement(Header, { layoutModel, ideElement }), /* @__PURE__ */ wp.element.createElement("div", { className: "ide-main" }, /* @__PURE__ */ wp.element.createElement(
        Layout,
        {
          model: layoutModel,
          factory: componentFactory,
          onAction,
          onModelChange,
          onRenderTabSet,
          realtimeResize: true,
          supportsPopout: false
        }
      )));
    }, "App");
    wp.element.render(/* @__PURE__ */ wp.element.createElement(App, null), ideElement);

})();
//# sourceMappingURL=view.min.js.map
