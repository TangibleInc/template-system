(function () {
    'use strict';

    (function() {
        const env = {"NODE_ENV":"development"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    var __defProp = Object.defineProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    async function createTemplateEditor(textarea, options = {}) {
      const { CodeEditor } = window.Tangible.TemplateSystem || {};
      if (!CodeEditor) {
        throw new Error("CodeEditor not found");
      }
      const { language = "html", onSave } = options;
      const listeners = {};
      const editor = await CodeEditor.create({
        // el,
        lang: language,
        content: textarea.value,
        onUpdate(doc) {
          if (listeners["change"]) {
            api.emit("change");
          }
        },
        onSave() {
          if (!onSave)
            return;
          updateTextarea();
          onSave();
        },
        editorActionsPanel: options.editorActionsPanel
      });
      const api = {
        // New editor
        codeMirror6: editor,
        updateTextarea,
        // Legacy editor
        getValue() {
          if (!editor)
            return "";
          return editor.view.state.doc.toString();
        },
        focus() {
          editor && editor.view.focus();
        },
        refresh() {
        },
        setSize(width, height) {
        },
        on(eventName, callback) {
          if (!listeners[eventName]) {
            listeners[eventName] = [];
          }
          listeners[eventName].push(callback);
        },
        emit(eventName, ...args) {
          if (listeners[eventName]) {
            for (const listener of listeners[eventName]) {
              listener(...args);
            }
          }
        },
        off(eventName, callback) {
          if (listeners[eventName]) {
            listeners[eventName] = listeners[eventName].filter(
              (f) => f !== callback
            );
          }
        }
      };
      const containterClass = "tangible-template-editor-container";
      if (!textarea.parentNode?.classList.contains(containterClass)) {
        textarea.parentNode?.classList.add(containterClass);
      }
      function updateTextarea() {
        textarea.value = editor.view.state.doc.toString();
      }
      __name(updateTextarea, "updateTextarea");
      textarea.parentNode?.insertBefore(editor.view.dom, textarea);
      if (textarea.form) {
        textarea.form.addEventListener("submit", () => updateTextarea());
      }
      return api;
    }
    __name(createTemplateEditor, "createTemplateEditor");

    window.Tangible = window.Tangible || {};
    window.Tangible.createCodeEditor = createTemplateEditor;

})();
//# sourceMappingURL=template-editor-bridge.min.js.map
