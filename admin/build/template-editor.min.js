(function () {
    'use strict';

    (function() {
        const env = {"NODE_ENV":"development"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    var __defProp$3 = Object.defineProperty;
    var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });
    const memoryKey = "tangibleTemplateEditorState";
    const memory = Object.assign(
      {
        tab: void 0,
        // Default tab
        postId: 0,
        // ?
        theme: "default",
        fontFamily: "default",
        fontSize: 14
      },
      getMemory() || {}
    );
    function setMemory(state) {
      if (!window.localStorage)
        return;
      Object.assign(memory, state);
      window.localStorage.setItem(memoryKey, JSON.stringify(memory));
    }
    __name$3(setMemory, "setMemory");
    function getMemory() {
      if (!window.localStorage)
        return;
      let state = window.localStorage.getItem(memoryKey);
      if (!state)
        return;
      try {
        state = JSON.parse(state);
        return state;
      } catch (e) {
      }
    }
    __name$3(getMemory, "getMemory");

    var __defProp$2 = Object.defineProperty;
    var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
    function handleTabs({
      $,
      postId,
      $postForm,
      editorInstances,
      renderPreview
    }) {
      const $tabSelectors = $postForm.find(".tangible-template-tab-selector");
      const $tabs = $postForm.find(".tangible-template-tab");
      const tabEditorActivated = [];
      if (!$tabs.length) {
        console.warn("No tabs elements found for Tangible Template code editor");
        return;
      }
      $tabSelectors.on("click", function() {
        const currentTabSelector = this;
        $tabSelectors.each(function(index) {
          const $tabSelector = $(this);
          const tabName = $tabSelector.data("tabName");
          const $tab = $tabs.eq(index);
          if (this !== currentTabSelector) {
            $tabSelector.removeClass("active");
            $tab.hide();
            return;
          }
          $tabSelector.addClass("active");
          $tab.show();
          const $tabEditor = $tab.find("[data-tangible-template-editor-type]");
          const editorInstance = $tabEditor.length ? editorInstances[
            $tabEditor.attr("name")
            // By field name
          ] : false;
          if (!tabEditorActivated[index]) {
            tabEditorActivated[index] = true;
            if (editorInstance) {
              editorInstance.refresh();
            }
          }
          if (editorInstance) {
            editorInstance.focus();
          }
          if (tabName === "preview") {
            renderPreview($tab[0]);
          }
          setMemory({
            tab: tabName,
            postId
          });
        });
      });
      const query = window.location.search.substr(1).split("&").reduce(function(obj, pair) {
        const [key, value] = pair.split("=");
        obj[key] = value;
        return obj;
      }, {});
      const gotoTab = query.tab || memory.postId === postId && memory.tab;
      if (gotoTab) {
        const $activeTabSelector = $tabSelectors.filter(
          `[data-tab-name="${gotoTab}"]`
        );
        if ($activeTabSelector.length) {
          $activeTabSelector.eq(0).click();
        }
      }
    }
    __name$2(handleTabs, "handleTabs");

    var __defProp$1 = Object.defineProperty;
    var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
    async function createEditors({
      $,
      save,
      $editors,
      editorInstances,
      createCodeEditor,
      templateMeta,
      Tangible
    }) {
      const sharedEditorOptions = {
        // New editor
        onSave: save,
        // Legacy editor
        viewportMargin: Infinity,
        // With .CodeMirror height: auto or 100%
        resizable: false,
        lineWrapping: true,
        extraKeys: {
          "Alt-F": "findPersistent",
          "Ctrl-S": save,
          "Cmd-S": save,
          Tab: "emmetExpandAbbreviation",
          Esc: "emmetResetAbbreviation",
          Enter: "emmetInsertLineBreak",
          "Ctrl-Space": "autocomplete"
        }
      };
      async function create(el) {
        const $editor = $(el);
        const fieldName = $editor.attr("name");
        const type = $editor.data("tangibleTemplateEditorType");
        const editorOptions = {
          ...sharedEditorOptions,
          language: type
        };
        if (type === "html") {
          editorOptions.emmet = {
            preview: false
          };
        }
        const editor = editorInstances[fieldName] = await createCodeEditor(
          el,
          editorOptions
        );
        editor.setSize(null, "100%");
        if (fieldName === "post_content" && !templateMeta.isNewPost)
          editor.focus();
        el.editor = editor;
        editor.save = save;
        if (!editor.codeMirror6)
          return;
      }
      __name$1(create, "create");
      const promises = [];
      $editors.each(function() {
        promises.push(create(this));
      });
      await Promise.all(promises);
    }
    __name$1(createEditors, "createEditors");

    var __defProp = Object.defineProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    window.jQuery(function($) {
      const $postForm = $("#post");
      const $editors = $postForm.find("[data-tangible-template-editor-type]");
      if (!$editors.length) {
        console.warn("No editor elements found for Tangible Template code editor");
        return;
      }
      const { wp } = window;
      if (wp && wp.autosave && wp.autosave.server && wp.autosave.server.postChanged) {
        wp.autosave.server.postChanged = function() {
          return false;
        };
      }
      const { Tangible } = window;
      const {
        ajax,
        // Provide new editor compatibility layer
        createCodeEditor
      } = Tangible;
      Tangible.codeEditors = [];
      const editorInstances = {
        // fieldName: editor instance
      };
      const postId = $("#post_ID").val();
      const $postTitle = $postForm.find('input[name="post_title"]');
      const $publishButton = $("#publish");
      const $publishingActions = $publishButton.closest("#major-publishing-actions");
      const templateMeta = $postForm.find("#tangible-template-editor-meta").data("json") || {};
      const additionalFieldNames = [
        "name",
        "assets",
        "location",
        "theme_position",
        "theme_header",
        "theme_footer",
        "universal_id"
      ];
      const $additionalFields = {
        // name?: $element
      };
      for (const fieldName of additionalFieldNames) {
        const $field = $postForm.find(`[name="${fieldName}"]`);
        if ($field.length) {
          $additionalFields[fieldName] = $field;
        }
      }
      const taxonomyNames = ["tangible_template_category"];
      const $taxonomyFields = {
        // name?: $terms
      };
      for (const taxName of taxonomyNames) {
        const $terms = $postForm.find(
          `[type="checkbox"][name="tax_input[${taxName}][]"]`
        );
        if ($terms.length) {
          $taxonomyFields[taxName] = $terms;
          $terms.each(function() {
            const checked = this.getAttribute("checked") === "checked";
            $(this).prop("checked", checked);
          });
        }
      }
      const updatePublishButton = /* @__PURE__ */ __name(function(newText, errorMessage = "") {
        $publishButton.val(newText);
        if (errorMessage) {
          $publishingActions.append(
            `<div id="post-save-error-message" style="padding-top: 8px">${errorMessage}</div>`
          );
        } else {
          $publishingActions.find("#post-save-error-message").remove();
        }
      }, "updatePublishButton");
      const getEditorFields = /* @__PURE__ */ __name(function() {
        const data = {};
        for (let fieldName in editorInstances) {
          const editor = editorInstances[fieldName];
          if (fieldName === "post_content")
            fieldName = "content";
          const value = editor.getValue();
          data[fieldName] = value;
        }
        return data;
      }, "getEditorFields");
      const getAdditionalFields = /* @__PURE__ */ __name(function() {
        const data = {};
        for (const fieldName of additionalFieldNames) {
          if (!$additionalFields[fieldName])
            continue;
          data[fieldName] = $additionalFields[fieldName].val();
        }
        return data;
      }, "getAdditionalFields");
      const getTaxonomyFields = /* @__PURE__ */ __name(function() {
        const data = {};
        for (const taxName of taxonomyNames) {
          if (!$taxonomyFields[taxName])
            continue;
          data[taxName] = [];
          $taxonomyFields[taxName].each(function() {
            const $el = $(this);
            if ($el.prop("checked")) {
              data[taxName].push($el.val());
            }
          });
        }
        return data;
      }, "getTaxonomyFields");
      function save() {
        if (templateMeta.isNewPost) {
          $publishButton.click();
          return;
        }
        if (!postId)
          return;
        const title = $postTitle.val();
        if (!title)
          return;
        const data = {
          title,
          id: postId,
          content: "",
          ...getEditorFields(),
          ...getAdditionalFields(),
          tax_input: getTaxonomyFields()
        };
        const previousLabel = $publishButton.val();
        let labelTimer;
        function restorePreviousLabelAfterTimeout() {
          if (labelTimer)
            clearTimeout(labelTimer);
          labelTimer = setTimeout(function() {
            $publishButton.val(previousLabel);
          }, 7e3);
        }
        __name(restorePreviousLabelAfterTimeout, "restorePreviousLabelAfterTimeout");
        ajax("tangible_template_editor_save", data).then(function(res) {
          updatePublishButton("Saved");
          restorePreviousLabelAfterTimeout();
        }).catch(function(e) {
          updatePublishButton("Error", e.message);
          restorePreviousLabelAfterTimeout();
        });
      }
      __name(save, "save");
      if (!templateMeta.isNewPost && templateMeta.postStatus === "publish") ;
      function setIframeContent(iframe, content) {
        iframe.contentWindow.document;
        iframe.contentWindow.document.open();
        iframe.contentWindow.document.write(content);
        iframe.contentWindow.document.close();
      }
      __name(setIframeContent, "setIframeContent");
      async function renderPreview(el) {
        const data = {
          id: postId,
          content: "",
          ...getEditorFields(),
          ...getAdditionalFields()
        };
        let iframe = el.getElementsByTagName("iframe")[0];
        if (!iframe) {
          iframe = document.createElement("iframe");
          iframe.style.width = "100%";
          iframe.style.height = "100%";
          iframe.style.minHeight = "380px";
          el.style.resize = "vertical";
          el.style.overflowY = "auto";
          el.appendChild(iframe);
        }
        ajax("tangible_template_editor_render", data).then(function(res) {
          setIframeContent(iframe, res.result);
        }).catch(function(e) {
          setIframeContent(iframe, `<p>${e.message}</p>`);
        });
      }
      __name(renderPreview, "renderPreview");
      createEditors({
        $,
        save,
        $editors,
        editorInstances,
        createCodeEditor,
        templateMeta,
        Tangible
      }).finally(function() {
        handleTabs({
          $,
          postId,
          $postForm,
          editorInstances,
          renderPreview
        });
      });
    });

})();
//# sourceMappingURL=template-editor.min.js.map
